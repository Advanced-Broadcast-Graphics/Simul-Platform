#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/simul_inscatter_fns.sl"
#include "../../CrossPlatform/SL/simul_cloud_constants.sl"
#include "../../CrossPlatform/SL/depth.sl"
#include "saturate.glsl"
#include "../../CrossPlatform/SL/noise.sl"
#include "../../CrossPlatform/SL/noise_constants.sl"
uniform sampler2D noise_texture;

shader VS_FullScreen(in int gl_VertexID,in vec4 gl_Vertex,out vec2 texCoords)
{
    vec2 pos		=vec2(-1.0,-1.0)+gl_Vertex.xy*2.0;
	gl_Position		=vec4(pos.xy,1.0,1.0);
    texCoords		=gl_Vertex.xy;
}

shader PS_Noise(in vec2 texCoords)
{
    vec4 c=vec4(rand(texCoords),rand(1.7*texCoords),rand(0.11*texCoords),rand(513.1*texCoords));
    gl_FragColor=c;
}

shader PS_EdgeNoise(in vec2 texCoords,out vec4 gl_FragColor)
{
	gl_FragColor=Noise(noise_texture,texCoords,persistence,octaves);
}

uniform sampler3D cloudDensity1;
uniform sampler3D cloudDensity2;
uniform sampler2D noiseSampler;
uniform sampler2D lossSampler;
uniform sampler2D inscatterSampler;
uniform sampler2D skylightSampler;
uniform sampler3D illumSampler;
uniform sampler2D depthTexture;

uniform sampler3D cloudDensity;

uniform sampler2D gColorMap;


shader PS_CloudShadow(in vec2 texCoords)
{
	vec3 texcoord=vec3(texCoords.xy,0.0);
	vec4 density=texture3D(cloudDensity1,texcoord);
	vec4 density2=texture3D(cloudDensity2,texcoord);
	density					=mix(density,density2,cloud_interp);
    gl_FragColor=density;
}

shader VS_Layers(in vec3 vertex
				,out float layerDensity
				,out float rainFade
				,out vec4 texCoords
				,out vec2 noise_texc
				,out vec3 wPosition
				,out vec3 texCoordLightning
				,out vec2 fade_texc
				,out vec3 view
				,out vec4 transformed_pos)
{
	LayerData layer		=layers[layerIndex];
	vec3 pos			=vertex.xyz*layerDistance_;

    wPosition			=pos.xyz;
    transformed_pos		=vec4(vertex.xyz,1.0)*worldViewProj;
#if 0
	gl_Position	=vec4(vec2(-1.0,-1.0)+2.0*vertex.xy,1.0,1.0);
#else
    gl_Position			=transformed_pos;
	gl_Position.z		=gl_Position.w;
#endif
	layerDensity		=layer.layerFade;
	texCoordLightning	=(wPosition.xyz-lightningOrigin.xyz)*lightningInvScales.xyz;
	float depth			=length(pos)/maxFadeDistanceMetres;
	view				=normalize(pos);
	wPosition			=viewPos+pos;
	wPosition.z			-=layer.verticalShift;
	texCoords.xyz		=(wPosition-vec3(0,0,layer.verticalShift)-cornerPos)*inverseScales;
	texCoords.w			=clamp(texCoords.z,0.0,1.0);	// clamp?
	vec2 screen_pos		=transformed_pos.xy/transformed_pos.w;
	vec3 n				=vec3(screen_pos.xy*tanHalfFov,1.0);
	n					=normalize(n);
	vec2 noise_texc_0	=(noiseMatrix*vec4(n.xy,0.0,0.0)).xy;

	noise_texc			=noise_texc_0.xy*layerDistance_/fractalRepeatLength+noiseOffset_;

	float sine			=view.z;
	fade_texc			=vec2(sqrt(depth),0.5*(1.0-sine));
	rainFade			=1.0-exp(-layer.layerDistance/10000.0);
}

vec4 Layers(float layerDensity,
			float rainFade,
			vec4 texCoords,
			vec2 noise_texc,
			vec3 wPosition,
			vec3 texCoordLightning,
			vec2 fade_texc,
			vec3 view,
			vec4 transformed_pos
			,float dist)
{
	vec3 half_vec			=vec3(0.5,0.5,0.5);//0.49803921568627452,0.49803921568627452,0.49803921568627452);
	float cos0				=dot(directionToSun.xyz,normalize(view.xyz));

	float cloud_dist		=pow(fade_texc.x,2.0);
	vec4 texc				=texCoords;
#ifdef TILING_OFFSET
	vec2 tiling_offset		=texture(noiseSampler,texc.xy/64.0).xy;
	texc.xy					+=2.0*(tiling_offset.xy-noise_offset.xy);
#endif
	vec3 noiseval			=2.0*(textureLod(noiseSampler,noise_texc.xy,0).xyz-half_vec);
	noiseval				*=texc.w;
	vec3 pos				=texc.xyz+fractalScale*noiseval;
	vec4 density			=textureLod(cloudDensity1,pos,0);
	vec4 density2			=textureLod(cloudDensity2,pos,0);
	density					=mix(density,density2,cloud_interp);
	float opacity			=layerFade_*density.y;
	if(opacity<=0.0)
		discard;
	if(dist<cloud_dist)
		discard;
	float Beta					=lightResponse.x*HenyeyGreenstein(cloudEccentricity*density.z,cos0);
	vec3 sunlightColour			=mix(sunlightColour1,sunlightColour2,saturate(texCoords.z));
	vec3 final					=(density.z*Beta+lightResponse.y*density.w)*sunlightColour*earthshadowMultiplier+density.x*ambientColour.rgb;
	
	vec3 diff					=wPosition.xyz-lightningSourcePos;
	float dist_from_lightning	=length(diff.xyz);
	float cc					=dist_from_lightning/2000.0;
	float pwr					=exp(-cc*cc);
	final.rgb					+=lightningColour.rgb*pwr;

	vec3 loss_lookup			=texture(lossSampler,fade_texc).rgb;
	vec4 insc_lookup			=earthshadowMultiplier*texture(inscatterSampler,fade_texc);
	vec3 skyl_lookup			=texture(skylightSampler,fade_texc).rgb;

	final.rgb					*=loss_lookup;
	final.rgb					+=InscatterFunction(insc_lookup,hazeEccentricity,cos0,mieRayleighRatio);
	final.rgb					+=skyl_lookup;
	//final.rgb=vec3(cloud_dist,cloud_dist,cloud_dist);
    return				vec4(final.rgb*opacity*exposure,1.0-opacity);
}


shader PS_Layers(in float layerDensity,
			in float rainFade,
			in vec4 texCoords,
			in vec2 noise_texc,
			in vec3 wPosition,
			in vec3 texCoordLightning,
			in vec2 fade_texc,
			in vec3 view,
			in vec4 transformed_pos)
{
	 gl_FragColor	=Layers(layerDensity,
						rainFade,
						texCoords,
						noise_texc,
						wPosition,
						texCoordLightning,
						fade_texc,
						view,
						transformed_pos
						,1.0);
}
shader PS_Layers_depth(in float layerDensity,
			in float rainFade,
			in vec4 texCoords,
			in vec2 noise_texc,
			in vec3 wPosition,
			in vec3 texCoordLightning,
			in vec2 fade_texc,
			in vec3 view,
			in vec4 transformed_pos)
{
	vec2 clip_pos			=transformed_pos.xy/transformed_pos.w;
	vec2 screenCoord		=screenCoordOffset+0.5*(clip_pos.xy)+vec2(0.5,0.5);
	float depth				=texture(depthTexture,screenCoord).x;
	float dist				=depthToFadeDistance(depth,clip_pos.xy,depthToLinFadeDistParams,tanHalfFov);

    gl_FragColor	=Layers(layerDensity,
						rainFade,
						texCoords,
						noise_texc,
						wPosition,
						texCoordLightning,
						fade_texc,
						view,
						transformed_pos
						,dist);
}


shader VS_CrossSection(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]=vec2(1.0, 0.0);
	poss[1]=vec2(1.0, 1.0);
	poss[3]=vec2(0.0, 1.0);
	poss[2]=vec2(0.0, 0.0);
	vec2 pos		=poss[gl_VertexID];
	gl_Position	=vec4(rect.xy+pos.xy*rect.zw,1.0,1.0);
    texCoords	=pos.xy;
}

#define CROSS_SECTION_STEPS 32
shader PS_CrossSection(in vec2 texCoords, out vec4 FragColor)
{
	vec3 texc=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i=0;
	vec3 accum=vec3(0.0,0.5,1.0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density=texture3D(cloudDensity,texc);
		vec3 colour=vec3(.5,.5,.5)*(lightResponse.x*density.z+lightResponse.y*density.w);
		colour.gb+=vec2(.125,.25)*(lightResponse.z*density.x);
		float opacity=density.y;
		colour*=opacity;
		accum*=1.0-opacity;
		accum+=colour;
		texc.y=texc.y+1.0/float(CROSS_SECTION_STEPS)*(1.0-yz);
		texc.z=texc.z+1.0/float(CROSS_SECTION_STEPS)*yz;
	}
	//accum=texture3D(cloud_density,vec3(crossSectionOffset+texCoords.x,crossSectionOffset+texCoords.y,0.35)).rgb;
    FragColor=vec4(accum,1);
}

program layers
{
    vs(430) = VS_Layers();
    fs(430) = PS_Layers();
};

program layers_depth
{
    vs(430) = VS_Layers();
    fs(430) = PS_Layers_depth();
};

program cloud_shadow
{
    vs(410) = VS_FullScreen();
    fs(410) = PS_CloudShadow();
};

program cross_section
{
    vs(410) = VS_CrossSection();
    fs(410) = PS_CrossSection();
};

program noise
{
	vs(410)=VS_FullScreen();
	fs(410)=PS_Noise();
};

program edge_noise
{
	vs(410)=VS_FullScreen();
	fs(410)=PS_EdgeNoise();
};
