#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/simul_cloud_constants.sl"

uniform sampler3D cloudDensity1;
uniform sampler3D cloudDensity2;
uniform sampler2D noiseSampler;
uniform sampler2D lossSampler;
uniform sampler2D inscatterSampler;
uniform sampler2D skylightSampler;
uniform sampler3D illumSampler;
uniform sampler2D depthTexture;

uniform sampler3D cloudDensity;

uniform mat4 gWVP;
uniform sampler2D gColorMap;

shader VS_CrossSection(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]=vec2(1.0, 0.0);
	poss[1]=vec2(1.0, 1.0);
	poss[2]=vec2(0.0, 1.0);
	poss[3]=vec2(0.0, 0.0);
	vec2 pos		=poss[gl_VertexID];
	gl_Position	=vec4(rect.xy+pos.xy*rect.zw,1.0,1.0);
    texCoords	=pos.xy;
}

#define CROSS_SECTION_STEPS 32
shader PS_CrossSection(in vec2 texCoords, out vec4 FragColor)
{
	vec3 texc=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i=0;
	vec3 accum=vec3(0.0,0.5,1.0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density=texture3D(cloudDensity,texc);
		vec3 colour=vec3(.5,.5,.5)*(lightResponse.x*density.z+lightResponse.y*density.w);
		colour.gb+=vec2(.125,.25)*(lightResponse.z*density.x);
		float opacity=density.y;
		colour*=opacity;
		accum*=1.0-opacity;
		accum+=colour;
		texc.y=texc.y+1.0/float(CROSS_SECTION_STEPS)*(1.0-yz);
		texc.z=texc.z+1.0/float(CROSS_SECTION_STEPS)*yz;
	}
	//accum=texture3D(cloud_density,vec3(crossSectionOffset+texCoords.x,crossSectionOffset+texCoords.y,0.35)).rgb;
    FragColor=vec4(accum,1);
}

program cross_section
{
    vs(410) = VS_CrossSection();
    fs(410) = PS_CrossSection();
};
