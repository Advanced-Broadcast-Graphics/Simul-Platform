#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/simul_terrain_constants.sl"
#include "../../CrossPlatform/SL/cloud_shadow.sl"
uniform sampler2DArray textureArray;

interface VSOutput
{
	vec3 wPosition;
	vec2 texcoord;
};

shader VS_Terrain(in vec3 vertex, out VSOutput OUT)
{
    gl_Position		=worldViewProj*vec4(vertex,1.0);
	OUT.wPosition = vertex;
	OUT.texcoord = vec2(OUT.wPosition.xy / 2000.0);
}

shader GS_Terrain()
{
	//increment variable
	int i;
	/////////////////////////////////////////////////////////////
	//This example has two parts
	//	step a) draw the primitive pushed down the pipeline
	//		 there are gl_Vertices # of vertices
	//		 put the vertex value into gl_Position
	//		 use EmitVertex => 'create' a new vertex
	// 		use EndPrimitive to signal that you are done creating a primitive!
	//	step b) create a new piece of geometry (I.E. WHY WE ARE USING A GEOMETRY SHADER!)
	//		I just do the same loop, but swizzle the x and y values
	//	result => the line we want to draw, and the same line, but along the other axis

	//Pass-thru!
	for(i=0; i< gl_VerticesIn; i++)
	{
		gl_Position = gl_PositionIn[i];
		EmitVertex();
	}
	EndPrimitive();																						
	//New piece of geometry!  We just swizzle the x and y terms
	for(i=0; i< gl_VerticesIn; i++){
		gl_Position = gl_PositionIn[i];
		gl_Position.xy = gl_Position.yx;
		EmitVertex();
	}
	EndPrimitive();	
}

float approx_oren_nayar(float roughness,vec3 view,vec3 normal,vec3 lightDir)
{
	float roughness2 = roughness * roughness;
	vec2 r2=vec2(roughness2,roughness2);
	vec2 oren_nayar_fraction = r2/(r2+ vec2(0.33, 0.09));
	vec2 oren_nayar = vec2(1, 0) + vec2(-0.5, 0.45) * oren_nayar_fraction;
	// Theta and phi
	vec2 cos_theta = saturate(vec2(dot(normal, lightDir), dot(normal, view)));
	vec2 cos_theta2 = cos_theta * cos_theta;
	float u=saturate((1.0-cos_theta2.x) * (1.0-cos_theta2.y));
	float sin_theta = sqrt(u);
	vec3 light_plane = normalize(lightDir - cos_theta.x * normal);
	vec3 view_plane = normalize(view - cos_theta.y * normal);
	float cos_phi = saturate(dot(light_plane, view_plane));
	// Composition
	float diffuse_oren_nayar = cos_phi * sin_theta / max(0.00001,max(cos_theta.x, cos_theta.y));
	float diffuse = cos_theta.x * (oren_nayar.x + oren_nayar.y * diffuse_oren_nayar);
	return diffuse;
}

shader PS_Terrain(in VSOutput IN, out vec4 FragColour)
{
	vec4 result;
	vec2 texcoord	= vec2(IN.wPosition.xy / 2000.0);
	vec4 layer1 = texture(textureArray, vec3(IN.texcoord, 0.0));
	vec4 layer2 = texture(textureArray, vec3(IN.texcoord, 1.0));
	vec4 texel = mix(layer1, layer2, clamp(1.0 - IN.wPosition.z / 100.0, 0.0, 1.0));
	result.rgb		=texel.rgb*lightDir.z*sunlight;
	// Distance
	result.a=1.0;
    FragColour=result;
}


program terrain
{
    vs(430) = VS_Terrain();
    fs(430) = PS_Terrain();
}
