#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/simul_inscatter_fns.sl"
#include "../../CrossPlatform/SL/simul_gpu_sky.sl"

uniform sampler2D input_loss_texture;
uniform sampler2D density_texture;
uniform sampler3D loss_texture;
uniform sampler3D insc_texture;
uniform sampler3D source_texture;
uniform sampler2D optical_depth_texture;
uniform sampler2D input_skyl_texture;
uniform sampler2D blackbody_texture;
uniform sampler2D input_insc_texture;
layout(rgba32f,binding = 0) uniform image3D targetTexture;

uniform float tz;
shader void PS_Loss(in vec2 texCoords)
{
	gl_FragColor	=PSLoss(input_loss_texture,density_texture,texCoords.xy);
}

shader void PS_Insc(in vec2 texCoords,out vec4 outColor)
{
	vec4 res		=Insc(input_insc_texture,loss_texture,density_texture,optical_depth_texture,texCoords);
	outColor		=res;
}

// What spectral radiance is added on a light path towards the viewer, due to illumination of
// a volume of air by the surrounding sky?
// in cpp:
//	float cos0=dir_to_sun.z;
//	Skylight=GetAnisotropicInscatterFactor(true,hh,pif/2.f,0,1e5f,dir_to_sun,dir_to_moon,haze,false,1);
//	Skylight*=GetInscatterAngularMultiplier(cos0,Skylight.w,hh);
vec3 getSkylight(float alt_km)
{
// The inscatter factor, at this altitude looking straight up, is given by:
	vec4 insc		=texture(insc_texture,vec3(sqrt(alt_km/maxOutputAltKm),0.0,1.0));
	vec3 skylight	=InscatterFunction(insc,hazeEccentricity,0.0,mieRayleighRatio);
	return skylight;
//	return vec3(.05,.1,.2);
}

shader void PS_Skyl(in vec2 texCoords,out vec4 outColor)
{
	vec4 previous_skyl	=texture(input_skyl_texture,texCoords.xy);
	vec3 previous_loss	=texture(loss_texture,vec3(texCoords.xy,pow(distanceKm/maxDistanceKm,0.5))).rgb;
	// should adjust texc - we want the PREVIOUS loss!
	float sin_e			=1.0-2.0*(texCoords.y*texSize.y-texelOffset)/(texSize.y-1.0);
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(texCoords.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);

	outColor			=Skyl(insc_texture
							,density_texture
							,blackbody_texture
							,previous_loss
							,previous_skyl
							,maxOutputAltKm
							,maxDistanceKm
							,maxDensityAltKm
							,spaceDistKm
							,viewAltKm
							,distanceKm
							,prevDistanceKm
							,sin_e
							,cos_e);
}

shader void PS_Copy(in vec2 texCoords,out vec4 outColor)
{
	outColor			=texture(source_texture,vec3(texCoords.xy,tz));
}

shader CS_LAYOUT(8,1,1) void CS_Loss() 
{
	uint3 sub_pos		=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=uint3(LinearThreadToPos2D(linear_pos,int3(targetSize)));
	CSLoss(targetTexture,density_texture,pos,maxOutputAltKm,maxDistanceKm,maxDensityAltKm,targetSize);
}

shader CS_LAYOUT(1,1,1) void CS_LightTable()
{
	uint3 sub_pos	=gl_GlobalInvocationID;
	MakeLightTable(targetTexture,insc_texture,optical_depth_texture,sub_pos,uint3(targetSize));
}

shader CS_LAYOUT(8,1,1) void CS_Insc()
{
	uint3 sub_pos		=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=uint3(LinearThreadToPos2D(linear_pos,int3(targetSize)));
	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
		return;
	CSInsc(targetTexture,density_texture,optical_depth_texture,loss_texture,pos,maxOutputAltKm,maxDistanceKm,maxDensityAltKm,targetSize);
}

shader CS_LAYOUT(8,1,1) void CS_Skyl()
{
	uint3 sub_pos=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=LinearThreadToPos2D(linear_pos,targetSize);
	CSSkyl(targetTexture,loss_texture,insc_texture,density_texture,blackbody_texture,pos,maxOutputAltKm,maxDistanceKm,maxDensityAltKm,targetSize);
	
}

program simul_gpu_loss
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Loss();
};

program simul_gpu_insc
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Insc();
};

program simul_gpu_skyl
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Skyl();
};

program copy
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Copy();
};

program gpu_light_table_compute
{
    cs(430)=CS_LightTable();
};

program gpu_loss_compute
{
   cs(430)=CS_Loss();
};

program gpu_insc_compute
{
    cs(430)=CS_Insc();
};

program gpu_skyl_compute
{
    cs(430)=CS_Skyl();
};