#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/simul_inscatter_fns.sl"
#include "../../CrossPlatform/SL/simul_gpu_sky.sl"

uniform sampler2D input_loss_texture;
uniform sampler2D density_texture;
uniform sampler3D loss_texture;
uniform sampler3D insc_texture;
uniform sampler3D source_texture;
uniform sampler2D optical_depth_texture;
uniform sampler2D input_skyl_texture;
uniform sampler2D blackbody_texture;
uniform sampler2D input_insc_texture;

layout(rgba32f,binding = 0) uniform image3D targetTexture;

shader VS_FullScreen(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]			=vec2(1.0,0.0);
	poss[1]			=vec2(1.0,1.0);
	poss[2]			=vec2(0.0,0.0);
	poss[3]			=vec2(0.0,1.0);
	vec2 pos		=poss[gl_VertexID];
	pos.y			=yRange.x+pos.y*yRange.y;
	vec4 vert_pos	=vec4(vec2(-1.0,-1.0)+2.0*vec2(pos.x,pos.y),1.0,1.0);
	gl_Position		=vert_pos;
    texCoords		=pos.xy;
}

shader PS_Loss(in vec2 texCoords)
{
	gl_FragColor	=PSLoss(input_loss_texture,density_texture,texCoords.xy);
}

shader PS_Insc(in vec2 texCoords,out vec4 outColor)
{
	vec4 res		=Insc(input_insc_texture,loss_texture,density_texture,optical_depth_texture,texCoords);
	outColor		=res;
}

// What spectral radiance is added on a light path towards the viewer, due to illumination of
// a volume of air by the surrounding sky?
// in cpp:
//	float cos0=dir_to_sun.z;
//	Skylight=GetAnisotropicInscatterFactor(true,hh,pif/2.f,0,1e5f,dir_to_sun,dir_to_moon,haze,false,1);
//	Skylight*=GetInscatterAngularMultiplier(cos0,Skylight.w,hh);
vec3 getSkylight(float alt_km)
{
// The inscatter factor, at this altitude looking straight up, is given by:
	vec4 insc		=texture(insc_texture,vec3(sqrt(alt_km/maxOutputAltKm),0.0,1.0));
	vec3 skylight	=InscatterFunction(insc,hazeEccentricity,0.0,mieRayleighRatio);
	return skylight;
//	return vec3(.05,.1,.2);
}

shader PS_Skyl(in vec2 texCoords,out vec4 outColor)
{
	vec4 previous_skyl	=texture(input_skyl_texture,texCoords.xy);
	vec3 previous_loss	=texture(loss_texture,vec3(texCoords.xy,pow(distanceKm/maxDistanceKm,0.5))).rgb;
	// should adjust texc - we want the PREVIOUS loss!
	float sin_e			=1.0-2.0*(texCoords.y*texSize.y-texelOffset)/(texSize.y-1.0);
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(texCoords.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);

	outColor			=Skyl(insc_texture
							,density_texture
							,blackbody_texture
							,previous_loss
							,previous_skyl
							,maxOutputAltKm
							,maxDistanceKm
							,maxDensityAltKm
							,spaceDistKm
							,viewAltKm
							,distanceKm
							,prevDistanceKm
							,sin_e
							,cos_e);
}

uniform float tz;

shader PS_Copy(in vec2 texCoords,out vec4 outColor)
{
	outColor			=texture(source_texture,vec3(texCoords.xy,tz));
}

shader CS_LAYOUT(8,1,1) CS_Loss() 
{
	uint3 sub_pos		=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=uint3(LinearThreadToPos2D(linear_pos,uint3(targetSize)));
	CSLoss(targetTexture,density_texture,pos,maxOutputAltKm,maxDistanceKm,maxDensityAltKm,targetSize);
}

shader CS_LAYOUT(8,1,1) CS_LightTable(  )
{
	uint3 sub_pos	=gl_GlobalInvocationID;
	MakeLightTable(targetTexture,insc_texture,optical_depth_texture,sub_pos,uint3(targetSize));
}

shader CS_LAYOUT(8,1,1) CS_Insc(  )
{
	uint3 sub_pos		=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	
	int3 pos			=LinearThreadToPos2D(linear_pos,targetSize);
	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
		return;
	
	vec2 texc			=(pos.xy+0.5)/vec2(targetSize.xy);

	vec4 previous_insc	=vec4(0.0,0.0,0.0,0.0);
	float sin_e			=max(-1.0,min(1.0,1.0-2.0*(texc.y*texSize.y-texelOffset)/(texSize.y-1.0)));
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(texc.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);
	
	float prevDist_km	=0.0;
	
	IMAGESTORE(targetTexture,pos,previous_insc);
	vec3 mie_factor		=vec3(1.0,1.0,1.0);
	for(int i=1;i<targetSize.z;i++)
	{
		uint3 idx			=uint3(pos.xy,i);
		float zPosition		=pow(float(i)/(float(targetSize.z)-1.0),2.0);
		
		vec3 previous_loss	=vec3(1,0,0);//IMAGE_LOAD(loss_texture,int3(idx)).rgb;

		float dist_km		=zPosition*maxDistanceKm;
		if(i==targetSize.z-1)
			dist_km=1000.0;
		float maxd			=min(spaceDistKm,dist_km);
		float mind			=min(spaceDistKm,prevDist_km);
		float dist			=0.5*(mind+maxd);
		float stepLengthKm	=max(0.0,maxd-mind);
		float y				=planetRadiusKm+viewAltKm+dist*sin_e;
		float x				=dist*cos_e;
		float r				=sqrt(x*x+y*y);
		float alt_km		=r-planetRadiusKm;
	
		float x1			=mind*cos_e;
		float r1			=sqrt(x1*x1+y*y);
		float alt_1_km		=r1-planetRadiusKm;
	
		float x2			=maxd*cos_e;
		float r2			=sqrt(x2*x2+y*y);
		float alt_2_km		=r2-planetRadiusKm;
	
		// lookups is: dens_factor,ozone_factor,haze_factor;
		float dens_texc		=(alt_km/maxDensityAltKm*(tableSize.x-1.0)+texelOffset)/tableSize.x;
		vec4 lookups		=texture_clamp_lod(density_texture,vec2(dens_texc,0.5),0);
		float dens_factor	=lookups.x;
		float ozone_factor	=lookups.y;
		float haze_factor	=getHazeFactorAtAltitude(alt_km);
		vec4 light			=vec4(sunIrradiance,1.0)*getSunlightFactor(optical_depth_texture,alt_km,lightDir);
		light.rgb			*=RAYLEIGH_BETA_FACTOR;
		vec4 insc			=light;

		vec3 extinction		=dens_factor*rayleigh+haze_factor*hazeMie;
		vec3 total_ext		=extinction+ozone*ozone_factor;
		vec3 loss;
		loss				=exp(-extinction*stepLengthKm);
		insc.rgb			*=vec3(1.0,1.0,1.0)-loss;
		mie_factor			*=exp(-insc.w*stepLengthKm*haze_factor*hazeMie);
	
		insc.rgb			*=previous_loss.rgb;
		insc.rgb			+=previous_insc.rgb;

		insc.w				=saturate((1.0-mie_factor.x)/(1.0-previous_loss.x+0.0001f));
		IMAGESTORE(targetTexture,idx,vec4(insc.rgb,insc.a));
		prevDist_km			=dist_km;
		previous_insc		=insc;
	}
}

shader CS_LAYOUT(8,1,1) CS_Skyl(  )
{
	uint3 sub_pos=gl_GlobalInvocationID;
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=LinearThreadToPos2D(linear_pos,targetSize);
	CSSkyl(targetTexture,loss_texture,insc_texture,density_texture,blackbody_texture,pos,maxOutputAltKm,maxDistanceKm,maxDensityAltKm,targetSize);
	
}

program simul_gpu_loss
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Loss();
};

program simul_gpu_insc
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Insc();
};

program simul_gpu_skyl
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Skyl();
};

program copy
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Copy();
};

program gpu_light_table_compute
{
    cs(430)=CS_LightTable();
};

program gpu_loss_compute
{
   cs(430)=CS_Loss();
};

program gpu_insc_compute
{
    cs(430)=CS_Insc();
};

program gpu_skyl_compute
{
    cs(430)=CS_Skyl();
};