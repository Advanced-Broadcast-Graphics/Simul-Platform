#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/sky_constants.sl"
#include "../../CrossPlatform/SL/earth_shadow_uniforms.sl"
#include "../../CrossPlatform/SL/earth_shadow.sl"
#include "../../CrossPlatform/SL/illumination.sl"
#include "../../CrossPlatform/SL/sky.sl"

uniform sampler3D fadeTexture1;
uniform sampler3D fadeTexture2;
uniform sampler2D backgroundTexture;
uniform sampler2D depthTexture;
uniform sampler2D flareTexture;
uniform sampler2D inscTexture;
uniform sampler2D illuminationTexture;
uniform sampler2D lightTable2DTexture;
uniform vec4 rect;

shader VS_FullScreen(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]		=vec2(1.0, 0.0);
	poss[1]		=vec2(1.0, 1.0);
	poss[2]		=vec2(0.0, 0.0);
	poss[3]		=vec2(0.0, 1.0);
	vec2 pos	=poss[gl_VertexID];
	gl_Position	=vec4(vec2(-1.0,-1.0)+2.0*pos.xy,1.0,1.0);
    texCoords	=pos.xy;
}

shader VS_ScreenQuad(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]		=vec2(1.0, 0.0);
	poss[1]		=vec2(1.0, 1.0);
	poss[2]		=vec2(0.0, 0.0);
	poss[3]		=vec2(0.0, 1.0);
	vec2 pos	=poss[gl_VertexID];
	gl_Position	=vec4(rect.xy+rect.zw*pos.xy,1.0,1.0);
    texCoords	=pos.xy;
}

shader VS_Sun(in int gl_VertexID, out vec2 texCoords) 
{
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	vec3 pos=vec3(poss[gl_VertexID],1.0/tan(radiusRadians));
    gl_Position=mul(worldViewProj,vec4(pos,1.0));
	// Set to far plane so can use depth test as want this geometry effectively at infinity
#ifdef REVERSE_DEPTH
	gl_Position.z = 0.0; 
#else
	gl_Position.z = gl_Position.w; 
#endif
    texCoords=pos.xy;
}

shader PS_Fade3DTo2D( in vec2 texCoords, out vec4 FragColor)
{
	vec3 texcoord	=vec3(altitudeTexCoord,texCoords.yx);
	vec4 texel1		=texture_clamp_lod(fadeTexture1,texcoord,0);
	vec4 texel2		=texture_clamp_lod(fadeTexture2,texcoord,0);
	vec4 texel		=mix(texel1,texel2,skyInterp);
    FragColor		=texel;
}

shader PS_Sun( in vec2 texCoords, out vec4 FragColor)
{
	float r=2.0*length(texCoords);
	if(r>2.0)
		return;
	float brightness=1.0;
	if(r>1.0)
	//	discard;
		brightness=colour.a/pow(r,4.0);//+colour.a*saturate((0.9-r)/0.1);
	vec3 result=brightness*colour.rgb;
	FragColor= vec4(result,1.0);
}

shader PS_Flare( in vec2 texCoords, out vec4 FragColor)
{
	vec3 res=colour.rgb*texture_clamp(flareTexture,vec2(.5,.5)+0.5*texCoords).rgb;
	FragColor=vec4(res,1.0);
}

shader PS_Planet(in vec2 texCoords, out vec4 FragColor)
{
	vec4 result=texture_clamp(flareTexture,vec2(.5,.5)-0.5*texCoords);
	// IN.tex is +- 1.
	vec3 normal;
	normal.x=texCoords.x;
	normal.y=texCoords.y;
	float l=length(texCoords);
	if(l>1.0)
		FragColor=vec4(0,0.0,0,1.0);
	else
	{
		//	discard;
		normal.z	=-sqrt(1.0-l*l);
		float light	=approx_oren_nayar(0.2,vec3(0,0,1.0),normal,lightDir.xyz);
		result.rgb	*=colour.rgb;
		result.rgb	*=light;
		result.a	*=saturate((0.97-l)/0.03);
		FragColor=result;
	}
}

struct starsVertexInput
{
    vec3 position			;
    float intex				;
};

shader VS_Stars(in vec3 position,in float intex, out float tex) 
{
    gl_Position=mul(worldViewProj,vec4(position.xyz,1.0));

	// Set to far plane so can use depth test as want this geometry effectively at infinity
#ifdef REVERSE_DEPTH
	gl_Position.z = 0.0; 
#else
	gl_Position.z = 1.0; 
#endif
    tex=intex;
}

shader PS_Stars(in float tex,out vec4 FragColor)
{
	vec3 colour	=vec3(1.0,1.0,1.0)*clamp(starBrightness*tex,0.0,1.0);
	FragColor	=vec4(colour,1.0);
}
shader PS_IlluminationBuffer(in vec2 texCoords,out vec4 FragColor)
{
	float alt_km		=eyePosition.z/1000.0;
	FragColor			= IlluminationBuffer(alt_km,texCoords,targetTextureSize,overcastBaseKm,overcastRangeKm,maxFadeDistanceKm
			,maxFadeDistance,terminatorDistance,radiusOnCylinder,earthShadowNormal,sunDir);
}
shader PS_OvercastInscatter(in vec2 texCoords,out vec4 FragColor)
{
	float alt_km		=eyePosition.z/1000.0;
	// Texcoords representing the full distance from the eye to the given point.
	vec2 fade_texc		=vec2(texCoords.x,1.0-texCoords.y);
    FragColor			=OvercastInscatter(inscTexture,illuminationTexture,fade_texc,alt_km,maxFadeDistanceKm,overcast,overcastBaseKm,overcastRangeKm,targetTextureSize);
}

shader PS_ShowIlluminationBuffer(in vec2 texCoords,out vec4 FragColor)
{
	FragColor=ShowIlluminationBuffer(illuminationTexture,texCoords);
}

shader PS_Show3DLightTable(in vec2 texCoords,out vec4 FragColor)
{
	vec4 result=texture_nearest_lod(fadeTexture1,vec3(texCoords.y,(float(cycled_index)+.5)/3.0,texCoords.x),0);
    FragColor= vec4(result.rgb,1.0);
}

shader PS_Show2DLightTable(in vec2 texCoords,out vec4 FragColor)
{
	vec4 result=texture_nearest_lod(lightTable2DTexture,texCoords.yx,0);
    FragColor= vec4(result.rgb,1);
}

shader PS_BackgroundLatLongSphere(in vec2 texCoords,out vec4 FragColor)
{
	float depth			=texture(depthTexture,texCoords.xy).x;
#if REVERSE_DEPTH==1
	if(depth!=0.0)
		discard;
#else
	if(depth<1.0)
		discard;
#endif
	FragColor= BackgroundLatLongSphere(backgroundTexture,texCoords.xy);
}

program fade_3d_to_2d
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_Fade3DTo2D();
};

program sun
{
    vs(430) = VS_Sun();
    fs(430) = PS_Sun();
};

program flare
{
    vs(430) = VS_Sun();
    fs(430) = PS_Flare();
};

program planet
{
    vs(430) = VS_Sun();
    fs(430) = PS_Planet();
};

program stars
{
    vs(430) = VS_Stars();
    fs(430) = PS_Stars();
};

program illumination_buffer
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_IlluminationBuffer();
};

program overcast_inscatter
{
    vs(430) = VS_FullScreen();
    fs(430) = PS_OvercastInscatter();
};

program show_illumination_buffer
{
    vs(430) = VS_ScreenQuad();
    fs(430) = PS_ShowIlluminationBuffer();
};

program show_cross_section
{
    vs(430) = VS_ScreenQuad();
    fs(430) = PS_Fade3DTo2D();
};

program show_2d_light_table
{
    vs(430) = VS_ScreenQuad();
    fs(430) = PS_Show2DLightTable();
};
program show_light_table
{
    vs(430) = VS_ScreenQuad();
    fs(430) = PS_Show3DLightTable();
};

program background_latlongsphere
{
    vs(430) = VS_ScreenQuad();
    fs(430) = PS_BackgroundLatLongSphere();
};