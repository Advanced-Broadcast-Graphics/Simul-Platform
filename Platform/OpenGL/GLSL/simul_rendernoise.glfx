#include "CppGlSl.hs"
#include "../../CrossPlatform/SL/noise.sl"
#include "../../CrossPlatform/SL/noise_constants.sl"
#include "../../CrossPlatform/SL/depth.sl"

uniform sampler2D image_texture;
uniform sampler2D noise_texture ;
uniform sampler3D random_texture_3d;
layout(rgba32f) uniform image3D targetTexture32;
layout(rgba8_snorm) uniform image3D targetTexture8;
uniform vec4 rect;
uniform vec4 depthToLinFadeDistParams;
uniform vec2 tanHalfFov;

shader VS_FullScreen(in int gl_VertexID, out vec2 texCoords)
{
	vec2 poss[4];
	poss[0]		=vec2( 1.0,-1.0);
	poss[1]		=vec2( 1.0, 1.0);
	poss[2]		=vec2(-1.0,-1.0);
	poss[3]		=vec2(-1.0, 1.0);
	vec2 pos	=poss[gl_VertexID];
	gl_Position	=vec4(pos,0.0,1.0);
    texCoords	=0.5*(vec2(1.0,1.0)+vec2(pos.x,pos.y));
	//texCoords.y	=1.0-texCoords.y;
}

shader RandomPS(in vec2 texCoords,out vec4 FragColour)
{
	// Range from -1 to 1.
    vec4 c=2.0*vec4(rand(texCoords),rand(1.7*texCoords),rand(0.11*texCoords),rand(513.1*texCoords))-1.0;
    FragColour=c;
}

shader PS_Noise2D(in vec2 texCoords,out vec4 FragColour) 
{
    FragColour= Noise(noise_texture,texCoords,persistence,octaves);
}

shader CS_LAYOUT(8,8,8) CS_Random3D()	//gl_GlobalInvocationID gives the combined id in each dimension.
{
	// NOTE: could use shader_image_size(targetTexture32)
	uint3 pos=gl_GlobalInvocationID;
	if(pos.x>=noise_texture_size||pos.y>=noise_texture_size||pos.z>=noise_texture_size)
		return;
	vec3 texCoords	=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(noise_texture_size,noise_texture_size,noise_texture_size);
	vec2 texc2		=texCoords.xy+noise_texture_size*texCoords.z;
	// Range from -1 to 1.
    vec4 c=2.0*vec4(rand(texc2),rand(1.7*texc2),rand(0.11*texc2),rand(513.1*texc2))-vec4(1.0,1.0,1.0,1.0);
	imageStore(targetTexture32,ivec3(pos),c);
}

shader CS_LAYOUT(8,8,8) CS_Noise3D()	//gl_GlobalInvocationID gives the combined id in each dimension.
{
	uint3 pos=gl_GlobalInvocationID;
	//uint3 dims;
	/*targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;*/
	vec4 result		=vec4(0,0,0,0);
/*	vec3 texCoords	=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	float mult		=0.5;
	float total		=0.0;
    for(int i=0;i<octaves;i++)
    {
		vec4 c		=texture_wrap_lod(random_texture_3d,texCoords,0);
		texCoords	*=2.0;
		total		+=mult;
		result		+=mult*c;
		mult		*=persistence;
    }
	// divide by total to get the range -1,1.
	result*=1.0/total;*/
	imageStore(targetTexture32,ivec3(pos), result);
}

program simul_random
{
    vs(430) = VS_FullScreen();
    fs(430) = RandomPS();
};

program simul_noise_2d
{
	vs(430) =VS_FullScreen();
	fs(430) =PS_Noise2D();
};

program random_3d_compute
{
    cs(430) =CS_Random3D();
};

program noise_3d_compute
{
    cs(430) =CS_Noise3D();
};
