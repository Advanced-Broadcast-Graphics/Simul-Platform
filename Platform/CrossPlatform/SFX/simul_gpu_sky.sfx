#include "shader_platform.sl"
uniform sampler2D input_texture;
uniform sampler2D density_texture;
uniform sampler3D loss_texture;
uniform sampler3D insc_texture;
// The generated colour texture
uniform sampler3D colourTexture;
uniform sampler3D colourTexture2;
uniform sampler2D optical_depth_texture;
uniform sampler2D blackbody_texture;
uniform RWTexture3D<vec4> targetTexture;

SamplerState samplerState 
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Clamp;
	AddressV = Mirror;
	AddressW = Clamp;
};
#include "../../CrossPlatform/SL/states.sl"
#include "../../CrossPlatform/SL/simul_inscatter_fns.sl"
#include "../../CrossPlatform/SL/gpu_sky_constants.sl"
#include "../../CrossPlatform/SL/simul_gpu_sky.sl"

struct vertexInput
{
    vec3 position		: POSITION;
    vec2 texCoords	: TEXCOORD0;
};

struct vertexOutput
{
    vec4 hPosition	: SV_POSITION;
	vec2 texCoords	: TEXCOORD0;		
};

shader vertexOutput VS_Main(idOnly IN)
{
    vertexOutput OUT;
	vec2 poss[4]=
	{
		{ 1.0, 0.0},
		{ 1.0, 1.0},
		{ 0.0, 0.0},
		{ 0.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	pos.y			=yRange.x+pos.y*yRange.y;
	vec4 vert_pos	=vec4(vec2(-1.0,1.0)+2.0*vec2(pos.x,-pos.y),1.0,1.0);
    OUT.hPosition	=vert_pos;
    OUT.texCoords	=pos;
    return OUT;
}

shader vec4 PS_Loss(vertexOutput IN) : SV_TARGET
{
	vec4 loss=PSLoss(input_texture,density_texture,IN.texCoords.xy);
	return loss;
}

CS_LAYOUT(4,4,4)
shader void CS_BlendColour3D(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 dims;
	uint3 sub_pos = g * 4 + t;
	if(sub_pos.x>=targetSize.x||sub_pos.y>=targetSize.y||sub_pos.z>=targetSize.z)
		return;
//	sub_pos.z=4;
	vec4 c1=IMAGE_LOAD_3D(colourTexture,sub_pos);
	vec4 c2=IMAGE_LOAD_3D(colourTexture2,sub_pos);
	vec4 c=lerp(c1,c2,interpColours);
	IMAGE_STORE_3D(targetTexture,sub_pos,c);
}

CS_LAYOUT(8,1,1)
shader void CS_Loss(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 dims;
	uint3 sub_pos = g * uint3(8, 1, 1) + t;
	GET_IMAGE_DIMENSIONS_3D(targetTexture,dims.x,dims.y,dims.z);
	uint linear_pos		=sub_pos.x+threadOffset.x;
	uint3 pos			=uint3(LinearThreadToPos2D(int(linear_pos),int3(dims)));
	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
		return;
	vec2 texc			=(pos.xy+vec2(0.5,0.5))/vec2(targetSize.xy);
	vec4 previous_loss	=vec4(1.0,1.0,1.0,1.0);//texture_clamp(input_loss_texture,texc.xy);
	float sin_e			=max(-1.0,min(1.0,1.0-2.0*(texc.y*texSize.y-texelOffset)/(texSize.y-1.0)));
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(texc.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);
	float prevDist_km	=0.0;
	for(uint i=0;i<targetSize.z;i++)
	{
		uint3 idx			=uint3(pos.xy,i);
		float zPosition		=pow(float(i)/(float(targetSize.z)-1.0),2.0);
		float dist_km		=zPosition*maxDistanceKm;
		if(i==targetSize.z-1)
			dist_km=12000.0;
		float maxd			=min(spaceDistKm,dist_km);
		float mind			=min(spaceDistKm,prevDist_km);
		float dist			=0.5*(mind+maxd);
		float stepLengthKm	=max(0.0,maxd-mind);
		float y				=planetRadiusKm+viewAltKm+dist*sin_e;
		float x				=dist*cos_e;
		float r				=sqrt(x*x+y*y);
		float alt_km		=r-planetRadiusKm;
		// lookups is: dens_factor,ozone_factor,haze_factor;
		float dens_texc		=(alt_km/maxDensityAltKm*(tableSize.x-1.0)+texelOffset)/tableSize.x;
		vec4 lookups		=texture_clamp_lod(density_texture,vec2(dens_texc,.5),0);
		float dens_factor	=lookups.x;
		float ozone_factor	=lookups.y;
		float haze_factor	=getHazeFactorAtAltitude(alt_km);
		vec3 extinction		=dens_factor*rayleigh+haze_factor*hazeMie+ozone*ozone_factor;
		vec4 loss;
		loss.rgb			=exp(-extinction*stepLengthKm);
		loss.a				=(loss.r+loss.g+loss.b)/3.0;
		loss				*=previous_loss;
		IMAGE_STORE_3D(targetTexture,idx,vec4(loss.rgb,1.0));
		prevDist_km			=dist_km;
		previous_loss		=loss;
	}
}
// Light Table 3D Tex is "altitudes x 3 x 4".
// The 4 z-values represent ambient, sunlight, moonlight and combined.
//The 3 y-values represent the three tables for interpolation.

CS_LAYOUT(1,1,1)
shader void CS_LightTable( uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID )
{
	uint3 sub_pos = g  + t;
	// threadOffset.y determines the cycled index.
	uint3 pos			=sub_pos+threadOffset;
//	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
//		return;
	float alt_texc			=float(pos.x)/float(targetSize.x);
	float alt_km			=maxOutputAltKm*alt_texc;
	vec4 sunlight			=vec4(sunIrradiance,1.0)*getSunlightFactor2(optical_depth_texture,alt_km,lightDir);
	float moon_angular_radius=pi/180.0/2.0;
	float moon_angular_area_ratio=pi*moon_angular_radius*moon_angular_radius/(4.0*pi);
	vec4 moonlight			=vec4(sunIrradiance,1.0)*getSunlightFactor2(optical_depth_texture,alt_km,directionToMoon)*0.136*moon_angular_area_ratio;
	// equivalent to GetAnisotropicInscatterFactor(true,altitude_km,pi/2.f,0,1e5f,sun_irradiance,starlight,dir_to_sun,dir_to_moon,haze,overcast,false,0):
	vec4 ambientLight		=vec4(getSkylight(alt_km, insc_texture),1.0);
	uint3 pos_sun			=uint3(pos.xy,0);

	IMAGE_STORE_3D(targetTexture,pos_sun, sunlight);
	uint3 pos_moon			=uint3(pos.xy,1);
	IMAGE_STORE_3D(targetTexture,pos_moon, moonlight);
	uint3 pos_amb			=uint3(pos.xy,2);
	IMAGE_STORE_3D(targetTexture,pos_amb, ambientLight);

	// Combined sun and moonlight:
	uint3 pos_both		=uint3(pos.xy,3);
	IMAGE_STORE_3D(targetTexture,pos_both, sunlight+moonlight);
}

CS_LAYOUT(8,1,1)
shader void CS_Insc( uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID )
{
	int3 sub_pos = int3(g) * int3(8, 1, 1) + int3(t);
	int3 dims;

	int linear_pos			=int(sub_pos.x)+int(threadOffset.x);
	
	int3 pos				=LinearThreadToPos2D(linear_pos,targetSize);
	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
		return;
	vec2 texc				=(pos.xy+vec2(0.5,0.5))/vec2(targetSize.xy);

	vec4 previous_insc		=vec4(0.0,0.0,0.0,0.0);
	float sin_e				=max(-1.0,min(1.0,1.0-2.0*(texc.y*texSize.y-texelOffset)/(texSize.y-1.0)));
	float cos_e				=sqrt(1.0-sin_e*sin_e);
	float altTexc			=(texc.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm			=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm		=getDistanceToSpace(sin_e,viewAltKm);
	
	float prevDist_km		=0.0;
	
	IMAGE_STORE_3D(targetTexture,pos,previous_insc);
	vec3 mie_factor			=vec3(1.0,1.0,1.0);
	for(uint i=1;i<targetSize.z;i++)
	{
		uint3 idx			=uint3(pos.xy,i);
		float zPosition		=pow(float(i)/(float(targetSize.z)-1.0),2.0);
		
		vec3 previous_loss	=IMAGE_LOAD_3D(loss_texture,idx).rgb;

		float dist_km		=zPosition*maxDistanceKm;
		if(i==targetSize.z-1)
			dist_km=1000.0;
		float maxd			=min(spaceDistKm,dist_km);
		float mind			=min(spaceDistKm,prevDist_km);
		float dist			=0.5*(mind+maxd);
		float stepLengthKm	=max(0.0,maxd-mind);
		float y				=planetRadiusKm+viewAltKm+dist*sin_e;
		float x				=dist*cos_e;
		float r				=sqrt(x*x+y*y);
		float alt_km		=r-planetRadiusKm;
	
		float x1			=mind*cos_e;
		float r1			=sqrt(x1*x1+y*y);
		float alt_1_km		=r1-planetRadiusKm;
	
		float x2			=maxd*cos_e;
		float r2			=sqrt(x2*x2+y*y);
		float alt_2_km		=r2-planetRadiusKm;
	
		// lookups is: dens_factor,ozone_factor,haze_factor;
		float dens_texc		=(alt_km/maxDensityAltKm*(tableSize.x-1.0)+texelOffset)/tableSize.x;
		vec4 lookups		=texture_clamp_lod(density_texture,vec2(dens_texc,0.5),0);
		float dens_factor	=lookups.x;
		float ozone_factor	=lookups.y;
		float haze_factor	=getHazeFactorAtAltitude(alt_km);
		vec4 light			=vec4(sunIrradiance,1.0)*getSunlightFactor(optical_depth_texture,alt_km,lightDir);
		light.rgb			*=RAYLEIGH_BETA_FACTOR;
		vec4 insc			=light;

		vec3 extinction		=dens_factor*rayleigh+haze_factor*hazeMie;
		vec3 total_ext		=extinction+ozone*ozone_factor;
		vec3 loss;
		loss				=exp(-extinction*stepLengthKm);
		insc.rgb			*=vec3(1.0,1.0,1.0)-loss;
		mie_factor			*=exp(-insc.w*stepLengthKm*haze_factor*hazeMie);
	
		insc.rgb			*=previous_loss.rgb;
		insc.rgb			+=previous_insc.rgb;

		insc.w				=saturate((1.0-mie_factor.x)/(1.0-previous_loss.x+0.0001f));
		vec3 texc			=(vec3(idx)+vec3(0.5,0.5,0.5))/vec3(targetSize.xyz);
		vec4 insc_colour	=texture_clamp_lod(colourTexture,texc.zyx,0);
		vec4 store_insc		=lerp(insc,insc_colour,blendToColours);

		IMAGE_STORE_3D(targetTexture,idx,store_insc);
		prevDist_km			=dist_km;
		previous_insc		=insc;
	}
	
}

CS_LAYOUT(8,1,1)
shader void CS_Skyl( uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID )
{
	int3 sub_pos = int3(g) *int3(8,1,1) + int3(t);
	int3 dims;
	GET_IMAGE_DIMENSIONS_3D(targetTexture,dims.x,dims.y,dims.z);
	int linear_pos		=sub_pos.x+int(threadOffset.x);
	int3 pos			=LinearThreadToPos2D(linear_pos,dims);
	if(pos.x>=targetSize.x||pos.y>=targetSize.y)
		return;
	vec2 texc			=(pos.xy+vec2(0.5,0.5))/vec2(targetSize.xy);
	
	vec4 previous_skyl	=vec4(0.0,0.0,0.0,1.0);
	float sin_e			=max(-1.0,min(1.0,1.0-2.0*(texc.y*texSize.y-texelOffset)/(texSize.y-1.0)));
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(texc.x*texSize.x-texelOffset)/max(texSize.x-1.0,1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);

	float prevDist_km	=0.0;
	// The midpoint of the step represented by this layer
	for(int i=0;i<int(targetSize.z);i++)
	{
		uint3 idx			=uint3(pos.xy,i);
		float zPosition		=pow(float(i)/(float(targetSize.z)-1.0),2.0);
		
		vec3 previous_loss	=IMAGE_LOAD_3D(loss_texture,idx).rgb;
		float dist_km		=zPosition*maxDistanceKm;
		if(i==targetSize.z-1)
			dist_km=1000.0;
		vec4 skyl	=Skyl(insc_texture
									,density_texture
									,blackbody_texture
									,previous_loss
									,previous_skyl
									,maxOutputAltKm
									,maxDistanceKm
									,maxDensityAltKm
									,spaceDistKm
									,viewAltKm
									,dist_km
									,prevDist_km
									,sin_e
									,cos_e);

		IMAGE_STORE_3D(targetTexture,idx, skyl);
		prevDist_km			=dist_km;
		previous_skyl		=skyl;
	}
	
}

shader vec4 PS_Insc(vertexOutput IN) : SV_TARGET
{
	vec4 ret=Insc(input_texture,loss_texture,density_texture,optical_depth_texture,IN.texCoords);
	return ret;
}

shader vec4 PS_Skyl(vertexOutput IN) : SV_TARGET
{
	vec4 previous_skyl	=texture(input_texture,IN.texCoords.xy);
	vec3 previous_loss	=texture(loss_texture,vec3(IN.texCoords.xy,pow(distanceKm/maxDistanceKm,0.5))).rgb;
	// should adjust texCoords - we want the PREVIOUS loss!
	float sin_e			=clamp(1.0-2.0*(IN.texCoords.y*texSize.y-texelOffset)/(texSize.y-1.0),-1.0,1.0);
	float cos_e			=sqrt(1.0-sin_e*sin_e);
	float altTexc		=(IN.texCoords.x*texSize.x-texelOffset)/(texSize.x-1.0);
	float viewAltKm		=altTexc*altTexc*maxOutputAltKm;
	float spaceDistKm	=getDistanceToSpace(sin_e,viewAltKm);
	float maxd			=min(spaceDistKm,distanceKm);
	float mind			=min(spaceDistKm,prevDistanceKm);
	float dist			=0.5*(mind+maxd);
	float stepLengthKm	=max(0.0,maxd-mind);
	float y				=planetRadiusKm+viewAltKm+dist*sin_e;
	float x				=dist*cos_e;
	float r				=sqrt(x*x+y*y);
	float alt_km		=r-planetRadiusKm;
	// lookups is: dens_factor,ozone_factor,haze_factor;
	float dens_texc		=(alt_km/maxDensityAltKm*(tableSize.x-1.0)+texelOffset)/tableSize.x;
	vec4 lookups		=texture(density_texture,vec2(dens_texc,dens_texc));
	float dens_factor	=lookups.x;
	float ozone_factor	=lookups.y;
	float haze_factor	=getHazeFactorAtAltitude(alt_km);
	vec4 light			=vec4(starlight+getSkylight(alt_km,insc_texture),0.0);
	vec4 skyl			=light;
	vec3 extinction		=dens_factor*rayleigh+haze_factor*hazeMie;
	vec3 total_ext		=extinction+ozone*ozone_factor;
	vec3 loss			=exp(-extinction*stepLengthKm);
	skyl.rgb			*=vec3(1.0,1.0,1.0)-loss;
	float mie_factor	=exp(-skyl.w*stepLengthKm*haze_factor*hazeMie.x);
	skyl.w				=saturate((1.0-mie_factor)/(1.0-total_ext.x+0.0001f));
	
	//skyl.w				=(loss.w)*(1.0-previous_skyl.w)*skyl.w+previous_skyl.w;
	skyl.rgb			*=previous_loss.rgb;
	skyl.rgb			+=previous_skyl.rgb;
	float lossw=1.0;
	skyl.w				=(lossw)*(1.0-previous_skyl.w)*skyl.w+previous_skyl.w;
    return skyl;
}


//------------------------------------
// Technique
//------------------------------------
DepthStencilState DisableDepth
{
	DepthEnable = FALSE;
	DepthWriteMask = ZERO;
};
BlendState DontBlend
{
	BlendEnable[0] = FALSE;
};
RasterizerState RenderNoCull { CullMode = none; };

technique simul_gpu_loss
{
    pass p0 
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_Main()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Loss()));
    }
}

technique simul_gpu_insc
{
    pass p0 
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_Main()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Insc()));
    }
}

technique simul_gpu_skyl
{
    pass p0 
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_Main()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Skyl()));
    }
}
technique gpu_light_table_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_LightTable()));
    }
}

technique gpu_loss_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Loss()));
    }
}

technique gpu_insc_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Insc()));
    }
}

technique gpu_skyl_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Skyl()));
    }
}

technique blend_colour_3d
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_BlendColour3D()));
    }
}