//  Copyright (c) 2015-2018 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/states.sl"
#include "../SL/debug_constants.sl"
#include "../SL/quaternion.sl"

Texture3D cloudVolume;
Texture3D cloudLighting;

shader posTexVertexOutput VS_DrawTextureOnSphere(idOnly IN) 
{
    posTexVertexOutput OUT;
	vec3 poss[4];
	poss[0]			=vec3( 1.0,-1.0,1.0);
	poss[1]			=vec3( 1.0, 1.0,1.0);
	poss[2]			=vec3(-1.0, 1.0,1.0);
	poss[3]			=vec3(-1.0,-1.0,1.0);
	vec3 pos;
	uint vert=IN.vertex_id%4;
	{
		pos				=poss[vert];
		OUT.texCoords	=pos.xy*0.5+vec2(0.5,0.5);
		pos.xy			*=sideview;
		pos.z			=1.0;
		pos				=normalize(pos);
	}
	pos					=radius*rotate_by_quaternion(quaternion,pos);
	// The default orientation is on the equator, whereby X=East, Y=North and Z=Up.
	// The quaternion rotates from that position.
	OUT.hPosition		=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
	return OUT;
}

shader vec4 PS_DrawTextureOnSphere(posTexVertexOutput IN) : SV_TARGET
{
	vec3 texc	=vec3(IN.texCoords.xy+texcOffset,0.5);
	// In DX, texcoords start from top left. In GL, sensibly, it's bottom-left.
	//texc.y		=1.0-texc.y;
	vec4 lookup=texture_wwc_lod(cloudVolume,texc.xyz,0);
	vec4 res=vec4(1.0,1.0,1.0,lookup.z);
	//res.rgb=IN.texCoords.xyy;
	return res;
}

technique draw_texture_on_sphere
{
    pass p0 
    {		
		SetRasterizerState( RenderNoCull );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_DrawTextureOnSphere()));
		SetPixelShader(CompileShader(ps_5_0,PS_DrawTextureOnSphere()));
		//SetVertexShader(CompileShader(vs_5_0,VS_DrawQuadOnSphere()));
		//SetPixelShader(debugps_5_0);
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
    }
}