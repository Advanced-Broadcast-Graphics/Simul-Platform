//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#define USE_LIGHT_TABLES 1
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
uniform sampler2D imageTexture;
uniform sampler2D noiseTexture;
uniform sampler2D coverageTexture;
uniform sampler2D lossTexture;
uniform Texture3D volumeInscatterTexture;
uniform sampler2D depthTexture;
uniform Texture2DMS<vec4> depthTextureMS;
uniform sampler2D illuminationTexture;
uniform sampler2D lightTableTexture;

uniform RWTexture2D<vec4> outputTexture		SIMUL_RWTEXTURE_REGISTER(0);

SamplerState samplerState 
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

#include "../SL/simul_2d_clouds.hs"

#include "../SL/simul_inscatter_fns.sl"
#include "../SL/earth_shadow_uniforms.sl"
#include "../SL/earth_shadow.sl"
#include "../SL/earth_shadow_fade.sl"

#include "../SL/simul_2d_clouds.sl"
#include "../SL/simul_2d_cloud_detail.sl"
#include "../SL/depth.sl"

SIMUL_CONSTANT_BUFFER(CloudCrossSection2DConstants,13)
uniform vec4 rect;
SIMUL_CONSTANT_BUFFER_END

struct a2v
{
    vec3 position	: POSITION;
	uint vertex_id			: SV_VertexID;
};

struct v2f
{
    vec4 hPosition		: SV_POSITION;
    vec4 clip_pos		: TEXCOORD0;
	vec3 wPosition		: TEXCOORD1;
};

v2f VSMain(a2v IN,bool reverseDepth)
{
	v2f OUT;
	OUT.hPosition	=vec4(IN.position,IN.position.z);
	OUT.clip_pos	=OUT.hPosition/OUT.hPosition.w;
	OUT.wPosition=vec3(0,0,0);
	vec2 poss[4];
	poss[0]=vec2( 1.0,-1.0);
	poss[1]=vec2( 1.0, 1.0);
	poss[2]=vec2(-1.0,-1.0);
	poss[3]=vec2(-1.0, 1.0);
	vec2 p2			=poss[IN.vertex_id%uint(4)];
	OUT.hPosition	=vec4(.5*p2,0.0,1.0);
	OUT.hPosition.z	=0.0; 

	vec3 pos			=maxCloudDistanceMetres*IN.position.xyz;
	pos.z				+=origin.z;
	float Rh			=planetRadius+origin.z;
	float dist			=length(pos.xy);
	float vertical_shift=sqrt(Rh*Rh-dist*dist)-Rh;
	pos.z				+=vertical_shift;
	pos.xy				+=eyePosition.xy;
	OUT.clip_pos		=mul(worldViewProj,vec4(pos.xyz,1.0));
	// Prevent clipping:
	if(reverseDepth)
	{
		if(OUT.clip_pos.z<0)
			OUT.clip_pos.z=0;
	}
	else
	{
		if(OUT.clip_pos.z>OUT.clip_pos.w)
			OUT.clip_pos.z=OUT.clip_pos.w;
	}
	OUT.hPosition		=OUT.clip_pos;
    OUT.wPosition		=pos.xyz;
    return OUT;
}

shader v2f VS_Main(a2v IN)
{
	return VSMain(IN,false);
}

shader v2f VS_DepthForward(a2v IN)
{
	return VSMain(IN,false);
}

shader v2f VS_DepthReverse(a2v IN)
{
	return VSMain(IN,true);
}

vec4 msaaPS(v2f IN)
{
	vec2 wOffset		=IN.wPosition.xy-origin.xy;
    vec2 texc_global	=wOffset/globalScale;
    vec2 texc_detail	=wOffset/detailScale;
	vec3 wEyeToPos		=IN.wPosition-eyePosition;
	float alt_texc		=IN.wPosition.z/maxAltitudeMetres;
	vec3 sun_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,0.5/3.0),0).rgb;
	vec3 moon_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,1.5/3.0),0).rgb;
	vec3 ambient_light	=texture_clamp_lod(lightTableTexture,vec2(alt_texc,2.5/3.0),0).rgb*lightResponse.w;
	vec2 viewportTexCoords	=0.5*(vec2(1.0,1.0)+(IN.clip_pos.xy));
	vec4 ret			=Clouds2DPS_illum(imageTexture,coverageTexture
										,lossTexture
										,volumeInscatterTexture,viewportTexCoords
										,noiseTexture
										,texc_global,texc_detail
										,wEyeToPos
										,sun_irr
										,moon_irr
										,ambient_light.rgb
										,lightDir.xyz
										,lightResponse
													,maxFadeDistanceMetres);

	ret.rgb				*=exposure;
	return ret;
}

vec4 MainPS(v2f IN,vec2 texCoords)
{
	vec2 wOffset		=IN.wPosition.xy-origin.xy;
    vec2 texc_global	=wOffset/globalScale;
    vec2 texc_detail	=wOffset/detailScale;
	vec3 wEyeToPos		=IN.wPosition-eyePosition;
	float alt_texc		=IN.wPosition.z/maxAltitudeMetres;
	vec3 sun_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,0.5/3.0),0).rgb;
	vec3 moon_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,1.5/3.0),0).rgb;
	vec3 ambient_light	=texture_clamp_lod(lightTableTexture,vec2(alt_texc,2.5/3.0),0).rgb*lightResponse.w;
	vec4 ret			=Clouds2DPS_illum(imageTexture
										,coverageTexture
										,lossTexture
										,volumeInscatterTexture,texCoords
										,noiseTexture
										,texc_global,texc_detail
										,wEyeToPos
										,sun_irr
										,moon_irr
										,ambient_light.rgb
										,lightDir.xyz
										,lightResponse
													,maxFadeDistanceMetres);
	ret.rgb				*=exposure;
	return ret;
}

struct FarNearPixelOutput
{
	vec4 farColour SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 nearColour SIMUL_RENDERTARGET_OUTPUT(1);
};

shader vec4 PS_Main(v2f IN) SIMUL_RENDERTARGET_OUTPUT(0)
{
	vec2 viewportTexCoords	=0.5*(vec2(1.0,1.0)+(IN.clip_pos.xy/IN.clip_pos.w));
	viewportTexCoords.y		=1.0-viewportTexCoords.y;
	return MainPS(IN,viewportTexCoords);
}

vec4 PS_Main_depthTexture(v2f IN,bool reverseDepth)
{
	vec2 viewportTexCoords	=0.5*(vec2(1.0,1.0)+(IN.clip_pos.xy/IN.clip_pos.w));
	viewportTexCoords.y		=1.0-viewportTexCoords.y;
	//uint2 depthDims;
	//uint depthSamples;
	vec2 depthTexCoords	=viewportCoordToTexRegionCoord(viewportTexCoords.xy,viewportToTexRegionScaleBias);
	float dlookup 		=texture_clamp_lod(depthTexture,depthTexCoords,0).x;
	if(reverseDepth)
	{
		if(dlookup!=0)
			discard;
	}
	else
	{	
		if(dlookup<0.999999)
			discard;
	}

	return MainPS(IN,viewportTexCoords);
}

shader vec4 PS_Main_depthReverse(v2f IN) : SV_TARGET
{
	return PS_Main_depthTexture(IN,true);
}

shader vec4 PS_Main_depthForward(v2f IN) : SV_TARGET
{
	return PS_Main_depthTexture(IN,false);
}

struct v2f2
{
    vec4 hPosition	: SV_POSITION;
	vec2 texCoords	: TEXCOORD0;
};

shader v2f2 FullScreenVS(idOnly IN)
{
	v2f2 OUT;
	vec2 poss[4]=
	{
		{ 1.0, 0.0},
		{ 1.0, 1.0},
		{ 0.0, 0.0},
		{ 0.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(2.0*pos-vec2(1.0,1.0),0.0,1.0);
    OUT.texCoords	=pos;
    return OUT;
}

shader v2f2 SimpleVS(idOnly IN)
{
	v2f2 OUT;
	vec2 poss[4]=
	{
		{ 1.0, 0.0},
		{ 1.0, 1.0},
		{ 0.0, 0.0},
		{ 0.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(rect.xy+rect.zw*pos,0.0,1.0);
    OUT.texCoords	=pos;
    return OUT;
}

shader vec4 SimplePS(v2f2 IN) : SV_TARGET
{
	return texture_clamp(imageTexture,.5+IN.texCoords);
}

shader vec4 CoveragePS(v2f2 IN) : SV_TARGET
{
	return Coverage(IN.texCoords,humidity,diffusivity,coverageOctaves,coveragePersistence,time,noiseTexture);
}

shader vec4 ShowDetailTexturePS(v2f2 IN) : SV_TARGET
{
	float alt_texc		=10000.0/maxAltitudeMetres;
	vec3 sun_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,0.5/3.0),0).rgb;
	return ShowDetailTexture(imageTexture,IN.texCoords,sun_irr,lightResponse);
}

float rand(vec2 co)
{
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

shader vec4 RandomPS(v2f2 IN) : SV_TARGET
{
    vec4 c	=vec4(rand(IN.texCoords),rand(1.7*IN.texCoords),rand(0.11*IN.texCoords),rand(513.1*IN.texCoords));
    return frac(c);
}

shader vec4 DetailPS(v2f2 IN) : SV_TARGET
{
    return DetailDensity(IN.texCoords,imageTexture,amplitude);
}

shader vec4 DetailLightingPS(v2f2 IN) : SV_TARGET
{
    return DetailLighting(IN.texCoords,imageTexture);
}

void CS_Clouds2D(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID,bool useDepth,bool reverseDepth)
{
	int2 pos				=int2(g.xy*8+t.xy);
	pos						=pos*amortization+amortizationOffset.xy;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;
	// offset by one texel to allow -1 in x and y:
	vec2 INtexCoords		=vec2(pos.xy+uint2(1,1))/vec2(targetTextureSize1);
	vec4 dlookup 			=vec4(0,0,0,0);
	if(useDepth)
		dlookup				=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(INtexCoords.xy,viewportToTexRegionScaleBias),0);
	// We transform from the target texCoords (0-1,0-1) passed from the vertex shader,
	//  to the texCoords of our "window". These wrap around 
	vec2 texCoords			=mixedResTransformXYWH.xy+INtexCoords.xy*mixedResTransformXYWH.zw;
	texCoords				-=vec2(1.0,1.0)/vec2(targetTextureSize1)*mixedResTransformXYWH.zw;
	
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	vec3 view				=normalize(mul(invViewProj,clip_pos).xyz);
	// TODO: should be depthToFadeDistance,not linear
	vec4 dist				=vec4(1.0,1.0,1.0,1.0);
	if(useDepth)
		dist				=depthToLinearDistance(dlookup, depthInterpretationStruct);
	float dz				=cloudAltitudeMetres-eyePosition.z;
	vec4 ret				=vec4(0,0,0,1.0);
	pos						+=offsetToCorner;
	pos						=pos%targetTextureSize1;

	if(dz>0||view.z<0)
	{
		float Rh				=6378.0+cloudAltitudeMetres*0.001;
		float Rz				=6378+eyePosition.z*0.001;
		float b					=2.0*Rz*view.z;
		float c					=Rz*Rz-Rh*Rh;
		float U					=b*b-4*c;
		if(U>=0)
		{
			float d				=1000.0*(-b + sqrt(U));
			if(d<0)
				d				=max(d,1000.0*(-b - sqrt(U)));
		//	float d				=abs(dz)/view.z;
	
			if(d>0)//&&dist.x>=1.0||dz<0)
			{
				vec3 wEyeToPos			=view*d;
				vec3 wPosition			=eyePosition+wEyeToPos;
				vec2 unmodifiedTexCoords	=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize1);

				vec2 wOffset		=wPosition.xy-origin.xy;
				vec2 texc_global	=wOffset/globalScale;
				vec2 texc_detail	=wOffset/detailScale;
				float alt_texc		=wPosition.z/maxAltitudeMetres;
				vec3 sun_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,0.5/3.0),0).rgb;
				vec3 moon_irr		=texture_clamp_lod(lightTableTexture,vec2(alt_texc,1.5/3.0),0).rgb;
				vec3 ambient_light	=texture_clamp_lod(lightTableTexture,vec2(alt_texc,2.5/3.0),0).rgb*lightResponse.w;
				ret			=Clouds2DPS_illum(imageTexture
													,coverageTexture
													,lossTexture
													,volumeInscatterTexture,unmodifiedTexCoords
													,noiseTexture
													,texc_global,texc_detail
													,wEyeToPos
													,sun_irr
													,moon_irr
													,ambient_light.rgb
													,lightDir.xyz
													,lightResponse
													,maxFadeDistanceMetres);
				ret.rgb				*=exposure*ret.a;
				ret.a=1.0-ret.a;
			}
		}
	}
	outputTexture[pos]	=ret;
}

CS_LAYOUT(8,8,1)
shader void CS_Clouds2D_depthReverse(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Clouds2D(g,t,true,true);
}


CS_LAYOUT(8,8,1)
shader void CS_Clouds2D_depthForward(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Clouds2D(g,t,true,false);
}

CS_LAYOUT(8,8,1)
shader void CS_Clouds2D_noDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Clouds2D(g,t,false,false);
}


technique coverage
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,FullScreenVS()));
		SetPixelShader(CompileShader(ps_4_0,CoveragePS()));
    }
}

technique simple
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,SimpleVS()));
		SetPixelShader(CompileShader(ps_4_0,SimplePS()));
    }
}

technique show_detail_texture
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,SimpleVS()));
		SetPixelShader(CompileShader(ps_4_0,ShowDetailTexturePS()));
    }
}

technique random
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,FullScreenVS()));
		SetPixelShader(CompileShader(ps_4_0,RandomPS()));
    }
}

technique detail_density
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,FullScreenVS()));
		SetPixelShader(CompileShader(ps_4_0,DetailPS()));
    }
}

technique detail_lighting
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,FullScreenVS()));
		SetPixelShader(CompileShader(ps_4_0,DetailLightingPS()));
    }
}

BlendState AlphaBlendX
{
	BlendEnable[0] = TRUE;
	BlendEnable[1] = FALSE;
	SrcBlend = SRC_ALPHA;
	DestBlend = INV_SRC_ALPHA;
    BlendOp = ADD;
    SrcBlendAlpha = ZERO;
    DestBlendAlpha = INV_SRC_ALPHA;
    BlendOpAlpha = ADD;
    RenderTargetWriteMask[0]	=15;
    RenderTargetWriteMask[1]	=15;
};

VertexShader main_vs	=CompileShader(vs_5_0,VS_Main());
VertexShader forward_vs	=CompileShader(vs_5_0,VS_DepthForward());
VertexShader reverse_vs	=CompileShader(vs_5_0,VS_DepthReverse());

technique simul_clouds_2d
{
    pass no_depth
    {
        SetGeometryShader(NULL);
		SetVertexShader(main_vs);
		SetPixelShader(CompileShader(ps_5_0,PS_Main()));
    }
    pass reverse_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendX,float4(0.0,0.0,0.0,0.0),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(reverse_vs);
		SetPixelShader(CompileShader(ps_5_0,PS_Main_depthReverse()));
    }
    pass forward_depth
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlendX,float4(0.0,0.0,0.0,0.0),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(forward_vs);
		SetPixelShader(CompileShader(ps_5_0,PS_Main_depthForward()));
    }
    pass depth_check
    {
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(TestDepth,0);
		SetBlendState(AlphaBlendX,float4(0.0,0.0,0.0,0.0),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(main_vs);
		SetPixelShader(CompileShader(ps_5_0,PS_Main()));
    }
}

VertexShader vs_fullscreen_5_0 = CompileShader(vs_5_0, VS_SimpleFullscreen());
technique clouds_2d_quad
{
	pass reverse_depth 
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clouds2D_depthReverse()));
	}
	pass forward_depth
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clouds2D_depthForward()));
	}
	pass no_depth
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Clouds2D_noDepth()));
	}
}