//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.

// Recommended by D Cook of MS to fix Xbox compiler crash:
#define __XBOX_DISABLE_ITERATION

#include "shader_platform.sl"



#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/simul_cloud_constants.sl"
#include "../SL/depth.sl"

uniform Texture3D smallWorleyTexture3D				SIMUL_TEXTURE_REGISTER(12);

#include "../SL/simul_clouds.sl"
#include "../SL/clouds_simple.sl"
#include "../SL/clouds_raytrace.sl"
#include "../SL/states.sl"
#include "../SL/earth_shadow_fade.sl"
#include "../SL/debug_constants.sl"
#include "../SL/gpu_cloud_constants.sl"
#include "../SL/simul_gpu_clouds.sl"
#include "../SL/noise.sl"

uniform Texture3D cloudDensity;
uniform Texture3D cloudDensity2			SIMUL_TEXTURE_REGISTER(1);
 
uniform Texture2D lossTexture;
uniform Texture2D inscTexture;
uniform Texture2D skylTexture;
uniform TextureCube depthTexture;
uniform Texture3D noiseTexture3D		SIMUL_TEXTURE_REGISTER(2);
uniform TextureCube clouds2DTexture		SIMUL_TEXTURE_REGISTER(3);
uniform Texture2D illuminationTexture;
uniform Texture2D lightTableTexture;
uniform Texture2D rainbowLookupTexture;
uniform Texture2D coronaLookupTexture;
uniform Texture3D volumeInscatterTexture;
uniform Texture2D rainMapTexture;
/// The previous texture area:
uniform Texture2DArray updateTexture;
uniform RWTexture3D<uchar4> outputTexture3d		SIMUL_RWTEXTURE_REGISTER(1);

uniform RWTexture2DArray<vec4> outputTexture1		SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<vec4> outputTexture3		SIMUL_RWTEXTURE_REGISTER(2);

uniform RWStructuredBuffer<VolumeQueryResult> volumeQueries;

uniform StructuredBuffer<vec3> queryInputs SIMUL_TEXTURE_REGISTER(3);

uniform RWStructuredBuffer<LineQueryResult> lineQueryResults;
CS_LAYOUT(1,1,1)
shader void CS_PointQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	uint num=0;
	uint byteStride=0;
	//queryInputs.GetDimensions(num,byteStride);
	//if(sub_pos.x>=num)
	//	return;
	VolumeQueryResult res;
	res.pos_km						=queryInputs[sub_pos.x+firstInput];
	res.valid						=1;
	vec3 cloudWorldOffsetKm			=res.pos_km-cornerPosKm;
	vec3 cloudTexCoords				=cloudWorldOffsetKm*inverseScalesKm;
	vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
	res.density						=lookup.z;
	vec4 light_lookup				=sample_3d_lod(cloudDensity2,cloudSamplerState,cloudTexCoords,0);
	res.direct_light				=light_lookup.y;
	res.indirect_light				=light_lookup.x;
	res.ambient_light				=light_lookup.w;
	res.precipitation				=GetRainAtOffsetKm( rainMapTexture, cloudWorldOffsetKm, inverseScalesKm, res.pos_km, rainCentreKm.xy, rainRadiusKm,rainEdgeKm);
	
	volumeQueries[sub_pos.x]		=res;
}

CS_LAYOUT(1,1,1)
shader void CS_LineQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	vec3 orig						=queryInputs[sub_pos.x*2+firstInput];
	vec3 start_pos					=orig;
	vec3 end_pos					=queryInputs[sub_pos.x*2+1+firstInput];
	vec3 diff						=end_pos-start_pos;
	float total_dist				=length(diff);
	if(total_dist<=0.0000001)
		return;
	float max_dist					=total_dist;
	LineQueryResult res;
	res.valid						=1;
	res.density						=0.0;
	res.visibility					=1.0;
	res.optical_thickness_km		=0.0;
	res.first_contact_km			=max_dist;
	vec3 dir						=diff/total_dist;
	float dz_plus					=max(0.0001, dir.z);
	float dz_minus					=max(0.0001,-dir.z);
	float start_dist=0;
	// How far under?
	vec3 offsetKm1					=start_pos-cornerPosKm;
	float under						=max(0.0,-offsetKm1.z);
	float over						=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
	start_dist						=max(over/dz_minus,under/dz_plus);
	start_dist						=min(start_dist,total_dist);
	start_pos						+=dir*start_dist;
	
	vec3 offsetKm2					=end_pos-cornerPosKm;
	// How far under?
	float under2					=max(0.0,-offsetKm2.z);
	float over2						=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
	float end_dist					=total_dist+max(over2/dz_minus,under2/dz_plus);
	end_dist						=min(end_dist,total_dist);
	end_dist						=max(start_dist,end_dist);
	end_pos							=start_pos+dir*end_dist;
	diff							=end_pos-start_pos;
	total_dist						=length(diff);
	
	res.pos1_km						=start_pos;
	res.pos2_km						=end_pos;

	//if(total_dist>0&&dot(dir,res.pos2_km-res.pos1_km)>0.0)
	if(start_dist<max_dist)
	{
		float stepSize						=total_dist/32.0;
		int i=0;
		for( i=0;i<33;i++)
		{
			vec3 pos						=lerp(start_pos,end_pos,float(i)/32.0);
			vec3 cloudTexCoords				=(pos-cornerPosKm)*inverseScalesKm;
			vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
			if(res.density==0.0&&lookup.z>0)
				res.first_contact_km		=min(res.first_contact_km,length(pos-orig));
			res.density						+=lookup.z/32.0;
			res.visibility					*=1.0-lookup.z;
			res.optical_thickness_km		+=stepSize*lookup.z;
		}
	}
	lineQueryResults[sub_pos.x]	=res;
}

#ifndef DETAIL_NOISE
	#define DETAIL_NOISE 1
#endif

void MixInLayer( uint3 g, uint3 t,bool clears)
{
	int3 idx	=int3(g*4+t)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	//if(idx.x>0&&idx.y>0&&idx.x<windowGrid.x-1&&idx.y<windowGrid.y-1)
	//	return;
	idx.xy		+=gridCentreTexel;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	vec3 texc	=vec3(idx)*scale+offset;
	vec4 c1		=cloudDensity.SampleLevel(cloudSamplerState,texc,0);
	vec4 c2		=cloudDensity2.SampleLevel(cloudSamplerState,texc,0);
	vec4 res	=lerp(c1,c2,cloud_interp);
	res.z		=saturate((res.z*2.0-0.5)*1.5+0.7);

	if (res.z > 0.05)
	{
		float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
		res.x		=localNoiseStrength/100.0*noise_factor;
		res.y		=localCellNoiseStrength*noise_factor;
		IMAGE_STORE_3D(outputTexture3d,idx,res);
	}
	else if(clears)
	{
		res.xy=0;
		IMAGE_STORE_3D(outputTexture3d,idx,res);
	}
}

CS_LAYOUT(4,4,4)
shader void CS_MixInit( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	MixInLayer(g,t,true);
}

CS_LAYOUT(4,4,4)
shader void CS_Mix( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	MixInLayer(g,t,false);
}

float WorleyFactor(vec3 worley_texcoord)
{
	float c			=0.5;
	float p			=0.75;
	float m			=1.0;
	float w			=0.0;
	worley_texcoord	*=2.3;
	for(int j=0;j<2;j++)
	{
		vec4 worley				=texture_wrap_lod(smallWorleyTexture3D,worley_texcoord,0);
		w						+=m*(worley.x-c);//+p*(worley.y-c)+p*p*(worley.z-c)+p*p*p*(worley.w-c))/(1.0+p+p*p+p*p*p);
		m						*=p;
		worley_texcoord			*=3.7;
	}
	//vec4 worley				=texture_wrap_lod(smallWorleyTexture3D,worley_texcoord,0);
	//float w=worley.x-c;
	return w;//2.0*w+0.5;
}

void MapToWindow( uint3 g , uint3 t ,bool clears)
{
	int3 idx			=int3(g*4+t)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	//if(idx.x>0&&idx.y>0&&idx.x<windowGrid.x-1&&idx.y<windowGrid.y-1)
	//	return;
	idx.xy				+=gridCentreTexel;
	idx.xy				+=int2(windowGrid.xy)/2;
	vec3 texc			=vec3(idx)*scale;//+offset;
	idx.xy				=idx.xy%int2(windowGrid.xy);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	float sine			=0;//sin(azimuth);
	float cosine		=1;//cos(azimuth);
	texc.xy				-=vec2(0.5,0.5);
	vec2 texc_r		=texc.xy;//	=vec2(texc.x*cosine+texc.y*sine,texc.x*-sine+texc.y*cosine);
	//texc_r				+=vec2(0.5,0.5);

	vec4 res			=texture_clamp_lod(rainMapTexture,texc_r.xy,0);
	res.z				*=step(0,texc_r.x)*step(0,texc_r.y)*step(texc_r.x,1.0)*step(texc_r.y,1.0);

	res.z				*=GetHumidityMultiplier(texc.z,res.z,baseLayer,transition,upperDensity);

	float maxz			=res.x;
	//res.z				*=saturate((maxz-texc.z)/0.1);
	float minz			=(cloudBaseKm-cloudOriginKm.z)/cloudScalesKm.z;
	res.z				*=saturate((texc.z-minz)/0.1);
	vec3 worley_texc	=0*worleyNoiseScale*vec3(idx)/float(windowGrid.z);
	float w				=WorleyFactor(worley_texc);
	res.z				=saturate(3.0*res.z-1.0+worleyNoiseStrength*w);
	//res.xyw=2.0*(float(idx.z)/64.0-0.5);
	res.x				=localNoiseStrength/100.0;
	res.y				=localCellNoiseStrength;
	if (clears||res.z > 0.50)
	{
		IMAGE_STORE_3D(outputTexture3d, idx, res);
	}
}
CS_LAYOUT(4,4,4)
shader void CS_MapToWindow( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	MapToWindow(g,t,false);
}
CS_LAYOUT(4,4,4)
shader void CS_MapToWindowInit( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	MapToWindow(g,t,true);
}

float ThicknessInDirection(vec3 texc,vec3 inverseScalesKm,vec3 dir)
{
	vec3 wpos			=texc/inverseScalesKm;
	float thickness		=0.0;
	int i				=0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	float s				=0.5*stepLengthKm;
	float maxh			=1.0/inverseScalesKm.z;
	float extinction	=6.5;
	for( i=0;i<122;i++)
	{
		wpos		+=dir*s;			// we expect stepLength in km for this shader
		vec3 tx		=wpos*inverseScalesKm;
		vec4 lookup	=texture_3d_wwc_lod(cloudDensity,tx,1)*saturate((maxh-wpos.z)/s);
		thickness	+=lookup.z*s;
		s			*=1.005;
	}
	return thickness;
}

CS_LAYOUT(4,4,4)
shader void WindowLighting(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	int3 idx	=int3(g*4+t)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	//if(idx.x>0&&idx.y>0&&idx.x<windowGrid.x-1&&idx.y<windowGrid.y-1)
	//	return;
	vec3 texc	=vec3(idx)/vec3(windowGrid);

	vec3 wpos			=texc/inverseScalesKm;
	float thickness		=0.0;
	int i				=0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	float s				=0.5*stepLengthKm;
	float maxh			=1.0/inverseScalesKm.z;
	float extinction	=6.5;
	thickness			=ThicknessInDirection(texc,inverseScalesKm,directionToSun);

	// find nearest direction to light for ambient lighting:
	float nearest=10000.0;
	vec3 nearest_dir=vec3(0,0,0);
	float total=0.0;
/*	for(int i=0;i<12;i++)
 	{
		vec3 random_dir=SphericalRandom(i*1.15+texc);
		float t			=0.00001+ThicknessInDirection(texc,inverseScalesKm,random_dir);
		nearest_dir+=random_dir/t;
		total+=1.0/t;
	}
	nearest_dir=0.5+0.5*normalize(nearest_dir);*/
	vec4 illum;
	illum.x			=exp(-extinction*thickness/36.0);
	illum.y			=exp(-extinction*thickness);
	illum.zw		=1;//nearest_dir.xy;
//illum=texture_3d_wwc_lod(cloudDensity,texc,0);
	IMAGE_STORE_3D(outputTexture3d,idx,illum);
}


CS_LAYOUT(4,4,1)
shader void CS_Mip( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=(g*uint3(4,4,1)+t)*uint3(amortizationScale)+uint3(amortizationOffset.xyz);
	int3 pos2=int3(pos)*2;

#ifndef __PSSL__
	vec4 c1		=cloudDensity[pos2+int3(0,0,0)];
	vec4 c2		=cloudDensity[pos2+int3(1,0,0)];
	vec4 c3		=cloudDensity[pos2+int3(-1,0,0)];
	vec4 c4		=cloudDensity[pos2+int3(0,1,0)];
	vec4 c5		=cloudDensity[pos2+int3(0,-1,0)];
	vec4 c6		=cloudDensity[pos2+int3(0,0,1)];
	vec4 c7		=cloudDensity[pos2+int3(0,0,-1)];
	vec4 res	=(c1+c2+c3+c4+c5+c6+c7)/7.0;
	IMAGE_STORE_3D(outputTexture3d,pos,res);
#endif
}

CS_LAYOUT(8,8,8)
shader void CS_Simulate( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=g*8+t;
	vec4 c1=TEXTURE_LOAD_3D(cloudDensity,pos);
	vec4 c2=TEXTURE_LOAD_3D(cloudDensity2,pos);
	//res.z=1.0;
	//output[pos].rgba=res;
    vec4 res= lerp(c1,c2,cloud_interp);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
	//outputTexture3d[pos].rgba=res;
}
// Given texture position from texCoords, convert to a worldpos with shadowMatrix.
// Then, trace towards sun to find initial intersection with cloud volume
// Then trace down to find first intersection with clouds, if any.
shader vec4 PS_CloudShadow( posTexVertexOutput IN):SV_TARGET
{
	vec3 simple_texc				=vec3(IN.texCoords,0);
	vec2 shadow						=saturate(3.0*sample_3d_lod(cloudDensity,wwcSamplerState,simple_texc,0).xy-vec2(2.0,2.0));
	return vec4(shadow.xy,0,shadow.x);
}

shader vec4 PS_RainMap(posTexVertexOutput IN) : SV_TARGET
{
	float total_cloud=0.0;
	float max_tex_z=0.0;
	for(int i=0;i<14;i++)
	{
		float tex_z		=float(i)/14.0/3.0;
		vec3 texc		=vec3(IN.texCoords.xy,tex_z);
		vec4 density	=sample_3d_lod(cloudDensity,cloudSamplerState,texc,0);
		total_cloud		+=0.125*density.z;
		max_tex_z		=max(max_tex_z,step(0.5,density.z)*tex_z);
	}
	total_cloud=saturate((total_cloud-0)/0.1);
	return vec4(total_cloud*precipitation,max_tex_z,0,0);
}

struct FarNearDepthPixelOutput
{
	vec4 farColour		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 nearColour		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 nearFarDepth	SIMUL_RENDERTARGET_OUTPUT(2);
};

void SimpleRaytrace(uint3 pos,bool include_rain,bool depth,bool background2d=true,int numSteps=200,int num_interp=NUM_CLOUD_INTERP)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if (depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);
	
	RaytracePixelOutput f	=RaytraceCloudsStatic( 
									cloudDensity
									,cloudDensity2
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture
									,volumeInscatterTexture
									,depth
									,dlookup
									,view
									,clip_pos
									,worldspaceVolumeTexCoordsXyC
									,background2d		// noise? 
									,include_rain
									,false
									,cloudIrRadiance1,cloudIrRadiance2
									,numSteps
									,num_interp);
	vec4 t2d;
	if(background2d)
	{
		t2d				=texture_cube_lod(clouds2DTexture,view,0);
	}
	else
	{
		t2d				=vec4(0,0,0,1.0);
	}
	// blend:

	vec4 c					=t2d;
	c.rgb					*=f.colour[num_interp-1].a;
	c.rgb					+=f.colour[num_interp-1].rgb;

	c.a						=t2d.a*f.colour[num_interp-1].a;
	
	outputTexture1[pos+uint3(0,0,6*(num_interp-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<num_interp-1;u++)
	{
		vec4 cn					=t2d;
		cn.rgb					*=f.colour[u].a*n;
		cn.a					=1.0-n*(1.0-t2d.a);
		cn.rgb					+=f.colour[u].rgb;
		cn.a					*=f.colour[u].a;
		//cn.b=1;
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
	//	outputTexture1[pos+uint3(0,0,6*2)]		=vec4(0,1,0,0);
	if(background2d)
		outputTexture3[pos]		=f.nearFarDepth;
}


#define BLOCK_SIZE 4

void CS_RaytraceStaticEdge(uint3 g: SV_GroupID, uint3 t: SV_GroupThreadID,bool include_rain,bool depth)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx,Z);
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	vec4 u=updateTexture[pos];
	if (u.r<1.0&&u.b>0.0)
	{
		//outputTexture1[pos]		=vec4(1,1,0,1);
		//outputTexture3[pos]		=vec4(1,1,0,1);
		SimpleRaytrace(pos,include_rain,depth);
	}
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,false,true);
}


shader posTexVertexOutput VS_CrossSection(idOnly IN)
{
	return VS_ScreenQuad(IN,rect);
}


fxgroup raytrace
{
	technique edge_stat
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeNoRain()));
		}
	}
}