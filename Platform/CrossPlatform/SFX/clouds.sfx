//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.

// Recommended by D Cook of MS to fix Xbox compiler crash:
#define __XBOX_DISABLE_ITERATION

#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/simul_cloud_constants.sl"
#include "../SL/depth.sl"

uniform Texture3D smallWorleyTexture3D				SIMUL_TEXTURE_REGISTER(12);

#include "../SL/simul_clouds.sl"
#include "../SL/clouds_simple.sl"
#include "../SL/clouds_raytrace.sl"
#include "../SL/states.sl"
#include "../SL/earth_shadow_fade.sl"
#include "../SL/debug_constants.sl"
#include "../SL/gpu_cloud_constants.sl"
#include "../SL/simul_gpu_clouds.sl"
#include "../SL/noise.sl"

uniform Texture3D cloudDensity			SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D cloudDensity2			SIMUL_TEXTURE_REGISTER(1);
uniform Texture3D noiseTexture3D		SIMUL_TEXTURE_REGISTER(2);
uniform Texture3D godraysTexture		SIMUL_TEXTURE_REGISTER(3);
uniform Texture3D volumeInscatterTexture		SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D lossTexture		SIMUL_TEXTURE_REGISTER(5);
uniform Texture2D inscTexture		SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D skylTexture	SIMUL_TEXTURE_REGISTER(3);
uniform TextureCube depthTexture;
uniform Texture2D illuminationTexture;
uniform Texture2D lightTableTexture;
uniform Texture2D rainbowLookupTexture;
uniform Texture2D coronaLookupTexture;
uniform Texture2D rainMapTexture;
/// The previous texture area:
uniform Texture2DArray updateTexture;
uniform RWTexture3D<uchar4> outputTexture3d		SIMUL_RWTEXTURE_REGISTER(0);
#ifdef SFX_TYPED_UAV_LOADS
uniform RWTexture3D<uchar4> packedOutputTexture3d		SIMUL_RWTEXTURE_REGISTER(0);
#else
uniform RWTexture3D<uint> packedOutputTexture3d		SIMUL_RWTEXTURE_REGISTER(0);
#endif
uniform RWTexture2DArray<vec4> outputTexture1		SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<vec4> outputTexture3		SIMUL_RWTEXTURE_REGISTER(2);

uniform RWStructuredBuffer<VolumeQueryResult> volumeQueries SIMUL_RWTEXTURE_REGISTER(4);

uniform StructuredBuffer<vec3> queryInputs SIMUL_TEXTURE_REGISTER(3);

uniform RWStructuredBuffer<LineQueryResult> lineQueryResults SIMUL_RWTEXTURE_REGISTER(5);
CS_LAYOUT(1,1,1)
shader void CS_PointQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	uint num=0;
	uint byteStride=0;
	//queryInputs.GetDimensions(num,byteStride);
	//if(sub_pos.x>=num)
	//	return;
	VolumeQueryResult res;
	res.pos_km						=queryInputs[sub_pos.x+firstInput];
	res.valid						=1;
	vec3 cloudWorldOffsetKm			=res.pos_km-cornerPosKm;
	vec3 cloudTexCoords				=cloudWorldOffsetKm*inverseScalesKm;
	vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
	res.density						=lookup.z;
	vec4 light_lookup				=sample_3d_lod(cloudDensity2,cloudSamplerState,cloudTexCoords,0);
	res.direct_light				=light_lookup.y;
	res.indirect_light				=light_lookup.x;
	res.ambient_light				=light_lookup.w;
	res.precipitation				=GetRainAtOffsetKm( rainMapTexture, cloudWorldOffsetKm, inverseScalesKm, res.pos_km, rainCentreKm.xy, rainRadiusKm,rainEdgeKm);
	res.rain_to_snow				=0.0;
	volumeQueries[sub_pos.x]		=res;
}

CS_LAYOUT(1,1,1)
shader void CS_LineQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	vec3 orig						=queryInputs[sub_pos.x*2+firstInput];
	vec3 start_pos					=orig;
	vec3 end_pos					=queryInputs[sub_pos.x*2+1+firstInput];
	vec3 diff						=end_pos-start_pos;
	float total_dist				=length(diff);
	if(total_dist<=0.0000001)
		return;
	float max_dist					=total_dist;
	LineQueryResult res;
	res.valid						=1;
	res.density						=0.0;
	res.visibility					=1.0;
	res.optical_thickness_km		=0.0;
	res.first_contact_km			=max_dist;
	vec3 dir						=diff/total_dist;
	float dz_plus					=max(0.0001, dir.z);
	float dz_minus					=max(0.0001,-dir.z);
	float start_dist=0;
	// How far under?
	vec3 offsetKm1					=start_pos-cornerPosKm;
	float under						=max(0.0,-offsetKm1.z);
	float over						=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
	start_dist						=max(over/dz_minus,under/dz_plus);
	start_dist						=min(start_dist,total_dist);
	start_pos						+=dir*start_dist;
	
	vec3 offsetKm2					=end_pos-cornerPosKm;
	// How far under?
	float under2					=max(0.0,-offsetKm2.z);
	float over2						=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
	float end_dist					=total_dist+max(over2/dz_minus,under2/dz_plus);
	end_dist						=min(end_dist,total_dist);
	end_dist						=max(start_dist,end_dist);
	end_pos							=start_pos+dir*end_dist;
	diff							=end_pos-start_pos;
	total_dist						=length(diff);
	
	res.pos1_km						=start_pos;
	res.pos2_km						=end_pos;

	//if(total_dist>0&&dot(dir,res.pos2_km-res.pos1_km)>0.0)
	if(start_dist<max_dist)
	{
		float stepSize						=total_dist/32.0;
		int i=0;
		for( i=0;i<33;i++)
		{
			vec3 pos						=lerp(start_pos,end_pos,float(i)/32.0);
			vec3 cloudTexCoords				=(pos-cornerPosKm)*inverseScalesKm;
			vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
			if(res.density==0.0&&lookup.z>0)
				res.first_contact_km		=min(res.first_contact_km,length(pos-orig));
			res.density						+=lookup.z/32.0;
			res.visibility					*=1.0-lookup.z;
			res.optical_thickness_km		+=stepSize*lookup.z;
		}
	}
	lineQueryResults[sub_pos.x]	=res;
}

#ifndef DETAIL_NOISE
	#define DETAIL_NOISE 1
#endif

#ifdef SFX_TYPED_UAV_LOADS
vec4 UnpackUintToVec4(vec4 a)
{
	return a;
}
vec4 PackVec4ToUint(vec4 a)
{
	return a;
}
#else

vec4 UnpackUintToVec4(uint i)
{
	vec4 o;
	o.r=((i&0x000000FFu)		)/255.0;
	o.g=((i&0x0000FF00u)>>8u	)/255.0;
	o.b=((i&0x00FF0000u)>>16u	)/255.0;
	o.a=((i&0xFF000000u)>>24u	)/255.0;
	return o;
}

uint PackVec4ToUint(vec4 i)
{
	uint o=0u;
	i=saturate(i);
	o|=(uint(i.x*255.0));
	o|=(uint(i.y*255.0)<<8u);
	o|=(uint(i.z*255.0)<<16u);
	o|=(uint(i.w*255.0)<<24u);
	//uint(i.w*255.0)|(uint(i.z*255.0)<<16u)|(uint(i.y*255.0)<<32u)|;
	return o;
}
#endif


// idx is the position relative to the grid centre texel.
// we add gridCentreTexel and mod to get the true position in the texture.
void MixInLayer( int3 p,bool clears)
{
	int3 idx	=p*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	idx.xy		+=gridCentreTexel;
	vec3 texc	=vec3(idx-int3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
//	if(texc.z<0||texc.z>1.0)
//		return;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	vec4 res = 0.0;
	for (int i = -2; i < 3; i++)
	{
		vec3 tc		= texc;
		tc.z		+= zPixel*i;
		vec4 c1		= cloudDensity.SampleLevel(wwcSamplerState, tc, 0);
		vec4 c2		= cloudDensity2.SampleLevel(wwcSamplerState, tc, 0);

		res			+= lerp(c1, c2, cloud_interp).zyxw/5.0;
	}

	float zPixel1=1.0/float(windowGrid.z);

	res.z		=saturate((res.z-0.25)/diffusivity+0.25);
	float layer_saturate	=saturate(texc.z / zPixel1 - 0.5)*saturate((1.0 - 0.5*zPixel1 - texc.z)/ zPixel1);
	res.z*= 1.0/0.5*layer_saturate;

	// x= edge noise, y= worley edge noise, z=density, w=sharpness.
	res.w=1.0;
	
	vec4 current=vec4(0,0,0,1.0);
	if(!clears)
	{
		current=UnpackUintToVec4(packedOutputTexture3d[idx]);
	}
	
	// stronger noise at the top:
	float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
	// variation:
	noise_factor *= (0.05 + rand3(idx).x);
	res.x		=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
	res.y		=localCellNoiseStrength*noise_factor;

	res.xyw		=lerp(current.xyw,res.xyw,layer_saturate);
	res.z		=max(res.z*max_density_gm3,current.z);
	IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
	
}

void MixInCirrus(uint3 ii,bool clears)
{
	int3 idx	=int3(ii)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	idx.xy		+=gridCentreTexel;
	vec3 texc	=vec3(idx-int3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	
	float fall_amount=saturate(1.0-texc.z);
	texc.xy+=0.1*pow(fall_amount,3.0);
	// fall streaks.
	vec4 res = 0.0;
	for (int i = -2; i < 3; i++)
	{
		vec3 tc		=	texc;
		tc.z		+=	zPixel*i;
		vec4 c1		=	cloudDensity.SampleLevel(wrapSamplerState, tc, 0);
		vec4 c2		=	cloudDensity2.SampleLevel(wrapSamplerState, tc, 0);
		res			+=	lerp(c1, c2, cloud_interp).zyxw/5.0;
	}

	float zPixel1=1.0/float(windowGrid.z);
	res.z		=saturate((res.z-0.5)/diffusivity);
	//res.z=frac(float(idx.x)/float(windowGrid.x));
	float layer_saturate	=saturate(texc.z / zPixel1 - 0.5)*saturate((1.0 - 0.5*zPixel1 - texc.z) / zPixel1);
	res.z*=saturate(1.0-fall_amount)*layer_saturate;
	vec4 current=vec4(0,0,0,0.0);
	if(clears)
		current=vec4(res.xy,res.z*max_density_gm3,res.w);
	else
		current=UnpackUintToVec4(packedOutputTexture3d[idx]);
	{
		float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
		noise_factor *= (0.05 + rand3(idx).x);
		res.x		=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
		res.y		=localCellNoiseStrength*noise_factor;
		res.w		=0;
			//res.xyw		=lerp(current.xyw,res.xyw,res.z);
			res.xyw		=lerp(current.xyw,res.xyw,layer_saturate);
		res.z		=max(res.z*max_density_gm3,current.z);
		IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
	}
}

CS_LAYOUT(4,4,4)
shader void CS_MixInit( uint3 idx : SV_DispatchThreadID )
{
	MixInLayer(idx,true);
}

CS_LAYOUT(4,4,4)
shader void CS_Mix( uint3 idx : SV_DispatchThreadID )
{
	MixInLayer(idx,false);
}

CS_LAYOUT(4,4,4)
shader void CS_MixCirrusInit( uint3 idx : SV_DispatchThreadID )
{
	MixInCirrus(idx,true);
}

CS_LAYOUT(4,4,4)
shader void CS_MixCirrus( uint3 idx : SV_DispatchThreadID )
{
	MixInCirrus(idx,false);
}

float WorleyFactor(vec3 worley_texcoord)
{
	float c			=0.5;
	float p			=0.75;
	float m			=1.0;
	float w			=0.0;
	worley_texcoord	*=2.3;
	for(int j=0;j<2;j++)
	{
		vec4 worley				=texture_wrap_lod(smallWorleyTexture3D,worley_texcoord,0);
		w						+=m*(worley.x-c);//+p*(worley.y-c)+p*p*(worley.z-c)+p*p*p*(worley.w-c))/(1.0+p+p*p+p*p*p);
		m						*=p;
		worley_texcoord			*=3.7;
	}
	//vec4 worley				=texture_wrap_lod(smallWorleyTexture3D,worley_texcoord,0);
	//float w=worley.x-c;
	return w;//2.0*w+0.5;
}

void MapToWindow( uint3 p ,bool clears)
{
	int3 idx			=p*int3(amortizationScale)+int3(amortizationOffset.xyz);
	//if(idx.x>0&&idx.y>0&&idx.x<windowGrid.x-1&&idx.y<windowGrid.y-1)
	//	return;
	idx.xy				+=gridCentreTexel;
	idx.xy				+=int2(windowGrid.xy)/2;
	vec3 texc			=vec3(idx)*scale;//+offset;
	idx.xy				=idx.xy%int2(windowGrid.xy);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	float sine			=0;//sin(azimuth);
	float cosine		=1;//cos(azimuth);
	texc.xy				-=vec2(0.5,0.5);
	vec2 texc_r		=texc.xy;//	=vec2(texc.x*cosine+texc.y*sine,texc.x*-sine+texc.y*cosine);
	//texc_r				+=vec2(0.5,0.5);

	vec4 res			=texture_clamp_lod(rainMapTexture,texc_r.xy,0);
	res.z				*=step(0,texc_r.x)*step(0,texc_r.y)*step(texc_r.x,1.0)*step(texc_r.y,1.0);

	res.z				*=GetHumidityMultiplier(texc.z,res.z,baseLayer,transition,upperDensity);

	float maxz			=res.x;
	//res.z				*=saturate((maxz-texc.z)/0.1);
	float minz			=(cloudBaseKm-cloudOriginKm.z)/cloudScalesKm.z;
	res.z				*=saturate((texc.z-minz)/0.1);
	vec3 worley_texc	=0*worleyNoiseScale*vec3(idx)/float(windowGrid.z);
	float w				=WorleyFactor(worley_texc);
	res.z				=saturate(3.0*res.z-1.0+worleyNoiseStrength*w);
	//res.xyw=2.0*(float(idx.z)/64.0-0.5);
	res.x				=saturate(localNoiseStrength/MaxNoiseAmplitudeKm);
	res.y				=localCellNoiseStrength;
	if (clears||res.z > 0.50)
	{
		IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
	}
}
CS_LAYOUT(4,4,4)
shader void CS_MapToWindow(uint3 idx : SV_DispatchThreadID)
{
	MapToWindow(idx,false);
}

CS_LAYOUT(4,4,4)
shader void CS_MapToWindowInit(uint3 idx : SV_DispatchThreadID)
{
	MapToWindow(idx,true);
}

float ThicknessKmInDirection(vec3 texc,vec3 inverseScalesKm,vec3 dir)
{
	float thicknessKm		=0.0;
	int i				=0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	float s				=0.2*stepLengthKm;
	float maxh			=1.0/inverseScalesKm.z;
	vec3 tx				=texc;
	vec3 dir_texc		=dir*inverseScalesKm;
	for( i=0;i<9;i++)
	{
		// we expect stepLength in km for this shader
		float lookup = texture_3d_wwc_lod(cloudDensity, vec3(tx), 1).z;// *saturate((maxh - wpos.z) / s);
		thicknessKm		+=lookup*s;
		tx				+=dir_texc*s;	// we expect stepLength in km for this shader
		s				*=1.3;
	}
	return thicknessKm;
}

CS_LAYOUT(4,4,4)
shader void CS_WindowLighting(uint3 p : SV_DispatchThreadID)
{
	int3 idx	=int3(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	idx.xy		+=gridCentreTexel;
	vec3 texc	=vec3(idx-int3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	vec3 texc_o	=vec3(idx)/vec3(windowGrid);

	vec3 wpos = texc / inverseScalesKm;
	float thicknessKm		=0.0;
	int i				=0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	float s				=0.5*stepLengthKm;
	float maxh			=1.0/inverseScalesKm.z;

	thicknessKm = ThicknessKmInDirection(texc_o,inverseScalesKm,lightDir);

	// find nearest direction to light for ambient lighting:
	float nearest=10000.0;
	vec3 nearest_dir=vec3(0,0,0);
	float total=0.0;
/*	for(int i=0;i<12;i++)
 	{
		vec3 random_dir=SphericalRandom(i*1.15+texc);
		float t			=0.00001+ThicknessInDirection(texc,inverseScalesKm,random_dir);
		nearest_dir+=random_dir/t;
		total+=1.0/t;
	}
	nearest_dir=0.5+0.5*normalize(nearest_dir);*/
	vec4 illum;

	illum.x			=exp(-extinctionPerKm*thicknessKm / 12);
	illum.y			=exp(-extinctionPerKm*thicknessKm);
	illum.zw = 1;// nearest_dir.xy;
//illum=texture_3d_wwc_lod(cloudDensity,texc,0);
	IMAGE_STORE_3D(outputTexture3d,idx,illum);
}


CS_LAYOUT(4,4,1)
shader void CS_CloudMip( uint3 p: SV_DispatchThreadID )
{
	int3 pos=(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if (pos.x >= exclusionRange.x&&pos.y >= exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	pos.xy		+= gridCentreTexel;
	pos.xy		+= int2(windowGrid.xy + windowGrid.xy / 2);
	pos.xy		= pos.xy%int2(windowGrid.xy);
	vec3 texc	= (vec3(pos)+vec3(0.5,0.5,0.5)) / vec3(windowGrid.xyz);
	uint3 pos2	=pos*2;
	vec4 res;
	{
		vec4 c1 = cloudDensity.SampleLevel(wwcSamplerState,texc,0);
	/*	vec4 c2 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c3 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c4 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c5 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c6 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c7 = cloudDensity[pos2 + uint3(0, 0, 0)];
		vec4 c8 = cloudDensity[pos2 + uint3(0, 0, 0)];
		res = (c1 + c2 + c3 + c4 + c5 + c6 + c7 + c8) / 8.0;*/
		res = c1;
	}
	///else
	//	res = vec4(1, 0, 1, 1);
	outputTexture3d[pos]=res;
}

CS_LAYOUT(8,8,8)
shader void CS_Simulate( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=g*8+t;
	vec4 c1=TEXTURE_LOAD_3D(cloudDensity,pos);
	vec4 c2=TEXTURE_LOAD_3D(cloudDensity2,pos);
	//res.z=1.0;
	//output[pos].rgba=res;
    vec4 res= lerp(c1,c2,cloud_interp);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
	//outputTexture3d[pos].rgba=res;
}
// Given texture position from texCoords, convert to a worldpos with shadowMatrix.
// Then, trace towards sun to find initial intersection with cloud volume
// Then trace down to find first intersection with clouds, if any. 
shader vec4 PS_AltCloudShadow( posTexVertexOutput IN):SV_TARGET
{
	float tempLength = sqrt(pow(directionToSun.x, 2) + pow(directionToSun.y, 2));
	float angle = sinh(directionToSun.x / tempLength);
	float s = sin(angle);
	float c = cos(angle);
	angle = tanh(directionToSun.z / tempLength);
	float scale = 1.0 / sin(angle);
	vec2 cameraOffset = vec2(viewPosKm.xy) / 75.0;
	vec2 cloudOffset = vec2(0.5, 0.5);
	float tempx = (IN.texCoords.x - 0.5) * 0.125;
	float tempy = (IN.texCoords.y - 0.5) * scale * 0.125;
	float x = ((tempx * c) - (tempy * s)) + 0.5 - cloudOffset.x - cameraOffset.x;
	float y = ((tempx * s) + (tempy * c)) + 0.5 - cloudOffset.y - cameraOffset.y;
	vec3 adjusted_texc = vec3(x, y, sampleHeight);
	vec3 simple_texc = vec3(IN.texCoords.xy,sampleHeight);
	vec3 shadow = saturate(3.0*sample_3d_lod(cloudDensity, wwcSamplerState, adjusted_texc, 0.0) - vec3(2.0,2.0,2.0));
	return vec4(shadow.xy, 0, 1.0 - shadow.z);
}

shader vec4 PS_CloudShadow(posTexVertexOutput IN) :SV_TARGET
{
	vec3 simple_texc = vec3(IN.texCoords.xy, sampleHeight);
	vec3 shadow = saturate(3.0*sample_3d_lod(cloudDensity, wwcSamplerState, simple_texc, 0.0) - vec3(2.0, 2.0, 2.0));
	return vec4(shadow.xy, 0, 1.0 - shadow.z);
}

shader vec4 PS_RainMap(posTexVertexOutput IN) : SV_TARGET
{
	float total_cloud=0.0;
	float max_tex_z=0.0;
	float thickness = 0.0;
	// We will trace downward. The first point where enough cloud has accumulated on the way is where rain starts.
	for(int i=0;i<14;i++)
	{
		float tex_z		=float(14.0-i)/20.0;
		vec3 texc		=vec3(IN.texCoords.xy,tex_z);
		vec4 density	=sample_3d_lod(cloudDensity,cloudSamplerState,texc,0);
		total_cloud		+=0.125*density.z;
		thickness		+=1.0*density.z;		// effective cloud thickness in km.
		max_tex_z		=max(max_tex_z,step(1.0, thickness)*tex_z);
	}
	total_cloud=saturate((total_cloud-0)/0.1);
	return vec4(total_cloud*precipitation,max_tex_z,0,0);
}

struct FarNearDepthPixelOutput
{
	vec4 farColour		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 nearColour		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 nearFarDepth	SIMUL_RENDERTARGET_OUTPUT(2);
};

void SimpleRaytrace(uint3 pos,bool include_rain,bool depth,bool background2d,int numSteps,int num_interp,bool do_godrays,bool consistent_steps)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if (depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);
	
	RaytracePixelOutput f	=RaytraceCloudsStatic( 
									cloudDensity
									,cloudDensity2
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture
									,volumeInscatterTexture
									,godraysTexture
									,depth
									,dlookup
									,view
									,clip_pos
									,worldspaceVolumeTexCoordsXyC
									,background2d		// noise? 
									,include_rain
									,false
									,cloudIrRadiance1,cloudIrRadiance2
									,numSteps
									,num_interp
									,do_godrays
									,consistent_steps);
	vec4 t2d				=vec4(0,0,0,1.0);
	// blend:

	vec4 c					=t2d;
	c.rgb					*=f.colour[num_interp-1].a;
	c.rgb					+=f.colour[num_interp-1].rgb;
	c.a						=t2d.a*f.colour[num_interp-1].a;
	outputTexture1[pos+uint3(0,0,6*(num_interp-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<num_interp-1;u++)
	{
		vec4 cn					=t2d;
		cn.rgb					*=f.colour[u].a*n;
		cn.a					=1.0-n*(1.0-t2d.a);
		cn.rgb					+=f.colour[u].rgb;
		cn.a					*=f.colour[u].a;
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
	//	outputTexture1[pos+uint3(0,0,6*2)]		=vec4(0,1,0,0);
	if(background2d)
		outputTexture3[pos]		=f.nearFarDepth;
}

void Raytrace(uint3 pos,bool include_rain,bool depth,int num_interp,bool do_godrays)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec3 v	=abs(view);
	float e	=max(max(v.x,v.y),v.z);
	float ef	=max(max(view.x,view.y),view.z);
	// All D components are positive. Only the smallest is equal to e. Step(x,y) returns (y>=x). So step(D.x,e) returns (e>=D.x), which is only true if e==D.x
	vec3 N	=0.005*saturate(-view)+saturate(view);

#if 1
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if(depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);

	RaytracePixelOutput f	=RaytraceCloudsForward(cloudDensity
													,cloudDensity2
													,rainMapTexture
													,noiseTexture3D
													,lightTableTexture
													,illuminationTexture
													,rainbowLookupTexture
													,coronaLookupTexture
													,lossTexture
													,inscTexture
													,skylTexture
													,volumeInscatterTexture
													,godraysTexture
													,true
													,dlookup
													,view
													,clip_pos
													,worldspaceVolumeTexCoordsXyC
													,true
													,include_rain
													,false
													,cloudIrRadiance1,cloudIrRadiance2
													,num_interp
													,do_godrays
													);
	/*RaytracePixelOutput f;
	f.colour=depthToLinFadeDistParams;
	f.nearColour=lightResponse;
	f.nearFarDepth=vec4(0,0,1,.5);*/
	// blend:
	vec4 c					=f.colour[NUM_CLOUD_INTERP-1];
	outputTexture1[pos+uint3(0,0,6*(NUM_CLOUD_INTERP-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<NUM_CLOUD_INTERP-1;u++)
	{
		vec4 cn					=f.colour[u];
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
	outputTexture3[pos]		=f.nearFarDepth;
#endif
}

void Lightpass(uint3 pos,bool depth)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,1.0,1.0);
	if(depth)
		dlookup				=texture_cube_lod(depthTexture,view,0);

	vec3 lightspaceView		=normalize((mul(worldToScatteringVolumeMatrix,vec4(view,1.0))).xyz);

	float ls_angle			=asin(lightspaceView.z);
	vec3 volumeTexCoordsXyC	=vec3(atan2(lightspaceView.x,lightspaceView.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*ls_angle/SIMUL_PI_F),max(0.3,cos(ls_angle)));
#if 1//ndef _XBOX_ONE
	FarNearPixelOutput f	=Lightpass(cloudDensity
										,noiseTexture3D
										,dlookup
										,view
										,clip_pos
										,sourcePosKm
										,sourceRadiusKm
										,spectralFluxOver1e6
										,minCosine
										,maxRadiusKm
										,irradianceThreshold
										);
#else
	FarNearPixelOutput f;
	f.farColour=vec4(0,0,0,0);
	f.nearColour=vec4(0,0,0,0);
#endif
	outputTexture1[pos]		=f.farColour;
	outputTexture1[pos+uint3(0,0,6)]		=f.nearColour;
}
#define BLOCK_SIZE 4
void CS_Raytrace(uint3 g: SV_GroupID, uint3 t: SV_GroupThreadID,bool include_rain,bool depth,bool godrays)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offs		= (amortizationOffset.xy + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy += offs;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	Raytrace(pos,include_rain,depth,NUM_CLOUD_INTERP,godrays);
}

void CS_RaytraceStatic(uint3 g: SV_GroupID, uint3 t: SV_GroupThreadID,bool include_rain,bool depth,bool godrays,bool consistent_steps)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offs		= (amortizationOffset.xy + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy			+= offs;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	//outputTexture1[pos]		=vec4(1,1,0,1);
	//outputTexture3[pos]		=vec4(1,1,0,1);
	SimpleRaytrace(pos,include_rain,depth,true,raytraceSteps,NUM_CLOUD_INTERP,godrays,consistent_steps);
}

void CS_RaytraceStaticEdge(uint3 g: SV_GroupID, uint3 t: SV_GroupThreadID,bool include_rain,bool depth,bool godrays,bool consistent_steps)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx,Z);
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	vec4 u=updateTexture[pos];
	if (u.g<1.0&&u.b>0.0)
	{
		//outputTexture1[pos]		=vec4(1,1,0,1);
		//outputTexture3[pos]		=vec4(1,1,0,1);
		SimpleRaytrace(pos,include_rain,depth,true,raytraceSteps,NUM_CLOUD_INTERP,godrays,consistent_steps);
	}
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Lightpass(uint3 g: SV_GroupID,uint3 t: SV_GroupThreadID)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint3 pos		=uint3(targetRange[cubemapTargetIndex].xy+idx*amortizationScale.xy,cubemapTargetIndex);
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[cubemapTargetIndex].z||pos.y>=targetRange[cubemapTargetIndex].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	Lightpass(pos,true);
}

shader vec4 PS_Lightpass(posTexVertexOutput IN):SV_TARGET
{
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*IN.texCoords.x;
	clip_pos.y				-=2.0*IN.texCoords.y;
	vec3 view				=normalize(mul(invViewProj[cubemapTargetIndex],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,1.0,1.0);
//	dlookup					=texture_cube_lod(depthTexture,view,0);

	FarNearPixelOutput f	=Lightpass(cloudDensity
										,noiseTexture3D
										,dlookup
										,view
										,clip_pos
										,sourcePosKm
										,sourceRadiusKm
										,spectralFluxOver1e6
										,minCosine
										,maxRadiusKm
										,irradianceThreshold
										);
	return vec4(f.farColour.rgb,1);
}

void Edge(uint3 g, uint3 t, bool rain, bool depth, bool godrays)
{
	uint2 idx = uint2(g.xy*BLOCK_SIZE + t.xy);
	uint Z = cubemapFaceIndex[g.z + t.z].x;
	uint3 pos = uint3(targetRange[Z].xy + idx, Z);
	if (pos.x >= targetRange[Z].z || pos.y >= targetRange[Z].w)
		return;
	vec4 u = updateTexture[pos];
	// current value is b, old value is r
	if (u.g<1.0&&u.b>0.0)
	{
		Raytrace(pos, rain, depth, NUM_CLOUD_INTERP, godrays);
	}
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Edge_NoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Edge(g, t, false, true, true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Edge_Rain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Edge(g, t, true, true, true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceSimple(uint3 g : SV_GroupID,uint3 t : SV_GroupThreadID)
{
	uint2 idx				=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z					=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos				=uint3(targetRange[t.z].xy+idx*amortizationScale.xy+amortizationOffset.xy,Z);
	
	SimpleRaytrace(pos,false,false,false,128,1,false,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceHighDetailCubemap(uint3 g : SV_GroupID,uint3 t : SV_GroupThreadID)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offset = (amortizationOffset.xy + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy += offset;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	Raytrace(pos, false, false,NUM_CLOUD_INTERP,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,false,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,true,true,true,false);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,false,true,true,false);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,true,true,true,false);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,false,true,true,false);
}



CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,true,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticNoRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,false,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,true,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeNoRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,false,true,true,true);
}





shader posTexVertexOutput VS_CrossSection(idOnly IN)
{
	return VS_ScreenQuad(IN,rect);
}

shader posTexVertexOutput VS_PlacementVolume(idOnly IN)
{
	posTexVertexOutput OUT;
	vec2 poss[4];
	poss[0]			=vec2(0.0, 0.0);
	poss[1]			=vec2(1.0, 0.0);
	poss[2]			=vec2(1.0, 1.0);
	poss[3]			=vec2(0.0, 1.0);
	vec3 pos		=vec3(0,0,0);
	int odd			=int(IN.vertex_id%uint(2));
	if(IN.vertex_id<8)
	{
		pos.z=0.0;
		uint j=(uint(IN.vertex_id)/2+odd);
		pos.xy=poss[j%4];
	}
	else if(IN.vertex_id<16)
	{
		pos.z=1.0;
		uint i=uint(IN.vertex_id)-8;
		uint j=(i/2+odd);
		pos.xy=poss[j%4];
	}
	else
	{
		uint i=uint(IN.vertex_id)-16;
		uint j=i/2;
		pos.z=float(i%2);
		pos.xy=poss[j%4];
	}

	OUT.hPosition	=mul(invViewProj[cubemapTargetIndex],vec4(pos,1.0));
	OUT.texCoords	=vec2(pos.z,0);
	return OUT;
}

shader vec4 PS_PlacementVolume(posTexVertexOutput IN):SV_TARGET
{
	return vec4(1.0,1.0,IN.texCoords.x,1.0);
}
shader vec4 PS_ShowNoise(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup=texture_wrap(rainMapTexture,IN.texCoords.xy);
					
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_Show3DNoise(posTexVertexOutput IN):SV_TARGET
{
	float z = 0; floor(8.0f*IN.texCoords.x) / 8.0f;
	//if(IN.texCoords.y<0.5)
		z=0.5;
	vec4 lookup		=texture_3d_nearest_lod(noiseTexture3D,vec3(IN.texCoords,z),0);
	
	//vec4 lookup = VirtualNoiseLookup(vec3(IN.texCoords, z), 4, 1, true);
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_ShowShadow(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup			=texture_clamp_lod(rainMapTexture,IN.texCoords.xy,0);
	return vec4(lookup.rgb*lookup.a,1.0);
}

#define CROSS_SECTION_STEPS 32
vec4 CrossSection(vec2 texCoords,float yz)
{
	vec3 texc	=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i		=0;
	vec3 accum	=vec3(0.0,0.0,0.0);
	texc.y		+=0.5*(1.0-yz)/float(CROSS_SECTION_STEPS);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density=texture_wwc_lod(cloudDensity,texc,0);
		vec3 colour=vec3(1.0,1.0,1.0)*(lightResponse.x+lightResponse.y);
		colour.gb+=vec2(.125,.25)*(lightResponse.z);
		colour=.85;
		if(density.x<0)
			colour.b=0;
		float opacity=saturate(0.1*abs(density.x));
		colour*=opacity;
		accum*=1.0-opacity;
		accum += colour; 
		//texc.y-=(1.0-yz)/float(CROSS_SECTION_STEPS);
		//texc.z+=yz/float(CROSS_SECTION_STEPS);
	}
    return vec4(accum,1);
}

shader vec4 PS_CrossSection(posTexVertexOutput IN):SV_TARGET
{
    return CrossSection(IN.texCoords,yz);
}

shader vec4 PS_BlendedCrossSection(posTexVertexOutput IN):SV_TARGET
{
	vec2 texCoords=IN.texCoords;
	vec3 texc	=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i		=0;
	vec3 accum	=vec3(0.0,0.5,1.0);
	texc.y		+=0.5*(1.0-yz)/float(CROSS_SECTION_STEPS);
	//texc.z+=0.5*yz/(float)CROSS_SECTION_STEPS;
	vec2 uv = vec2(0,0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density	=texture_wwc_lod(cloudDensity,texc,2);
		vec4 light		=texture_wwc_lod(cloudDensity2,texc,2);
		vec3 colour		=light.rgb;//(lightResponse.x*light.y+lightResponse.y*light.x);
		colour.gb		+=vec2(.125,.25)*(lightResponse.z*light.w);
		float opacity	=density.z;
		colour			*=opacity;
		accum			*=1.0-opacity;
		accum			+=colour;
		uv				+=density.xy;
		texc.y			-=(1.0-yz)/float(CROSS_SECTION_STEPS);
		texc.z			+=yz/float(CROSS_SECTION_STEPS);
	}
    return vec4(accum,1);
}

BlendState Blend1
{
	BlendEnable[0]	=FALSE;
	BlendEnable[1] = FALSE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=SRC_ALPHA;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=SRC_ALPHA;
    BlendOpAlpha	=ADD;
};

BlendState AddBlend2
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1] = TRUE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=ONE;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=ONE;
    BlendOpAlpha	=ADD;
};

VertexShader vs_fullscreen_5_0 = CompileShader(vs_5_0, VS_SimpleFullscreen());

fxgroup raytrace
{
	technique skylight
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceSimple()));
		}
	}
	technique skybox
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceHighDetailCubemap()));
		}
	}
	technique lightpass
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Lightpass()));
		}
	}
	technique lightpass_draw
	{
		pass p0
		{
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState(RenderNoCull);
			SetBlendState(NoBlend,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
			SetVertexShader(vs_fullscreen_5_0);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Lightpass()));
		}
	}
	technique edge_norain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Edge_NoRain()));
		}
	}
	technique edge_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Edge_Rain()));
		}
	}
	technique full_compute
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceRain()));
		}
	}
	technique no_rain_compute
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceNoRain()));
		}
	}
	technique stat_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticRain()));
		}
	}
	technique stat
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticNoRain()));
		}
	}
	technique edge_stat_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeRain()));
		}
	}
	technique edge_stat
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeNoRain()));
		}
	}
	technique cons_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticRain_cons()));
		}
	}
	technique cons
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticNoRain_cons()));
		}
	}
	technique edge_cons_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeRain_cons()));
		}
	}
	technique edge_cons
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeNoRain_cons()));
		}
	}
}

technique alt_cloud_shadow
{
	pass p0
	{
		SetDepthStencilState(DisableDepth, 0);
		SetRasterizerState(RenderNoCull);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(vs_fullscreen_5_0);
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_AltCloudShadow()));
	}
}

technique cloud_shadow
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_CloudShadow()));
    }
}

technique rain_map
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_RainMap()));
    }
}

technique mix_clouds
{
    pass init
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MixInit()));
    }
    pass main
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Mix()));
    }
}

technique mix_cirrus
{
	pass init
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MixCirrusInit()));
	}
		pass main
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MixCirrus()));
	}
}

technique map_to_window
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MapToWindow()));
    }
}
technique map_to_window_init
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MapToWindowInit()));
    }
}
technique window_lighting
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_WindowLighting()));
    }
}

technique cloud_mip
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0, CS_CloudMip()));
    }
}

technique simulate_clouds
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Simulate()));
    }
}

technique cloud_placement_volume
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( wireframeRasterizer );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_PlacementVolume()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_PlacementVolume()));
    }
}

technique blended_cloud_cs
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_BlendedCrossSection()));
    }
}

technique cross_section
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_CrossSection()));
    }
}


technique show_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowNoise()));
    }
}

technique show_3d_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Show3DNoise()));
    }
}

technique show_shadow
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowShadow()));
    }
}

technique point_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_PointQueries()));
    }
}

technique line_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_LineQueries()));
    }
}