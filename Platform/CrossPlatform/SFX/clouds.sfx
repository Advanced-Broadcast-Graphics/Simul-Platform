//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/simul_cloud_constants.sl"
#include "../SL/depth.sl"
uniform Texture3D smallWorleyTexture3D				SIMUL_TEXTURE_REGISTER(12);
#include "../SL/simul_clouds.sl"
#include "../SL/clouds_simple.sl"
#include "../SL/states.sl"
#include "../SL/earth_shadow_fade.sl"
#include "../SL/debug_constants.sl"

uniform Texture3D cloudDensity					SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D cloudDensity2					SIMUL_TEXTURE_REGISTER(1);

uniform Texture2D cloudShadowTexture			SIMUL_TEXTURE_REGISTER(2);
uniform Texture2D lossTexture					SIMUL_TEXTURE_REGISTER(3);
uniform Texture2D inscTexture					SIMUL_TEXTURE_REGISTER(1);
uniform Texture2D skylTexture					SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D depthTexture					SIMUL_TEXTURE_REGISTER(5);
uniform Texture3D noiseTexture3D				SIMUL_TEXTURE_REGISTER(6);
uniform Texture3D lightningIlluminationTexture	SIMUL_TEXTURE_REGISTER(7);
uniform Texture2D illuminationTexture			SIMUL_TEXTURE_REGISTER(8);
uniform Texture2D lightTableTexture				SIMUL_TEXTURE_REGISTER(9);
uniform Texture2D rainbowLookupTexture			SIMUL_TEXTURE_REGISTER(10);
uniform Texture2D coronaLookupTexture			SIMUL_TEXTURE_REGISTER(11);
uniform Texture3D volumeInscatterTexture		SIMUL_TEXTURE_REGISTER(1);
uniform Texture2D rainMapTexture				SIMUL_TEXTURE_REGISTER(2);
uniform RWTexture3D<uchar4> inputTexture3d;
uniform RWTexture3D<uchar4> outputTexture3d;
uniform RWStructuredBuffer<VolumeQueryResult> volumeQueries;

uniform StructuredBuffer<vec3> queryInputs;

uniform RWStructuredBuffer<LineQueryResult> lineQueryResults;

uniform RWTexture2D<vec4> outputTexture1		SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2D<vec4> outputTexture2		SIMUL_RWTEXTURE_REGISTER(1);
uniform RWTexture2D<vec4> outputTexture3		SIMUL_RWTEXTURE_REGISTER(2);

CS_LAYOUT(1,1,1)
shader void CS_PointQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	uint num=0;
	uint byteStride=0;
	//queryInputs.GetDimensions(num,byteStride);
	//if(sub_pos.x>=num)
	//	return;
	VolumeQueryResult res;
	res.pos_km						=queryInputs[sub_pos.x+firstInput];
	res.valid						=1;
	vec3 cloudWorldOffsetKm			=res.pos_km-cornerPosKm;
	vec3 cloudTexCoords				=cloudWorldOffsetKm*inverseScalesKm;
	vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
	res.density						=lookup.z;
	res.direct_light				=lookup.y;
	res.indirect_light				=lookup.x;
	res.ambient_light				=lookup.w;
	res.precipitation				=GetRainAtOffsetKm( rainMapTexture, cloudWorldOffsetKm, inverseScalesKm, res.pos_km, rainCentreKm, rainRadiusKm);
	
	volumeQueries[sub_pos.x]		=res;
}

CS_LAYOUT(1,1,1)
shader void CS_LineQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	vec3 start_pos					=queryInputs[sub_pos.x*2+firstInput];
	vec3 end_pos					=queryInputs[sub_pos.x*2+1+firstInput];
	vec3 diff						=end_pos-start_pos;
	float total_dist				=length(diff);
	if(total_dist<=0.0000001)
		return;
	LineQueryResult res;
	res.pos1_km						=start_pos;
	res.pos2_km						=end_pos;
	res.valid						=1;
	res.density						=0.0;
	res.visibility					=1.0;
	res.optical_thickness_km		=0.0;
	res.first_contact_km			=total_dist;
	vec3 dir						=diff/total_dist;
	// How far under?
	vec3 offsetKm1					=start_pos-cornerPosKm;
	float under						=max(0.0,-offsetKm1.z);
	float over						=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
	float start_dist				=max(over/max(0.0001,-dir.z),under/max(0.0001,dir.z));
	start_dist						=min(start_dist,total_dist);
	res.pos1_km						+=dir*start_dist;
	// How far over?
	//res.pos1_km						+=dir/(max(0.0001,-dir.z))*over;
	
	vec3 offsetKm2					=end_pos-cornerPosKm;
	// How far under?
	float under2					=max(0.0,-offsetKm2.z);
	float over2						=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
	float end_dist					=max(over2/max(0.0001,-dir.z),under2/max(0.0001,dir.z));
	end_dist						=min(end_dist,total_dist);
	end_dist						=max(start_dist,end_dist);
	res.pos2_km						=start_pos+dir*end_dist;
	diff							=res.pos2_km-res.pos1_km;
	total_dist						=length(diff);
	if(total_dist>0&&dot(dir,res.pos2_km-res.pos1_km)>0.0)
	{
		float stepSize						=total_dist/32.0;
		int i=0;
		for( i=0;i<33;i++)
		{
			vec3 pos						=lerp(res.pos1_km,res.pos2_km,float(i)/32.0);
			vec3 cloudTexCoords				=(pos-cornerPosKm)*inverseScalesKm;
			vec4 lookup						=sample_3d_lod(cloudDensity,cloudSamplerState,cloudTexCoords,0);
			res.density						+=lookup.z/32.0;
			if(res.density>0.0)
				res.first_contact_km		=min(res.first_contact_km,length(pos-start_pos));
			res.visibility					*=1.0-lookup.z;
			res.optical_thickness_km		+=stepSize*lookup.z;
		}
	}
	lineQueryResults[sub_pos.x]	=res;
}

#ifndef DETAIL_NOISE
	#define DETAIL_NOISE 1
#endif

CS_LAYOUT(8,8,8)
shader void CS_Mix( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=(g*8+t)*amortization+uint3(amortizationOffset);
	vec4 c1=cloudDensity[pos];
	vec4 c2=cloudDensity2[pos];
    vec4 res= lerp(c1,c2,cloud_interp);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
}


CS_LAYOUT(4,4,4)
shader void CS_Mip( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=g*8+t;
	int3 pos2=pos*2;

#ifndef __PSSL__
	vec4 c1= cloudDensity.mips[0][pos2+int3(0,0,0)];
	vec4 c2= cloudDensity.mips[0][pos2+int3(1,0,0)];
	vec4 c3= cloudDensity.mips[0][pos2+int3(0,1,0)];
	vec4 c4= cloudDensity.mips[0][pos2+int3(1,1,0)];
	vec4 c5= cloudDensity.mips[0][pos2+int3(0,0,1)];
	vec4 c6= cloudDensity.mips[0][pos2+int3(1,0,1)];
	vec4 c7= cloudDensity.mips[0][pos2+int3(0,1,1)];
	vec4 c8= cloudDensity.mips[0][pos2+int3(1,1,1)];
	vec4 res=0.125*(c1+c2+c3+c4+c5+c6+c7+c8);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
#endif
}


CS_LAYOUT(8,8,8)
shader void CS_Simulate( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=g*8+t;
	vec4 c1=TEXTURE_LOAD_3D(cloudDensity,pos);
	vec4 c2=TEXTURE_LOAD_3D(cloudDensity2,pos);
	//res.z=1.0;
	//output[pos].rgba=res;
    vec4 res= lerp(c1,c2,cloud_interp);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
	//outputTexture3d[pos].rgba=res;
}
// Given texture position from texCoords, convert to a worldpos with shadowMatrix.
// Then, trace towards sun to find initial intersection with cloud volume
// Then trace down to find first intersection with clouds, if any.
shader vec4 PS_CloudShadow( posTexVertexOutput IN):SV_TARGET
{
	return CloudShadow(cloudDensity,IN.texCoords,shadowMatrix,cornerPosKm,inverseScalesKm);
}

shader vec4 PS_RainMap(posTexVertexOutput IN) : SV_TARGET
{
	float r=MakeRainMap(cloudDensity,IN.texCoords);
	return vec4(r,r,r,r);
}

shader vec4 PS_MoistureAccumulation( posTexVertexOutput IN):SV_TARGET
{
	float m=MoistureAccumulation(cloudShadowTexture,shadowTextureSize,IN.texCoords);
	return vec4(m,m,m,m);
}

vec4 SimpleRaytrace(posTexVertexOutput IN,bool reverseDepth)
{
	vec4 dlookup 	=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias),0);
	vec2 texCoords	=mixedResTransformXYWH.xy + IN.texCoords.xy*mixedResTransformXYWH.zw;

	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	RaytracePixelOutput p	=RaytraceCloudsForward(
									cloudDensity
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture,volumeInscatterTexture
									,true
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,IN.texCoords.xy
									,false
									,true
									,cloudIrRadiance1,cloudIrRadiance2
									);
	if(p.colour.a>=1.0)
	   discard;
	p.colour.rgb*=exposure;
//p.colour.rgb=vec3(1.0,0,0);
	return p.colour;
}

shader vec4 PS_SimpleRaytrace_depthForward(posTexVertexOutput IN) : SV_TARGET
{
	return SimpleRaytrace(IN,false);
}

shader vec4 PS_SimpleRaytrace_depthReverse(posTexVertexOutput IN) : SV_TARGET
{
	return SimpleRaytrace(IN,true);
}

FarNearPixelOutput PS_Lightpass(posTexVertexOutput IN,bool reverseDepth)
{
	vec4 dlookup 			=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias),0);
	vec2 texCoords			=mixedResTransformXYWH.xy+IN.texCoords.xy*mixedResTransformXYWH.zw;
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;
	FarNearPixelOutput f	=Lightpass(
									cloudDensity
									,noiseTexture3D
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,sourcePosKm
									,sourceRadiusKm
									,spectralFluxOver1e6
									,minCosine
									,maxRadiusKm
									,irradianceThreshold
									);
	return f;
}

shader FarNearPixelOutput PS_Lightpass_DepthReverse(posTexVertexOutput IN) 
{
	return PS_Lightpass(IN,true);
}

shader FarNearPixelOutput PS_Lightpass_DepthForward(posTexVertexOutput IN) 
{
	return PS_Lightpass(IN,true);
}

struct FarNearDepthPixelOutput
{
	vec4 farColour		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 nearColour		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 nearFarDepth	SIMUL_RENDERTARGET_OUTPUT(2);
};

void CS_Raytrace(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID,bool reverseDepth,bool rain)
{
	uint2 pos				=(g.xy*8+t.xy)*amortization+amortizationOffset.xy;
	// offset by one texel to allow -1 in x and y:
	vec2 INtexCoords		=vec2(pos.xy+uint2(1,1))/vec2(targetTextureSize);
	vec4 dlookup 			=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(INtexCoords.xy,viewportToTexRegionScaleBias),0);
	// We transform from the target texCoords (0-1,0-1) passed from the vertex shader,
	//  to the texCoords of our "window". These wrap around 
	vec2 texCoords			=mixedResTransformXYWH.xy+INtexCoords.xy*mixedResTransformXYWH.zw;
	texCoords				/=mixedResTransformXYWH.zw;
	texCoords				=frac(texCoords);
	texCoords				*=mixedResTransformXYWH.zw;
	texCoords				-=vec2(1.0,1.0)/vec2(targetTextureSize)*mixedResTransformXYWH.zw;

	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;

	RaytracePixelOutput f	=RaytraceCloudsForward(
									cloudDensity
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture,volumeInscatterTexture
									,true
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,INtexCoords.xy
									,true
									,rain
									,cloudIrRadiance1,cloudIrRadiance2
									);
	outputTexture1[pos]		=f.colour;
	outputTexture2[pos]		=f.nearColour;
	outputTexture3[pos]		=f.nearFarDepth;
}

void CS_Fill(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID,bool reverseDepth,bool rain)
{
	uint2 pos				=((g.xy*8+t.xy)+amortizationOffset.xy)%targetTextureSize;
	//vec4 res				=mixedResTransformXYWH;
	//outputTexture1[pos]		=res;
	//outputTexture2[pos]		=res;
	//outputTexture3[pos]		=res;
	// offset by one texel to allow -1 in x and y:
	vec2 INtexCoords		=vec2(pos.xy+uint2(1,1))/vec2(targetTextureSize);
	vec4 dlookup 			=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(INtexCoords.xy,viewportToTexRegionScaleBias),0);
	// We transform from the target texCoords (0-1,0-1) passed from the vertex shader,
	//  to the texCoords of our "window". These wrap around 
	vec2 texCoords			=mixedResTransformXYWH.xy+INtexCoords.xy*mixedResTransformXYWH.zw;
	texCoords				/=mixedResTransformXYWH.zw;
	texCoords				=frac(texCoords);
	texCoords				*=mixedResTransformXYWH.zw;
	texCoords				-=vec2(1.0,1.0)/vec2(targetTextureSize)*mixedResTransformXYWH.zw;

	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;

	RaytracePixelOutput f	=RaytraceCloudsForward(
									cloudDensity
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture,volumeInscatterTexture
									,true
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,INtexCoords.xy
									,true
									,rain
									,cloudIrRadiance1,cloudIrRadiance2
									);
	outputTexture1[pos]		=f.colour;
	outputTexture2[pos]		=f.nearColour;
	outputTexture3[pos]		=f.nearFarDepth;
}

FarNearDepthPixelOutput PS_Raytrace(posTexVertexOutput IN,bool reverseDepth,bool rain)
{
	vec4 dlookup 			=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias),0);
	// We transform from the target texCoords (0-1,0-1) passed from the vertex shader,
	//  to the texCoords of our "window". These wrap around 
	vec2 texCoords			=mixedResTransformXYWH.xy+IN.texCoords.xy*mixedResTransformXYWH.zw;
	texCoords				/=mixedResTransformXYWH.zw;
	texCoords				=frac(texCoords);
	texCoords				*=mixedResTransformXYWH.zw;

	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;
	RaytracePixelOutput f	=RaytraceCloudsForward(
									cloudDensity
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture,volumeInscatterTexture
									,true
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,IN.texCoords.xy
									,true
									,rain
									,cloudIrRadiance1,cloudIrRadiance2
									);
	FarNearDepthPixelOutput fn;
	fn.farColour=f.colour;
	fn.nearColour=f.nearColour;
	fn.nearFarDepth = f.nearFarDepth;
	return fn;
}

FarNearDepthPixelOutput PS_RaytraceStatic(posTexVertexOutput IN,bool reverseDepth)
{
	vec4 dlookup 			=texture_nearest_lod(depthTexture,viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias),0);
	vec2 texCoords			=mixedResTransformXYWH.xy+IN.texCoords.xy*mixedResTransformXYWH.zw;
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;
	RaytracePixelOutput f	=RaytraceCloudsStatic(
									cloudDensity
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,rainbowLookupTexture
									,coronaLookupTexture
									,lossTexture
									,inscTexture
									,skylTexture,volumeInscatterTexture
									,true
									,depthInterpretationStruct
									,dlookup
									,texCoords
									,true
									,false
									,cloudIrRadiance1
									,cloudIrRadiance2
									);
	FarNearDepthPixelOutput fn;
	fn.farColour	=f.colour;
	fn.nearColour	=f.nearColour;

	fn.nearFarDepth	=f.nearFarDepth;

	return fn;
}

shader FarNearDepthPixelOutput PS_Raytrace_depthReverse(posTexVertexOutput IN)
{
	return PS_Raytrace(IN,true,true);
}

shader FarNearDepthPixelOutput PS_Raytrace_depthForward(posTexVertexOutput IN)
{
	return PS_Raytrace(IN,false,true);
}
shader FarNearDepthPixelOutput PS_RaytraceNoRain_depthReverse(posTexVertexOutput IN)
{
	return PS_Raytrace(IN,true,false);
}

shader FarNearDepthPixelOutput PS_RaytraceNoRain_depthForward(posTexVertexOutput IN)
{
	return PS_Raytrace(IN,false,false);
}

CS_LAYOUT(8,8,1)
shader void CS_Raytrace_depthReverse(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,true,true);
}

CS_LAYOUT(8,8,1)
shader void CS_Raytrace_depthForward(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,false,true);
}
CS_LAYOUT(8,8,1)
shader void CS_Fill_depthReverse(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Fill(g,t,true,true);
}

CS_LAYOUT(8,8,1)
shader void CS_Fill_depthForward(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Fill(g,t,false,true);
}

CS_LAYOUT(8,8,1)
shader void CS_RaytraceNoRain_depthReverse(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,true,false);
}

CS_LAYOUT(8,8,1)
shader void CS_RaytraceNoRain_depthForward(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,false,false);
}

shader FarNearDepthPixelOutput PS_RaytraceStatic_depthReverse(posTexVertexOutput IN)
{
	return PS_RaytraceStatic(IN,true);
}

shader FarNearDepthPixelOutput PS_RaytraceStatic_depthForward(posTexVertexOutput IN)
{
	return PS_RaytraceStatic(IN,false);
}

shader posTexVertexOutput VS_CrossSection(idOnly IN)
{
	return VS_ScreenQuad(IN,rect);
}

shader posTexVertexOutput VS_PlacementVolume(idOnly IN)
{
	posTexVertexOutput OUT;
	vec2 poss[4];
	poss[0]			=vec2(0.0, 0.0);
	poss[1]			=vec2(1.0, 0.0);
	poss[2]			=vec2(1.0, 1.0);
	poss[3]			=vec2(0.0, 1.0);
	vec3 pos	=vec3(0,0,0);
	int odd=(IN.vertex_id%2);
	if(IN.vertex_id<8)
	{
		pos.z=0.0;
		int j=((IN.vertex_id)/2+odd);
		pos.xy=poss[j%4];
	}
	else if(IN.vertex_id<16)
	{
		pos.z=1.0;
		int i=IN.vertex_id-8;
		int j=((i)/2+odd);
		pos.xy=poss[j%4];
	}
	else
	{
		int i=IN.vertex_id-16;
		int j=i/2;
		pos.z=float(i%2);
		pos.xy=poss[j%4];
	}

	OUT.hPosition	=mul(invViewProj,vec4(pos,1.0));
	OUT.texCoords	=vec2(pos.z,0);
	return OUT;
}

shader vec4 PS_PlacementVolume(posTexVertexOutput IN):SV_TARGET
{
	return vec4(1.0,1.0,IN.texCoords.x,1.0);
}

shader vec4 PS_Simple(posTexVertexOutput IN):SV_TARGET
{
    return texture_wrap(cloudShadowTexture,IN.texCoords.xy);
}

shader vec4 PS_ShowNoise(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup=texture_wrap(cloudShadowTexture,IN.texCoords.xy);
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_Show3DNoise(posTexVertexOutput IN):SV_TARGET
{
	float z			=floor(8.0f*IN.texCoords.x)/8.0f;
	//if(IN.texCoords.y<0.5)
		z=0.5;
	vec4 lookup		=texture_3d_nearest_lod(noiseTexture3D,vec3(IN.texCoords,z),0);
	//lookup=abs(lookup);
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_ShowShadow(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup			=texture_clamp_lod(cloudShadowTexture,IN.texCoords.xy,0);
	return vec4(lookup.rgb*lookup.a,1.0);
}

#define CROSS_SECTION_STEPS 32
vec4 CrossSection(vec2 texCoords,float yz)
{
	vec3 texc	=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i		=0;
	vec3 accum	=vec3(0.0,0.5,1.0);
	texc.y		+=0.5*(1.0-yz)/float(CROSS_SECTION_STEPS);
	//texc.z+=0.5*yz/(float)CROSS_SECTION_STEPS;
	vec2 uv = vec2(0,0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density=texture_wwc_lod(cloudDensity,texc,1);
		vec3 colour=vec3(.5,.5,.5)*(lightResponse.x*density.y+lightResponse.y*density.x);
		colour.gb+=vec2(.125,.25)*(lightResponse.z*density.w);
		float opacity=density.z;
		colour*=opacity;
		accum*=1.0-opacity;
		accum += colour; 
	//	accum *=1-0.1*(1.0-density.y);
		uv += density.xy;
		texc.y-=(1.0-yz)/float(CROSS_SECTION_STEPS);
		texc.z+=yz/float(CROSS_SECTION_STEPS);
	}
//	accum.rg = uv / float(CROSS_SECTION_STEPS);
    return vec4(accum,1);
}

shader vec4 PS_CrossSection(posTexVertexOutput IN):SV_TARGET
{
    return CrossSection(IN.texCoords,yz);
}

BlendState Blend1
{
	BlendEnable[0]	=FALSE;
	BlendEnable[1] = FALSE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=SRC_ALPHA;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=SRC_ALPHA;
    BlendOpAlpha	=ADD;
};

BlendState AddBlend2
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1] = TRUE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=ONE;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=ONE;
    BlendOpAlpha	=ADD;
};

VertexShader vs_fullscreen_5_0 = CompileShader(vs_5_0, VS_SimpleFullscreen());

fxgroup raytrace
{
	technique simple
	{
		pass depth_reverse
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_SimpleRaytrace_depthReverse()));
		}
		pass depth_forward 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_SimpleRaytrace_depthForward()));
		}
	}
	technique lightpass
	{
		pass depth_reverse
		{
			SetBlendState(AddBlend2,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_Lightpass_DepthReverse()));
		}
		pass depth_forward 
		{
			SetBlendState(AddBlend2,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_Lightpass_DepthForward()));
		}
	}
	technique fill
	{
		pass depth_reverse 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Fill_depthReverse()));
		}
		pass depth_forward 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Fill_depthForward()));
		}
	}
	technique full_compute
	{
		pass depth_reverse 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Raytrace_depthReverse()));
		}
		pass depth_forward 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Raytrace_depthForward()));
		}
	}
	technique no_rain_compute
	{
		pass depth_reverse 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceNoRain_depthReverse()));
		}
		pass depth_forward 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceNoRain_depthForward()));
		}
	}
	technique full
	{
		pass depth_reverse 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_Raytrace_depthReverse()));
		}
		pass depth_forward 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_Raytrace_depthForward()));
		}
	}
	technique no_rain
	{
		pass depth_reverse 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_RaytraceNoRain_depthReverse()));
		}
		pass depth_forward 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_RaytraceNoRain_depthForward()));
		}
	}
	technique stat
	{
		pass depth_reverse 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_RaytraceStatic_depthReverse()));
		}
		pass depth_forward 
		{
			SetBlendState(Blend1,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetDepthStencilState(WriteDepth,0);
			SetRasterizerState( RenderNoCull );
			SetVertexShader(vs_fullscreen_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_RaytraceStatic_depthForward()));
		}
	}
}

technique cloud_shadow
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_CloudShadow()));
    }
}


technique rain_map
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_RainMap()));
    }
}

technique mix_clouds
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Mix()));
    }
}

technique cloud_mip
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Mip()));
    }
}

technique simulate_clouds
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Simulate()));
    }
}

technique moisture_accumulation
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_MoistureAccumulation()));
    }
}

technique cloud_placement_volume
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( wireframeRasterizer );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_PlacementVolume()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_PlacementVolume()));
    }
}

technique cross_section
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_CrossSection()));
    }
}

technique simple
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Simple()));
    }
}

technique show_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowNoise()));
    }
}

technique show_3d_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Show3DNoise()));
    }
}

technique show_shadow
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowShadow()));
    }
}

technique point_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_PointQueries()));
    }
}
technique line_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_LineQueries()));
    }
}