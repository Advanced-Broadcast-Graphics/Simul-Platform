//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.

// Recommended by D Cook of MS to fix Xbox compiler crash:
#define __XBOX_DISABLE_ITERATION

#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/simul_cloud_constants.sl"
#include "../SL/depth.sl"

uniform Texture3D smallWorleyTexture3D				SIMUL_TEXTURE_REGISTER(12);

#include "../SL/simul_clouds.sl"
#include "../SL/clouds_lightpass.sl"
#include "../SL/clouds_simple.sl"
#include "../SL/clouds_raytrace.sl"
#include "../SL/states.sl"
#include "../SL/earth_shadow_fade.sl"
#include "../SL/debug_constants.sl"
#include "../SL/gpu_cloud_constants.sl"
#include "../SL/simul_gpu_clouds.sl"
#include "../SL/noise.sl"

uniform Texture3D cloudDensity				SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D cloudDensity2				SIMUL_TEXTURE_REGISTER(1);
uniform Texture3D noiseTexture3D			SIMUL_TEXTURE_REGISTER(2);
uniform Texture3D godraysTexture			SIMUL_TEXTURE_REGISTER(3);
uniform Texture3D volumeInscatterTexture	SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D skylTexture				SIMUL_TEXTURE_REGISTER(5);
uniform Texture2D inscTexture				SIMUL_TEXTURE_REGISTER(6);
uniform Texture2D lossTexture				SIMUL_TEXTURE_REGISTER(7);
uniform TextureCube depthTexture;
uniform Texture2D illuminationTexture;
uniform Texture2D lightTableTexture;
//uniform Texture2D rainbowLookupTexture;
//uniform Texture2D coronaLookupTexture;
/*
	vec4 rainbowColour;
	if(do_rainbow)
		rainbowColour		=RainbowAndCorona(rainbowLookupTexture,coronaLookupTexture,dropletRadius,
												rainbowIntensity,view,lightDirection);
#ifndef INFRARED
	if(do_rainbow)
		res.colour[num_interp-1].rgb		+=saturate(moisture)*sunlightColour1.rgb/25.0*rainbowColour.rgb;
#endif
*/ 
uniform Texture2D rainMapTexture;
/// The previous texture area:
uniform Texture2DArray updateTexture;
uniform RWTexture3D<uchar4> outputTexture3d			SIMUL_RWTEXTURE_REGISTER(0);
#ifdef SFX_TYPED_UAV_LOADS
uniform RWTexture3D<uchar4> packedOutputTexture3d	SIMUL_RWTEXTURE_REGISTER(0);
#else
uniform RWTexture3D<uint> packedOutputTexture3d		SIMUL_RWTEXTURE_REGISTER(0);
#endif
uniform RWTexture2DArray<vec4> outputTexture1		SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<vec4> outputTexture3		SIMUL_RWTEXTURE_REGISTER(2);

uniform StructuredBuffer<vec4> queryInputs SIMUL_TEXTURE_REGISTER(3);
uniform RWStructuredBuffer<VolumeQueryResult> volumeQueries SIMUL_RWTEXTURE_REGISTER(4);
uniform RWStructuredBuffer<LineQueryResult> lineQueryResults SIMUL_RWTEXTURE_REGISTER(5);

CS_LAYOUT(1,1,1)
shader void CS_PointQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	uint num=0;
	uint byteStride=0;
	//queryInputs.GetDimensions(num,byteStride);
	//if(sub_pos.x>=num)
	//	return;
	VolumeQueryResult res;
	res.pos_km						=queryInputs[sub_pos.x+firstInput];
	res.valid						=1;
	vec3 cloudWorldOffsetKm			=res.pos_km.xyz-cornerPosKm;
	vec3 cloudTexCoords				=cloudWorldOffsetKm*inverseScalesKm;
	vec4 lookup						=sample_3d_lod(cloudDensity,wwcSamplerState,cloudTexCoords,0);
	res.density						=lookup.z;
	vec4 light_lookup				=sample_3d_lod(cloudDensity2,wwcSamplerState,cloudTexCoords,0);
	res.direct_light				=light_lookup.y;
	res.indirect_light				=light_lookup.x;
	res.ambient_light				=light_lookup.w;
	res.precipitation				=GetRainAtOffsetKm( rainMapTexture, cloudWorldOffsetKm, inverseScalesKm, res.pos_km.xyz, rainCentreKm.xy, rainRadiusKm,rainEdgeKm);
	res.rain_to_snow				=GetRainToSnowAtOffsetKm(rainMapTexture, cloudWorldOffsetKm, inverseScalesKm);
	res.padding						=0.0;
	volumeQueries[sub_pos.x]		=res;
}

CS_LAYOUT(1,1,1)
shader void CS_LineQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	vec3 orig						=queryInputs[sub_pos.x*2+firstInput].xyz;
	vec3 start_pos					=orig;
	vec3 end_pos					=queryInputs[sub_pos.x*2+1+firstInput].xyz;
	vec3 diff						=end_pos-start_pos;
	float total_dist				=length(diff);
	if(total_dist<=0.0000001)
		return;
	float max_dist					=total_dist;
	LineQueryResult res;
	res.valid						=1;
	res.density						=0.0;
	res.visibility					=1.0;
	res.optical_thickness_km		=0.0;
	res.first_contact_km			=max_dist;
	res.padding2					=vec3(0, 0, 0);
	vec3 dir						=diff/total_dist;
	float dz_plus					=max(0.0001, dir.z);
	float dz_minus					=max(0.0001,-dir.z);
	float start_dist=0;
	// How far under?
	vec3 offsetKm1					=start_pos-cornerPosKm;
	float under						=max(0.0,-offsetKm1.z);
	float over						=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
	start_dist						=max(over/dz_minus,under/dz_plus);
	start_dist						=min(start_dist,total_dist);
	start_pos						+=dir*start_dist;
	
	vec3 offsetKm2					=end_pos-cornerPosKm;
	// How far under?
	float under2					=max(0.0,-offsetKm2.z);
	float over2						=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
	float end_dist					=total_dist+max(over2/dz_minus,under2/dz_plus);
	end_dist						=min(end_dist,total_dist);
	end_dist						=max(start_dist,end_dist);
	end_pos							=start_pos+dir*end_dist;
	diff							=end_pos-start_pos;
	total_dist						=length(diff);
	
	res.pos1_km						=vec4(start_pos, 1);
	res.pos2_km						=vec4(end_pos, 1);

	//if(total_dist>0&&dot(dir,res.pos2_km-res.pos1_km)>0.0)
	if(start_dist<max_dist)
	{
		float stepSize						=total_dist/32.0;
		int i=0;
		for( i=0;i<33;i++)
		{
			vec3 pos						=lerp(start_pos,end_pos,float(i)/32.0);
			vec3 cloudTexCoords				=(pos-cornerPosKm)*inverseScalesKm;
			vec4 lookup						=sample_3d_lod(cloudDensity,wwcSamplerState,cloudTexCoords,0);
			if(res.density==0.0&&lookup.z>0)
				res.first_contact_km		=min(res.first_contact_km,length(pos-orig));
			res.density						+=lookup.z/32.0;
			res.visibility					*=1.0-lookup.z;
			res.optical_thickness_km		+=stepSize*lookup.z;
		}
	}
	lineQueryResults[sub_pos.x]	=res;
}

#ifndef DETAIL_NOISE
	#define DETAIL_NOISE 1
#endif

#ifdef SFX_TYPED_UAV_LOADS
vec4 UnpackUintToVec4(vec4 a)
{
	return a;
}
vec4 PackVec4ToUint(vec4 a)
{
	return a;
}
#else

vec4 UnpackUintToVec4(uint i)
{
	vec4 o;
	o.r=((i&0x000000FFu)		)/255.0;
	o.g=((i&0x0000FF00u)>>8u	)/255.0;
	o.b=((i&0x00FF0000u)>>16u	)/255.0;
	o.a=((i&0xFF000000u)>>24u	)/255.0;
	return o;
}

uint PackVec4ToUint(vec4 i)
{
	uint o=0u;
	i=saturate(i);
	o|=(uint(i.x*255.0));
	o|=(uint(i.y*255.0)<<8u);
	o|=(uint(i.z*255.0)<<16u);
	o|=(uint(i.w*255.0)<<24u);
	//uint(i.w*255.0)|(uint(i.z*255.0)<<16u)|(uint(i.y*255.0)<<32u)|;
	return o;
}
#endif

// idx is the position relative to the grid centre texel.
// we add gridCentreTexel and mod to get the true position in the texture.
void MixInLayer(int3 p,bool clears)
{
	int3 idx	=p*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	idx.xy					+=gridCentreTexel;
	vec3 gridf				=vec3(vec2(windowGrid.xy),0);
	vec3 wind_texc			=vec3(int3((idx.xy-gridCentreTexel.xy)%windowGrid.xy - windowGrid.xy / 2,idx.z));
	vec3 texc				=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
	//texc					=texc*scale+offset;
	idx.xy					+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy					=idx.xy%int2(windowGrid.xy);
	vec4 res				=vec4(0.0,0.0,0.0,0.0);
	float zPixel1			=1.0/float(windowGrid.z);
	float layer_saturate	=saturate(texc.z / zPixel1+1.0)*saturate((1.0+zPixel1 - texc.z)/ zPixel1);
	if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
	//if(clears)
	{
		for (int i = -2; i < 3; i++)
		{
			vec3 tc		= texc;
			tc.z		+= zPixel1*i*.5;
			vec4 c1		= cloudDensity.SampleLevel(wwcSamplerState, tc, 0);
			vec4 c2		= cloudDensity2.SampleLevel(wwcSamplerState, tc, 0);

			res			+= lerp(c1, c2, cloud_interp).zyxw/5.0;
		}
	
		res.z			=saturate(2.0*layer_saturate*((res.z-0.15)/diffusivity+0.15));

		// x= edge noise, y= worley edge noise, z=density, w=sharpness.
		res.w=edgeSharpness;

		// stronger noise at the top:
		float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
		// variation:
		noise_factor	*= (0.5 + rand3(idx).x);
		res.x			=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
		res.y			=saturate(localCellNoiseStrength*noise_factor);
	}
	vec4 current=res;
	if(!clears)
	{
		current=UnpackUintToVec4(packedOutputTexture3d[idx]);
	}
	res.xyw		=lerp(current.xyw,res.xyw,layer_saturate);
	res.z		=max(res.z*max_density_gm3, current.z);

	//res.xy = saturate(-5*texc.xy);
//	res.z		=saturate(texc.y);
	IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
}

void MixInCirrus(uint3 ii,bool clears)
{
	int3 idx	=int3(ii)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	idx.xy					+=gridCentreTexel;
	vec3 gridf				=vec3(vec2(windowGrid.xy),0);
	vec3 wind_texc			=vec3(int3((idx.xy-gridCentreTexel.xy)%windowGrid.xy - windowGrid.xy / 2,idx.z));
	vec3 texc				=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	
	float fall_amount=saturate(1.0-texc.z);
	texc.xy+=cirrusWindVector.xy*pow(fall_amount,2.0);
	// fall streaks.
	vec4 res = vec4(0.0,0.0,0.0,0.0);
	for (int i = -2; i < 3; i++)
	{
		vec3 tc		=	texc;
		tc.z		+=	zPixel*i;
		vec4 c1		=	cloudDensity.SampleLevel(wrapSamplerState, tc, 0);
		vec4 c2		=	cloudDensity2.SampleLevel(wrapSamplerState, tc, 0);
		res			+=	lerp(c1, c2, cloud_interp).zyxw/5.0;
	}
	float zPixel1=1.0/float(windowGrid.z);
	res.z		=saturate((res.z-0.5)/diffusivity);
	//res.z=frac(float(idx.x)/float(windowGrid.x));
	float layer_saturate	=saturate(texc.z / zPixel1 - 0.5)*saturate((1.0 - 0.5*zPixel1 - texc.z) / zPixel1);
	res.z*=layer_saturate;//saturate(1.0-fall_amount)
	vec4 current=vec4(0,0,0,0.0);
	if(clears)
		current=vec4(res.xy,res.z*max_density_gm3,res.w);
	else
		current=UnpackUintToVec4(packedOutputTexture3d[idx]);
	{
		float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
		noise_factor *= (0.05 + rand3(idx).x);
		res.x		=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
		res.y		=localCellNoiseStrength*noise_factor;
		res.w		=0;
		
		res.xyw		=lerp(current.xyw,res.xyw,layer_saturate);
		res.z		=max(res.z*max_density_gm3,current.z);
		IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
	}
}

CS_LAYOUT(4,4,4)
shader void CS_MixInit( uint3 idx : SV_DispatchThreadID )
{
	MixInLayer(int3(idx),true);
}

CS_LAYOUT(4,4,4)
shader void CS_Mix( uint3 idx : SV_DispatchThreadID )
{
	MixInLayer(int3(idx),false);
}

CS_LAYOUT(4,4,4)
shader void CS_MixCirrusInit( uint3 idx : SV_DispatchThreadID )
{
	MixInCirrus(idx,true);
}

CS_LAYOUT(4,4,4)
shader void CS_MixCirrus( uint3 idx : SV_DispatchThreadID )
{
	MixInCirrus(idx,false);
}

void MapToWindow(uint3 p,bool clears)
{
	int3 idx	= int3(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;

	vec3 texc1		=vec3(idx)/vec3(windowGrid);
	texc1.z			+=1.0/float(windowGrid.z); //Needed to correctly offset the height of the clouds in the output 3D Texture to match with MixInLayer() - AJR
	texc1.y			=1.0-texc1.y;
	texc1.xy		-=vec2(0.5,0.5);
	texc1			=texc1*mapScale+mapOffset;
	float sine		=sin(azimuth);
	float cosine	=cos(azimuth);
	texc1.xy		=vec2(texc1.x*cosine-texc1.y*sine,texc1.y*cosine+texc1.x*sine);
	texc1.xy		+=vec2(0.5,0.5);
	// The position translates to a texture coordinate in the current cloudDensity texture:
	idx.xy			+=gridCentreTexel;
	vec3 texc		=texc1;
	texc.z			-=mapOffset.z;
	texc			*=scale/mapScale*vec3(windowGrid);//vec3(idx-int3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;//+mapOffset*scale/mapScale;
	texc.z			+=offset.z;
	idx.xy			+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy			=idx.xy%int2(windowGrid.xy);
	float zPixel1	=1.0/float(windowGrid.z);
	float layer_saturate	=saturate(texc.z / zPixel1 - 0.5)*saturate((1.0 - 0.5*zPixel1 - texc.z)/ zPixel1);
	vec4 res = vec4(0.0,0.0,0.0,0.0);
	vec4 current=vec4(0,0,0,1.0);
	if(!clears)
	{
		current=UnpackUintToVec4(packedOutputTexture3d[idx]);
	}
	if(texc1.x>0.0&&texc1.y>=0.0&&texc1.x<=1.0&&texc1.y<=1.0)
	{
		// The position translates to a texture coordinate in the current cloudDensity texture:
		for (int i = -2; i < 3; i++)
		{
			vec3 tc		= texc;
			tc.z		+= zPixel*i;
			vec4 c1		= cloudDensity.SampleLevel(wwcSamplerState, tc, 0);
			vec4 c2		= cloudDensity2.SampleLevel(wwcSamplerState, tc, 0);
			res			+= lerp(c1, c2, cloud_interp).zyxw/5.0;
		}

		vec4 map_lookup				=texture_clamp_lod(rainMapTexture,texc1.xy,0);
		
		res.z				*=map_lookup.z;
		
		res.z		=saturate((res.z-0.25)/diffusivity+0.25);
		res.z		*= 1.0/0.5*layer_saturate;

		// x= edge noise, y= worley edge noise, z=density, w=sharpness.
		res.w=edgeSharpness;
	
		// stronger noise at the top:
		float noise_factor=lerp(baseNoiseFactor,1.0,saturate(texc.z));
		// variation:
		noise_factor *=lerp(0.05,1.0,rand3(idx).x);
		res.x		=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
		res.y		=localCellNoiseStrength*noise_factor;
	}
	res.xyw		=lerp(current.xyw,res.xyw,layer_saturate);
	res.z		=max(res.z*max_density_gm3,current.z);
	IMAGE_STORE_3D(packedOutputTexture3d,idx,PackVec4ToUint(res));
}

CS_LAYOUT(4,4,4)
shader void CS_MapToWindow(uint3 idx : SV_DispatchThreadID)
{
	MapToWindow(idx,false);
}

CS_LAYOUT(4,4,4)
shader void CS_MapToWindowInit(uint3 idx : SV_DispatchThreadID)
{
	MapToWindow(idx,true);
}

float ThicknessKmInDirection(vec3 texc,vec3 inverseScalesKm,vec3 dir,float rand,float max_dist_km)
{
	float thicknessKm	=0.0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	vec3 tx				=texc;
	vec3 dir_texc		=dir*inverseScalesKm;

#if 1
	float s				=max_dist_km/80.0;	// 1.2^24 ~ 80
	int i				=0;
	for( i=0;i<12;i++)
	{
		if (i >= thicknessSteps)
			break;
		// we expect stepLength in km for this shader
		tx				+=dir_texc*s;	// we expect stepLength in km for this shader
		vec4 lookup		=texture_3d_wwc_lod(cloudDensity, vec3(tx), 0);
		float density	=lookup.z*step(tx.z,1.0);
		density			=saturate(0.3+(1.0+1.0*lookup.w*2.0)*(density-0.4));
		thicknessKm		+= density*s;
		s				*=1.44;
	}
#else
	float dist_km		=rand*max_dist_km;
	// we expect stepLength in km for this shader
	tx					+=dir_texc*dist_km;
	vec4 lookup			=texture_3d_wwc_lod(cloudDensity, vec3(tx),0);
	float density		=lookup.z*step(tx.z,1.0);
	density				=saturate(0.3+(1.0+1.0*lookup.w*2.0)*(density-0.3));
	thicknessKm			+= density*max_dist_km;
#endif
	return thicknessKm;
}

CS_LAYOUT(4,4,4)
shader void CS_WindowLighting(uint3 p : SV_DispatchThreadID)
{
	int3 idx	=int3(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	idx.xy		+=gridCentreTexel;
	vec3 texc	=vec3(idx-int3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
	idx.xy		+=int2(windowGrid.xy+windowGrid.xy/2);
	idx.xy		=idx.xy%int2(windowGrid.xy);
	vec3 texc_o	=vec3(idx)/vec3(windowGrid);

	vec3 wpos = texc / inverseScalesKm;
	float thicknessKm		=0.0;
	int i				=0;
	float stepLengthKm	=1.0/inverseScalesKm.x/float(windowGrid.x);
	float s				=0.5*stepLengthKm;
	float max_h_km		=1.0/inverseScalesKm.z;
	// We will blend with the existing value, to temporally amortize the calculation effort:
	vec4 current = vec4(0, 0, 0, 0);
	{
		current = UnpackUintToVec4(packedOutputTexture3d[idx]);
	}
	// a random number between 0 and 1.0:
	float randm=rand3(vec3(idx+uint3(stepCycle,stepCycle,stepCycle)));

	// how many km from top.
	float z_from_top_km=max_h_km*float(1+windowGrid.z-idx.z)/float(windowGrid.z);

	float extinction_distance_km=max(5.0,min(5.5*max_h_km,z_from_top_km/(abs(lightDir.z)+0.0001)));
	// this means extinction distance is the distance to the top of the clouds
	// clamped between 5km and 100km.
	thicknessKm = ThicknessKmInDirection(texc_o,inverseScalesKm,lightDir,randm,extinction_distance_km);

	// find nearest direction to light for ambient lighting:
	float nearest=10000.0;
	vec3 nearest_dir=vec3(0,0,0);
	float total=0.0;

	vec4 illum;
	float t			=saturate(thicknessKm/extinction_distance_km);
	t				=t*0.5+current.z*0.5;
	thicknessKm		=t*extinction_distance_km;
	illum.x			=max(.01,exp(-extinctionPerKm*thicknessKm/12.0));
	illum.y			=exp(-extinctionPerKm*thicknessKm);
	illum.zw        =vec2(t,1.0);

	const float v=127.0/255.0;
	illum.xyw= lerp(current.xyw,illum.xyw,v);

	IMAGE_STORE_3D(packedOutputTexture3d, idx, PackVec4ToUint(illum));
}


CS_LAYOUT(4,4,1)
shader void CS_CloudMip( uint3 p: SV_DispatchThreadID )
{
	int3 pos=int3(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if (pos.x >= exclusionRange.x&&pos.y >= exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	pos.xy		+= int2(gridCentreTexel);
	pos.xy		+= int2(windowGrid.xy + windowGrid.xy / 2);
	pos.xy		= pos.xy%int2(windowGrid.xy);
	uint3 pos2	=pos*2;
	vec3 texc = vec3(pos) / vec3(targetTextureSize.xxy);
	vec3 offset_texc = vec3(1.f, 1.f, 1.f) / vec3(targetTextureSize.xxy);
	vec4 res;
	{
		vec4 c1 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc, 0);
		vec4 c2 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3( offset_texc.x,0, 0), 0);
		vec4 c3 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(-offset_texc.x,0, 0), 0);
		vec4 c4 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, offset_texc.y, 0), 0);
		vec4 c5 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0,-offset_texc.y, 0), 0);
		vec4 c6 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, 0, offset_texc.z), 0);
		vec4 c7 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, 0,-offset_texc.z), 0);
		res = c1;// (c1 + c2 + c3 + c4 + c5 + c6 + c7) / 7.0;
		//res.z=max(max(max(max(max(max(c1.z,c2.z),c3.z),c4.z),c5.z),.5*c6.z),.5*c7.z);
	res.xyw*=0.5;
	}
	///else
	//	res = vec4(1, 0, 1, 1);
	outputTexture3d[pos]=res;
}

CS_LAYOUT(4,4,1)
shader void CS_LightMip( uint3 p: SV_DispatchThreadID )
{
	int3 pos=int3(p)*int3(amortizationScale)+int3(amortizationOffset.xyz);
	if (pos.x >= exclusionRange.x&&pos.y >= exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)
		return;
	// The position translates to a texture coordinate in the current cloudDensity texture:
	pos.xy		+= gridCentreTexel;
	pos.xy		+= int2(windowGrid.xy + windowGrid.xy / 2);
	pos.xy		= pos.xy%int2(windowGrid.xy);
	uint3 pos2	=pos*2;
	vec3 texc = vec3(pos) / vec3(targetTextureSize.xxy);
	vec3 offset_texc = vec3(1.f, 1.f, 1.f) / vec3(targetTextureSize.xxy);
	vec4 res;
	{
		vec4 c1 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc, 0);
		vec4 c2 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(offset_texc.x, 0, 0)	, 0);
		vec4 c3 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(-offset_texc.x, 0, 0), 0);
		vec4 c4 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, offset_texc.y, 0)	, 0);
		vec4 c5 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, -offset_texc.y, 0), 0);
		vec4 c6 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, 0, offset_texc.z)	, 0);
		vec4 c7 = cloudDensity.SampleLevel(wwcNearestSamplerState, texc + vec3(0, 0, -offset_texc.z), 0);
		res = (c1 + c2 + c3 + c4 + c5 + c6 + c7 ) / 7.0;
	}
	///else
	//	res = vec4(1, 0, 1, 1);
	outputTexture3d[pos]=res;
}
CS_LAYOUT(8,8,8)
shader void CS_Simulate( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 pos=g*8+t;
	vec4 c1=TEXTURE_LOAD_3D(cloudDensity,pos);
	vec4 c2=TEXTURE_LOAD_3D(cloudDensity2,pos);
	//res.z=1.0;
	//output[pos].rgba=res;
    vec4 res= lerp(c1,c2,cloud_interp);
	IMAGE_STORE_3D(outputTexture3d,pos,res);
	//outputTexture3d[pos].rgba=res;
}

//Unity cloud shadow generator
//Get new texcoords by rotating and scaling the old texcoords so texture will be projected correctly over the scene
shader vec4 PS_AltCloudShadow( posTexVertexOutput IN):SV_TARGET
{
	float tempLength = sqrt(pow(directionToSun.x, 2) + pow(directionToSun.y, 2));
	float angle = sinh(directionToSun.x / tempLength);
	float s = sin(angle);
	float c = cos(angle);
	angle = tanh(directionToSun.z / tempLength);
	float mscale = 1.0 / sin(angle);
	vec2 cameraOffset = vec2(viewPosKm.xy) / 150.0;
	vec2 cloudOffset = vec2(0.5, 0.5);
	float tempx = (IN.texCoords.x - 0.5) * 0.25;
	float tempy = (IN.texCoords.y - 0.5) * mscale * 0.25;
	float x = ((tempx * c) - (tempy * s)) + 0.5 - cloudOffset.x;
	float y = ((tempx * s) + (tempy * c)) + 0.5 - cloudOffset.y;
	vec3 adjusted_texc = vec3(x, y, sampleHeight);
#ifdef SFX_OPENGL
	adjusted_texc.y = 1.0 - adjusted_texc.y;
#endif
	vec3 shadow = saturate(3.0*sample_3d_lod(cloudDensity, wwcSamplerState, adjusted_texc, 0.0).xyz - vec3(2.0,2.0,2.0));
	return vec4(shadow.xy, 0, 1.0 - shadow.z);
}

shader vec4 PS_CloudShadow(posTexVertexOutput IN) :SV_TARGET
{
	//vec3 simple_texc = vec3((IN.texCoords.xy - vec2(0.5,0.5)) * (shadowRangeKm / 80.0), sampleHeight);
	//vec3 shadow = saturate(sample_3d_lod(cloudDensity, wwcSamplerState, simple_texc, 0).xyz);
	//return vec4(shadow.xy, 0, 1.0 - shadow.z);

	float x = 0;
	float y = 0;
	/*
	vec2 normalisedSunDir = normalize(directionToSun.xy);

	float tempLength = sqrt(pow(directionToSun.x, 2) + pow(directionToSun.y, 2));
	float angle = tempLength / directionToSun.z;
	
	float groundLength = sampleHeight * angle * (2.0 / shadowRangeKm);

	x = groundLength * normalisedSunDir.x;
	y = groundLength * normalisedSunDir.y;
	*/
	
	vec3 simple_texc = vec3((IN.texCoords.xy - vec2(0.5,0.5) + vec2(x, y)) * (shadowRangeKm / 80.0), sampleHeight);
#ifdef SFX_OPENGL
	simple_texc.y = 1.0 - simple_texc.y;
#endif
	vec3 shadow = saturate(sample_3d_lod(cloudDensity, wwcSamplerState , simple_texc, 0).xyz);
	return vec4(shadow.xy, 0, 1.0 - shadow.z);
}

shader vec4 PS_RainMap(posTexVertexOutput IN) : SV_TARGET
{
	float total_cloud=0.0;
	float max_tex_z=0.0;
	float thickness = 0.0;

	vec2 rainCentreTC[4];
	rainCentreTC[0] = rainCentreKm.xy * inverseScalesKm.xy + vec2(0, 0);
	rainCentreTC[1] = rainCentreKm.xy * inverseScalesKm.xy + vec2(0, 1);
	rainCentreTC[2] = rainCentreKm.xy * inverseScalesKm.xy + vec2(1, 0);
	rainCentreTC[3] = rainCentreKm.xy * inverseScalesKm.xy + vec2(1, 1);

	float rainRadiusTC = rainRadiusKm * inverseScalesKm.x;
	bool outOfRange = true;
	for (int i = 0; i < 4; i++)
	{
		if (length(IN.texCoords.xy - rainCentreTC[i]) < rainRadiusTC)
		{
			outOfRange = false;
			break;
		}
	}
	if (outOfRange)
		discard;
	
	// We will trace downward. The first point where enough cloud has accumulated on the way is where rain starts.
	for(int j=0;j<14;j++)
	{
		float tex_z		=float(14.0-j)/20.0;
		vec3 texc		=vec3(IN.texCoords.xy,tex_z);
		vec4 density	=sample_3d_lod(cloudDensity,wwcSamplerState,texc,0);
		total_cloud		+=0.125*density.z;
		thickness		+=1.0*density.z;		// effective cloud thickness in km.
		max_tex_z		=max(max_tex_z,step(1.0, thickness)*tex_z);
	}
	total_cloud=saturate((total_cloud-0)/0.1);
	
	return vec4(total_cloud*precipitation, max_tex_z, rainToSnow, 0);
}

struct FarNearDepthPixelOutput
{
	vec4 farColour		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 nearColour		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 nearFarDepth	SIMUL_RENDERTARGET_OUTPUT(2);
};

void SimpleRaytrace(uint3 pos,bool include_rain,bool depth,int numSteps,int num_interp,bool consistent_steps)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if (depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);
	
	RaytracePixelOutput f	=RaytraceCloudsStatic( 
									cloudDensity
									,cloudDensity2
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,lossTexture
									,inscTexture
									,skylTexture
									,volumeInscatterTexture
									,godraysTexture
									,depth
									,dlookup
									,view
									,clip_pos
									,worldspaceVolumeTexCoordsXyC
									,false		// noise? 
									,include_rain
									,false
									,cloudIrRadiance1,cloudIrRadiance2
									,numSteps
									,num_interp
									,false
									,consistent_steps);
	vec4 t2d				=vec4(0,0,0,1.0);
	// blend:

	vec4 c					=t2d;
	c.rgb					*=f.colour[num_interp-1].a;
	c.rgb					+=f.colour[num_interp-1].rgb;
	c.a						=t2d.a*f.colour[num_interp-1].a;
	outputTexture1[pos+uint3(0,0,6*(num_interp-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<num_interp-1;u++)
	{
		vec4 cn					=t2d;
		cn.rgb					*=f.colour[u].a*n;
		cn.a					=1.0-n*(1.0-t2d.a);
		cn.rgb					+=f.colour[u].rgb;
		cn.a					*=f.colour[u].a;
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
}

void StaticRaytrace(uint3 pos,bool include_rain,bool depth,bool background2d,int numSteps,int num_interp,bool do_godrays,bool consistent_steps)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if (depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);
	
	RaytracePixelOutput f	=RaytraceCloudsStatic( 
									cloudDensity
									,cloudDensity2
									,rainMapTexture
									,noiseTexture3D
									,lightTableTexture
									,illuminationTexture
									,lossTexture
									,inscTexture
									,skylTexture
									,volumeInscatterTexture
									,godraysTexture
									,depth
									,dlookup
									,view
									,clip_pos
									,worldspaceVolumeTexCoordsXyC
									,background2d		// noise? 
									,include_rain
									,false
									,cloudIrRadiance1,cloudIrRadiance2
									,numSteps
									,num_interp
									,do_godrays
									,consistent_steps);
	vec4 t2d				=vec4(0,0,0,1.0);
	// blend:

	vec4 c					=t2d;
	c.rgb					*=f.colour[num_interp-1].a;
	c.rgb					+=f.colour[num_interp-1].rgb;
	c.a						=t2d.a*f.colour[num_interp-1].a;
	outputTexture1[pos+uint3(0,0,6*(num_interp-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<num_interp-1;u++)
	{
		vec4 cn					=t2d;
		cn.rgb					*=f.colour[u].a*n;
		cn.a					=1.0-n*(1.0-t2d.a);
		cn.rgb					+=f.colour[u].rgb;
		cn.a					*=f.colour[u].a;
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
	if(background2d)
		outputTexture3[pos]		=f.nearFarDepth;
}
void Raytrace(uint3 pos,bool include_rain,bool depth,int num_interp,bool do_godrays)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec3 v	=abs(view);
	float e	=max(max(v.x,v.y),v.z);
	float ef	=max(max(view.x,view.y),view.z);
	// All D components are positive. Only the smallest is equal to e. Step(x,y) returns (y>=x). So step(D.x,e) returns (e>=D.x), which is only true if e==D.x
	vec3 N	=0.005*saturate(-view)+saturate(view);

#if 1
	vec4 dlookup			=vec4(1.0,1.0,0.000001,1.0);
	if(depth)
	{
		dlookup =depthTexture.SampleLevel(wrapSamplerState, view, 0);
	}
	vec3 worldspaceVolumeTexCoordsXyC	=vec3(atan2(view.x,view.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*asin(view.z)/SIMUL_PI_F),0);

	RaytracePixelOutput f	=RaytraceCloudsForward(cloudDensity
													,cloudDensity2
													,rainMapTexture
													,noiseTexture3D
													,lightTableTexture
													,illuminationTexture
													,lossTexture
													,inscTexture
													,skylTexture
													,volumeInscatterTexture
													,godraysTexture
													,true
													,dlookup
													,view
													,clip_pos
													,worldspaceVolumeTexCoordsXyC
													,true
													,include_rain
													,false
													,cloudIrRadiance1,cloudIrRadiance2
													,num_interp
													,do_godrays
													);
	/*RaytracePixelOutput f;
	f.colour=depthToLinFadeDistParams;
	f.nearColour=lightResponse;
	f.nearFarDepth=vec4(0,0,1,.5);*/
	// blend:
	vec4 c					=f.colour[NUM_CLOUD_INTERP-1];
	outputTexture1[pos+uint3(0,0,6*(NUM_CLOUD_INTERP-1))]		=c;
	float n					=float(dlookup.y>=1.0);
	for(int u=0;u<NUM_CLOUD_INTERP-1;u++)
	{
		vec4 cn					=f.colour[u];
		outputTexture1[pos+uint3(0,0,6*u)]		=cn;
	}
	outputTexture3[pos]		=f.nearFarDepth;
#endif
}

void Lightpass(uint3 pos,bool depth)
{
	vec2 texCoords			=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	float sineFactor		=1.0/length(clip_pos.xyz);
	vec3 view				=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
	vec4 dlookup			=vec4(1.0,1.0,1.0,1.0);
	if(depth)
		dlookup				=texture_cube_lod(depthTexture,view,0);

	vec3 lightspaceView		=normalize((mul(worldToScatteringVolumeMatrix,vec4(view,1.0))).xyz);

	float ls_angle			=asin(lightspaceView.z);
	vec3 volumeTexCoordsXyC	=vec3(atan2(lightspaceView.x,lightspaceView.y)/(2.0*SIMUL_PI_F),0.5*(1.0+2.0*ls_angle/SIMUL_PI_F),max(0.3,cos(ls_angle)));
#if 1//ndef _XBOX_ONE
	FarNearPixelOutput f	=Lightpass(cloudDensity
										,noiseTexture3D
										,dlookup
										,view
										,clip_pos
										,sourcePosKm
										,sourceRadiusKm
										,spectralFluxOver1e6
										,minCosine
										,maxRadiusKm
										,irradianceThreshold
										);
#else
	FarNearPixelOutput f;
	f.farColour=vec4(0,0,0,0);
	f.nearColour=vec4(0,0,0,0);
#endif
	outputTexture1[pos]		=f.farColour;
	outputTexture1[pos+uint3(0,0,6)]		=f.nearColour;
}

#define BLOCK_SIZE 4
void CS_Raytrace(uint3 g, uint3 t,bool include_rain,bool depth,bool godrays)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offs		= (amortizationOffset.xy );//+ (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy += offs;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	Raytrace(pos,include_rain,depth,NUM_CLOUD_INTERP,godrays);
}
#define XX (3)
#define YY (3)

void Interp(uint3 g, uint3 t,bool include_rain,bool depth,bool godrays)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offs		= (amortizationOffset.xy);// + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy += offs;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	vec4 v=updateTexture[pos];
	if(v.b==0.0)
		return;
	int xi,yi;
	// Interpolate the corners.
	for(int u=0;u<NUM_CLOUD_INTERP;u++)
	{
		vec4 c00		=outputTexture1[pos+uint3(0,0,6*u)];
		vec4 c20		=outputTexture1[pos+uint3(XX,0,6*u)];
		vec4 c02		=outputTexture1[pos+uint3(0,YY,6*u)];
		vec4 c22		=outputTexture1[pos+uint3(XX,YY,6*u)];
		//[unroll(XX)]
		for( xi=0;xi<XX;xi++)
		{
			float xf	=float(xi)/float(XX);
			//[unroll(YY)]
			for( yi=0;yi<YY;yi++)
			{
				if(xi==0&&yi==0)
					continue;
				uint3 posu				=pos+uint3(xi,yi,0);
				vec4 ui					=updateTexture[posu];
				if(ui.b==0.0)//||ui.g==1.0)
					continue;
				float yf				=float(yi)/float(YY);
				vec4 cx0				=lerp(c00,c20,xf);
				vec4 cx2				=lerp(c02,c22,xf);
				vec4 cii				=lerp(cx0,cx2,yf);
				uint3 post				=pos+uint3(xi,yi,6*u);
				float r=(post.x%XX)/float(XX);
				float g=(post.y%YY)/float(YY);
				outputTexture1[post]	=cii;//vec4(r,g,0,0);
			}
		}
	}
	//outputTexture3[pos]		=f.nearFarDepth;
}

void CS_RaytraceStatic(uint3 g, uint3 t,bool include_rain,bool depth,bool godrays,bool consistent_steps)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offs		= (amortizationOffset.xy + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy			+= offs;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	//outputTexture1[pos]		=vec4(1,1,0,1);
	//outputTexture3[pos]		=vec4(1,1,0,1);
	StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,NUM_CLOUD_INTERP,godrays,consistent_steps);
}

void CS_RaytraceStaticEdge(uint3 g, uint3 t,bool include_rain,bool depth,bool godrays,bool consistent_steps)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx,Z);
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	vec4 u=updateTexture[pos];
	if (u.g<1.0&&u.b>0.0)
	{
		//outputTexture1[pos]		=vec4(1,1,0,1);
		//outputTexture3[pos]		=vec4(1,1,0,1);
		StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,NUM_CLOUD_INTERP,godrays,consistent_steps);
	}
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Lightpass(uint3 g: SV_GroupID,uint3 t: SV_GroupThreadID)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint3 pos		=uint3(targetRange[cubemapTargetIndex].xy+idx*amortizationScale.xy,cubemapTargetIndex);
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[cubemapTargetIndex].z||pos.y>=targetRange[cubemapTargetIndex].w)
		return;
	if(updateTexture[pos].b==0.0)
		return;
	Lightpass(pos,true);
}

shader vec4 PS_Lightpass(posTexVertexOutput IN):SV_TARGET
{
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*IN.texCoords.x;
	clip_pos.y				-=2.0*IN.texCoords.y;
	vec3 view				=normalize(mul(invViewProj[cubemapTargetIndex],clip_pos).xyz);
	vec4 dlookup			=vec4(0.0,0.0,0.0,0.0);
	dlookup					=texture_cube_lod(depthTexture,view,0);

	FarNearPixelOutput f	=Lightpass(cloudDensity
										,noiseTexture3D
										,dlookup
										,view
										,clip_pos
										,sourcePosKm
										,sourceRadiusKm
										,spectralFluxOver1e6
										,minCosine
										,maxRadiusKm
										,irradianceThreshold
										);
	return vec4(f.farColour.rgb,1);
}

void Edge(uint3 g, uint3 t, bool rain, bool depth, bool godrays)
{
	uint2 idx = uint2(g.xy*BLOCK_SIZE + t.xy);
	uint Z = cubemapFaceIndex[g.z + t.z].x;
	uint3 pos = uint3(targetRange[Z].xy + idx, Z);
	if (pos.x >= targetRange[Z].z || pos.y >= targetRange[Z].w)
		return;
	vec4 u = updateTexture[pos];
	// current value is b, old value is r
	if (u.g<1.0&&u.b>0.0)
	{
		Raytrace(pos, rain, depth, NUM_CLOUD_INTERP, godrays);
	}
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Edge_NoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Edge(g, t, false, true, true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Edge_Rain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Edge(g, t, true, true, true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Interp_NoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Interp(g, t, false, true, true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Interp_Rain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	Interp(g, t, true, true, true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceSimple(uint3 g : SV_GroupID,uint3 t : SV_GroupThreadID)
{
	uint2 idx				=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z					=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos				=uint3(targetRange[t.z].xy+idx*amortizationScale.xy+amortizationOffset.xy,Z);
	
	SimpleRaytrace(pos,false,false,128,1,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceHighDetailCubemap(uint3 g : SV_GroupID,uint3 t : SV_GroupThreadID)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubemapFaceIndex[g.z+t.z].x;
	uint3 pos		=uint3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
	uint2 offset = (amortizationOffset.xy + (idx.xy + idx.yx)) % amortizationScale.xy;
	pos.xy += offset;
	if(pos.x>=edge.x||pos.y>=edge.y)
		return;
	if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)
		return;
	Raytrace(pos, false, false,NUM_CLOUD_INTERP,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_Raytrace(g,t,false,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,true,true,true,false);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,false,true,true,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,true,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticNoRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStatic(g,t,false,true,true,true);
}


CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,true,true,true,true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,true,true,true,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeNoRain(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,false,true,true,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_RaytraceStaticEdgeNoRain_cons(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	CS_RaytraceStaticEdge(g,t,false,true,true,true);
}


shader posTexVertexOutput VS_CrossSection(idOnly IN)
{
	return VS_ScreenQuad(IN,rect);
}

shader posTexVertexOutput VS_PlacementVolume(idOnly IN)
{
	posTexVertexOutput OUT;
	vec2 poss[4];
	poss[0]			=vec2(0.0, 0.0);
	poss[1]			=vec2(1.0, 0.0);
	poss[2]			=vec2(1.0, 1.0);
	poss[3]			=vec2(0.0, 1.0);
	vec3 pos		=vec3(0,0,0);
	int odd			=int(IN.vertex_id%uint(2));
	if(IN.vertex_id<8)
	{
		pos.z=0.0;
		uint j=(uint(IN.vertex_id)/2+odd);
		pos.xy=poss[j%4];
	}
	else if(IN.vertex_id<16)
	{
		pos.z=1.0;
		uint i=uint(IN.vertex_id)-8;
		uint j=(i/2+odd);
		pos.xy=poss[j%4];
	}
	else
	{
		uint i=uint(IN.vertex_id)-16;
		uint j=i/2;
		pos.z=float(i%2);
		pos.xy=poss[j%4];
	}

	OUT.hPosition	=mul(invViewProj[cubemapTargetIndex],vec4(pos,1.0));
	OUT.texCoords	=vec2(pos.z,0);
	return OUT;
}

shader vec4 PS_PlacementVolume(posTexVertexOutput IN):SV_TARGET
{
	return vec4(1.0,1.0,IN.texCoords.x,1.0);
}

shader vec4 PS_ShowNoise(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup=texture_wrap(rainMapTexture,IN.texCoords.xy);
					
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_Show3DNoise(posTexVertexOutput IN):SV_TARGET
{
	float z = 0; floor(8.0f*IN.texCoords.x) / 8.0f;
	//if(IN.texCoords.y<0.5)
		z=0.5;
	vec4 lookup		=texture_3d_nearest_lod(noiseTexture3D,vec3(IN.texCoords,z),0);
	
	//vec4 lookup = VirtualNoiseLookup(vec3(IN.texCoords, z), 4, 1, true);
	return vec4(0.5*(lookup.rgb+1.0),1.0);
}

shader vec4 PS_ShowShadow(posTexVertexOutput IN):SV_TARGET
{
    vec4 lookup			=texture_clamp_lod(rainMapTexture,IN.texCoords.xy,0);
	return vec4(lookup.rgb*lookup.a,1.0);
}

#define CROSS_SECTION_STEPS 32
vec4 CrossSection(vec2 texCoords,float yz)
{
	vec3 texc	=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
	int i		=0;
	vec3 accum	=vec3(0.0,0.0,0.0);
	texc.y		+=0.5*(1.0-yz)/float(CROSS_SECTION_STEPS);
	texc.z		+=0.5*yz/float(CROSS_SECTION_STEPS);
	vec4 x_section	=texture_wwc_lod(cloudDensity,texc,0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		vec4 density=texture_wwc_lod(cloudDensity,texc,0);
		vec3 colour=vec3(1.0,1.0,1.0)*(lightResponse.x+lightResponse.y);
		colour.gb+=vec2(.125,.25)*(lightResponse.z);
		colour=vec3(.85,.85,.85);
		if(density.x<0)
			colour.b=0;
		float opacity=saturate(0.1*abs(density.x));
		colour*=opacity;
		accum*=1.0-opacity;
		accum += colour; 
		texc.y-=(1.0-yz)/float(CROSS_SECTION_STEPS);
		texc.z+=yz/float(CROSS_SECTION_STEPS);
	}
    return vec4(x_section.xxx,1);
}

shader vec4 PS_CrossSection(posTexVertexOutput IN):SV_TARGET
{
    return CrossSection(IN.texCoords,yz);
}

shader vec4 PS_BlendedCrossSection(posTexVertexOutput IN):SV_TARGET
{
	vec2 texCoords=IN.texCoords;
	vec3 texc	=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
texc.xy		+=vec2(gridCentreTexel)/vec2(windowGrid.xy)-vec2(0.5,0.5);
	int i		=0;
	vec3 accum	=vec3(0.0,0.5,1.0);
	//texc.y		+=0.5*(1.0-yz)/float(CROSS_SECTION_STEPS);
	//texc.z+=0.5*yz/(float)CROSS_SECTION_STEPS;
	vec2 uv = vec2(0,0);
	for(i=0;i<CROSS_SECTION_STEPS;i++)
	{
		//texc.z=0.5;
		vec4 density	=texture_wwc_lod(cloudDensity,texc,0);
		vec4 light		=texture_wwc_lod(cloudDensity2,texc,0);
		vec3 colour		=light.rgb;//(lightResponse.x*light.y+lightResponse.y*light.x);
		colour.gb		+=vec2(.125,.25)*(lightResponse.z*light.w);
	//	colour.rg = saturate(1.0*density.xy);
		colour.b		+=density.w;
		float opacity	=density.z;
		colour			*=opacity;
		accum			*=1.0-opacity;
		accum			+=colour;
		uv				+=density.xy;
		texc.y			-=(1.0-yz)/float(CROSS_SECTION_STEPS);
		texc.z			+=yz/float(CROSS_SECTION_STEPS);
		//accum=density;
	}
	//accum=texture_wwc_lod(cloudDensity,vec3(texc.xy,0.5),0).rgb;
    return vec4(accum,1);
}

BlendState Blend1
{
	BlendEnable[0]	=FALSE;
	BlendEnable[1] = FALSE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=SRC_ALPHA;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=SRC_ALPHA;
    BlendOpAlpha	=ADD;
};

BlendState AddBlend2
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1] = TRUE;
	BlendEnable[2] = FALSE;
	SrcBlend		=ONE;
	DestBlend		=ONE;
    BlendOp			=ADD;
    SrcBlendAlpha	=ZERO;
    DestBlendAlpha	=ONE;
    BlendOpAlpha	=ADD;
};

VertexShader vs_fullscreen_5_0 = CompileShader(vs_5_0, VS_SimpleFullscreen());

fxgroup raytrace
{
	technique skylight
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceSimple()));
		}
	}
	technique skybox
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceHighDetailCubemap()));
		}
	}
	technique lightpass
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Lightpass()));
		}
	}
	technique lightpass_draw
	{
		pass p0
		{
			SetDepthStencilState(DisableDepth,0);
			SetRasterizerState(RenderNoCull);
			SetBlendState(NoBlend,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
			SetVertexShader(vs_fullscreen_5_0);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Lightpass()));
		}
	}
	technique edge_norain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Edge_NoRain()));
		}
	}
	technique edge_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Edge_Rain()));
		}
	}
	technique interp_norain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Interp_NoRain()));
		}
	}
	technique interp_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_Interp_Rain()));
		}
	}
	technique full_compute
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceRain()));
		}
	}
	technique no_rain_compute
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceNoRain()));
		}
	}
	technique stat_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticRain()));
		}
	}
	technique stat
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticNoRain()));
		}
	}
	technique edge_stat_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeRain()));
		}
	}
	technique edge_stat
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeNoRain()));
		}
	}
	technique cons_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticRain_cons()));
		}
	}
	technique cons
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticNoRain_cons()));
		}
	}
	technique edge_cons_rain
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeRain_cons()));
		}
	}
	technique edge_cons
	{
		pass p0 
		{
			SetComputeShader(CompileShader(cs_5_0,CS_RaytraceStaticEdgeNoRain_cons()));
		}
	}
}

technique alt_cloud_shadow
{
	pass p0
	{
		SetDepthStencilState(DisableDepth, 0);
		SetRasterizerState(RenderNoCull);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(vs_fullscreen_5_0);
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_AltCloudShadow()));
	}
}

technique cloud_shadow
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_CloudShadow()));
    }
}

technique rain_map
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(vs_fullscreen_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_RainMap()));
    }
}

technique mix_clouds
{
    pass init
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MixInit()));
    }
    pass main
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Mix()));
    }
}

technique mix_cirrus
{
	pass init
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MixCirrusInit()));
	}
		pass main
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MixCirrus()));
	}
}

technique mix_map
{
	pass init
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MapToWindowInit()));
	}
		pass main
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MapToWindow()));
    }
}

technique window_lighting
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_WindowLighting()));
    }
}

technique cloud_mip
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0, CS_CloudMip()));
    }
}

technique light_mip
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0, CS_LightMip()));
    }
}


technique simulate_clouds
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Simulate()));
    }
}

technique cloud_placement_volume
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( wireframeRasterizer );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_PlacementVolume()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_PlacementVolume()));
    }
}

technique blended_cloud_cs
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_BlendedCrossSection()));
    }
}

technique cross_section
{
    pass p0 
    {
		SetDepthStencilState(DisableDepth,0);
        SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_CrossSection()));
    }
}


technique show_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowNoise()));
    }
}

technique show_3d_noise
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_Show3DNoise()));
    }
}

technique show_shadow
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_CrossSection()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_ShowShadow()));
    }
}

technique point_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_PointQueries()));
    }
}

technique line_queries
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_LineQueries()));
    }
}