// Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/states.sl"
#include "../SL/noise.sl"
#include "../SL/noise_constants.sl"
#include "../SL/common.sl"

uniform Texture2D noise_texture SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D random_texture_3d SIMUL_TEXTURE_REGISTER(1);
uniform RWTexture3D<vec4> targetTexture32 SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture3D<char4> targetTexture8 SIMUL_RWTEXTURE_REGISTER(1);

SamplerState samplerState 
{
	Filter = MIN_MAG_MIP_LINEAR;
	AddressU = Wrap;
	AddressV = Wrap;
};

struct a2v
{
    vec4 position  : POSITION;
    vec2 texCoords  : TEXCOORD0;
};

shader vec4 RandomPS(posTexVertexOutput IN) : SV_TARGET
{
	// Range from -1 to 1.
	vec4 c=2.0*vec4(rand(IN.texCoords),rand(1.7*IN.texCoords),rand(0.11*IN.texCoords),rand(513.1*IN.texCoords))-1.0;
	//vec4 c=vec4(SphericalRandom(IN.texCoords),2.0*rand(513.1*IN.texCoords)-1.0);
    return c;
}

shader vec4 NoisePS(posTexVertexOutput IN) : SV_TARGET
{
    return Noise(noise_texture,IN.texCoords,persistence,octaves);
}

CS_LAYOUT(8,8,8)
shader void CS_Random3D(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords			=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec2 texc2				=texCoords.xy+dims.y*texCoords.z;
	// Range from -1 to 1.
	vec4 c					=vec4(SphericalRandom(texCoords),rand3(513.1*texCoords));
   // vec4 c				=2.0*vec4(rand(texc2),rand(1.7*texc2),rand(0.11*texc2),rand(513.1*texc2))-vec4(1.0,1.0,1.0,1.0);
    IMAGE_STORE_3D(targetTexture32,pos,c.xyzw);
}

CS_LAYOUT(8,8,8)
shader void CS_Random3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords			=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec2 texc2				=texCoords.xy+dims.y*texCoords.z;
	// Range from -1 to 1.
	vec4 c					=vec4(SphericalRandom(texCoords),rand3(513.1*texCoords));
   // vec4 c				=2.0*vec4(rand(texc2),rand(1.7*texc2),rand(0.11*texc2),rand(513.1*texc2))-vec4(1.0,1.0,1.0,1.0);
    IMAGE_STORE_3D(targetTexture8,pos,c.xyzw);
}

CS_LAYOUT(8,8,8)
shader void CS_Noise3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords		=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec4 result			=Noise3D(random_texture_3d,texCoords,octaves, persistence);
	IMAGE_STORE_3D(targetTexture8,pos,result);
}

CS_LAYOUT(8,8,8)
shader void CS_Noise3D_float(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 pos		=g*8+t;
	int3 dims		=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	//targetTexture32.GetDimensions(dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 texCoords	=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec4 result		=Noise3D(random_texture_3d,texCoords,octaves, persistence);//texture_wrap_lod(random_texture_3d,texCoords,0);//
	//result=vec4(1.0,0,0,0);
    IMAGE_STORE_3D(targetTexture32,pos,result);
}

CS_LAYOUT(8,8,8)
shader void CS_Worley3D_8(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 idx = g * 8 + t;
	int3 dims=int3(noise_texture_size,noise_texture_size,noise_texture_size);
	if(idx.x>=dims.x||idx.y>=dims.y||idx.z>=dims.z)
		return;
	vec3 texCoords		=(vec3(idx)+vec3(0.5,0.5,0.5))/vec3(dims);
	int grid=4;
	vec3 pos			=float(grid)*texCoords;
	vec3 fractional,intpart;
	fractional			=modf(pos,intpart);
	vec3 loc			=fractional-vec3(0.5,0.5,0.5);
/*	vec3 ctr[7]			=	{{0,0,0}
							,{1.0,0,0}
							,{-1.0,0,0}
							,{0,1.0,0}
							,{0,-1.0,0}
							,{0,0,1.0}
							,{0,0,-1.0}};*/
	float p			=0;
    for (int i = -1; i < 2; ++i)
	{
        for (int j = -1; j < 2; ++j)
		{
            for (int k = -1; k < 2; ++k)
			{
				vec3 c			=vec3(i,j,k);
				vec4 random		=texture_wrap_lod(random_texture_3d,(intpart+c)/float(grid),0);
				c				+=2.0*random.xyz;
				float r			=1.4*saturate(0.5*random.a+0.5);
				float k1		=length(loc-c);
				float d			=saturate(r-k1*k1)/r;
				p				=max(d,p);
			}
		}
	}


	vec4 result			=vec4(p,p,p,1);
	IMAGE_STORE_3D(targetTexture8,idx,result);
}


CS_LAYOUT(4,4,4)
shader void CS_MakeMips3D_float(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 p = g * 8 + t;
	int3 pos	=int3(p);
	vec4 result	=TEXTURE_LOAD_3D(random_texture_3d,pos*2);
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,1,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,0,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,1,0));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,0,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(0,1,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,0,1));
	result		+=TEXTURE_LOAD_3D(random_texture_3d,pos*2+int3(1,1,1));
	result		/=8.0;
	//result=vec4(1.0,0,0,0);
    IMAGE_STORE_3D(targetTexture32,pos,result);
}

DepthStencilState DisableDepth
{
	DepthEnable = FALSE;
	DepthWriteMask = ZERO;
};

RasterizerState RenderNoCull
{
	CullMode = none;
};

BlendState NoBlend
{
	BlendEnable[0] = FALSE;
};

technique simul_random
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		//SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,RandomPS()));
    }
}

technique simul_noise_2d
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		//SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,NoisePS()));
    }
}

technique random_3d_compute
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Random3D()));
    }
}

technique random_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Random3D_8()));
    }
}


technique noise_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Noise3D_8()));
    }
}

technique noise_3d_compute_float
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Noise3D_float()));
    }
}

technique voronoi_3d_compute_8bit
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_Worley3D_8()));
    }
}
technique make_mip_3d
{
    pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_MakeMips3D_float()));
    }
}
