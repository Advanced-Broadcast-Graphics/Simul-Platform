//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/mixed_resolution_constants.sl"
#include "../SL/depth.sl"
#include "../SL/colour_packing.sl"
#include "../SL/debug_constants.sl"

uniform TEXTURE2DMS_FLOAT4 sourceMSDepthTexture SIMUL_TEXTURE_REGISTER(0);
uniform TEXTURE2DMS_FLOAT4 sourceTextureMS SIMUL_TEXTURE_REGISTER(0);
uniform Texture2D sourceDepthTexture SIMUL_TEXTURE_REGISTER(1);

uniform Texture2DArray<vec4> previousTexture;
uniform Texture2DArray<vec4> sourceTexture1;
uniform Texture2DArray<vec4> sourceTexture2;
uniform Texture2DArray<vec4> sourceTexture3;
uniform Texture2DArray<vec4> updateTexture;
uniform RWTexture2DArray<vec4> targetTexture;
uniform RWTexture2DArray<vec4> nextUpdateTexture;

uniform RWTexture2DArray<vec4> targetTexture2;
uniform RWTexture2DArray<vec4> targetTexture3;
#define BLOCK_SIZE 8

bool GetStochasticSamples(Texture2DArray previousTexture,Texture2D sourceDepthTexture,vec2 sourceTexCoords,vec2 frustum_clip_pos, vec2 texelRange
	, DepthIntepretationStruct depthInterpretationStruct,vec2 tanHalfFov, float nearThresholdDepth
	,vec2 stochasticOffset
	,uint2 scale,bool twoStep
	,out vec4 result)
{
	// Stochastic offset goes from -1 to +1
	vec2 texCoords		=sourceTexCoords + .3*texelRange*stochasticOffset;// / vec2(scale);
	vec4 fn				=vec4(0.0,1.0,0.0,1.0);
	vec2 thr			=vec2(nearThresholdDist, nearThresholdDist);
	vec2 offsets[3];
	offsets[0]	=vec2(-0.4,0.3);
	offsets[1]	=vec2(0.4,0.3);
	offsets[2]	=vec2(0.0,-0.5);
	bool any_result=false;
	for(int i=0;i<3;i++)
	{
		//float x=(0.5+float(i)-scale.x/2.0)/float(scale.x);
		//for(int j=0;j<scale.y;j++)
		{
			//float y	=(0.5+float(j)-scale.y/2.0)/float(scale.y);
			vec2 offs	=texelRange*offsets[i];//texelRange*vec2(x,y);
			vec2 texc	=saturate(1.01*(texCoords+.6*offs))/1.01;
			texc		*=depthWindow.zw;
			texc		+=depthWindow.xy;
			// VERY important to use NEAREST, and not filter the source depth texture!
			vec2 d		=texture_nearest_lod(sourceDepthTexture,texc,0).xx;
			if(twoStep&&(d.x>=1.0||d.x<0))
				return false;
			vec2 dist	=depthToFadeDistance(d,frustum_clip_pos.xy,depthInterpretationStruct,tanHalfFov);
			if(dist.x<thr.x)
				 continue;
			float s		=saturate((dist.x)/thr.x);
			fn.yw		=min(fn.yw,vec2((1.0-s),0.0)+dist);
			fn.xz		=max(fn.xz,dist);
			any_result=true;
		}
	}
	result=saturate(fn.xyzw);
	return any_result;
}

vec4 GetFrustumClipPos(uint3 idx)
{
	vec2 texCoords			=(vec2(idx.xy)+vec2(0.5,0.5))/vec2(target_dims);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	vec3 view				=-normalize(mul(invViewProj[idx.z],clip_pos).xyz);
	// Transform view into the proper frustum
	vec4 frustum_clip_pos	=mul(viewProj,vec4(view,1.0));
	frustum_clip_pos		/=frustum_clip_pos.w;

	return frustum_clip_pos;
}

void DownscaleStochastic(uint3 idx,bool reverseDepth,bool twoStep) 
{
	if(idx.x<targetRange[idx.z].x||idx.x>=targetRange[idx.z].z||idx.y<targetRange[idx.z].y||idx.y>=targetRange[idx.z].w)
	{
		nextUpdateTexture[idx]	=vec4(0,0,0,0);
		return;
	}
	// old update
	vec4 u					=updateTexture[idx];
	vec2 texCoords			=(vec2(idx.xy)+vec2(0.5,0.5))/vec2(target_dims);
	vec4 clip_pos			=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x				+=2.0*texCoords.x;
	clip_pos.y				-=2.0*texCoords.y;
	vec3 view				=-normalize(mul(invViewProj[idx.z],clip_pos).xyz);
	// Transform view into the proper frustum
	vec4 frustum_clip_pos	=mul(viewProj,vec4(view,1.0));
	frustum_clip_pos		/=frustum_clip_pos.w;
	vec2 sourceTexCoords	=0.5*(frustum_clip_pos.xy+vec2(1.0,1.0));
	sourceTexCoords.y		=1.0-sourceTexCoords.y;
	vec4 clipRange			=frustumClipRange;//vec4(-1.0,-1.0,1.0,1.0);
	if(frustum_clip_pos.z<0.0)
	{
		nextUpdateTexture[idx]=vec4(0,0,0,0);
		return;
	}
	if(frustum_clip_pos.z<0.0||frustum_clip_pos.x<clipRange.x||frustum_clip_pos.x>clipRange.z||frustum_clip_pos.y<clipRange.y||frustum_clip_pos.y>clipRange.w)
	{
		nextUpdateTexture[idx]=vec4(0,0,0,0);
		return;
	}
	DepthIntepretationStruct ds;
	ds.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	ds.reverseDepth				=reverseDepth;
	vec4 res					=vec4(0,0,0,0);
	bool any_result	=GetStochasticSamples(
									previousTexture
									,sourceDepthTexture
									,sourceTexCoords
									,frustum_clip_pos.xy
									,texelRange
									,ds
									,tanHalfFov
									,nearThresholdDepth
									,stochasticOffset
									,scale
									,twoStep
									,res);
	if(twoStep&&!any_result)
		return;

	targetTexture[idx]		=res;
	vec4 oldAggregateDepth	=sourceTexture1[idx];
	// If the far depth (x) has radically increased, we need to fill in behind:
	float oldDepthValid		=u.b*step((res.x-oldAggregateDepth.x),0.01)*step(oldAggregateDepth.y-res.y,0.01);//+saturate(res.y-oldAggregateDepth.y));
	// This part was not previously updated. Therefore we will calculate all THREE target depth textures:
	if(u.b==0)
	{
		targetTexture2[idx]		=res;
		targetTexture3[idx]		=res;
	}
	if(twoStep)
		nextUpdateTexture[idx]	=vec4(u.b,u.a,1.0,oldDepthValid);
	else
		nextUpdateTexture[idx]	=vec4(u.b,oldDepthValid,1.0,0.0);
}

void Direct(uint3 idx,bool reverseDepth) 
{
	vec4 frustum_clip_pos			=GetFrustumClipPos(idx);
	vec2 sourceTexCoords			=0.5*(frustum_clip_pos.xy+vec2(1.0,1.0));
	sourceTexCoords.y				=1.0-sourceTexCoords.y;
	DepthIntepretationStruct dis;
	dis.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	dis.reverseDepth				=reverseDepth;
	vec4 res						=vec4(0,0,0,0);
	bool any_result					=GetStochasticSamples(previousTexture,sourceDepthTexture,sourceTexCoords,frustum_clip_pos.xy,texelRange,dis
										,tanHalfFov,  nearThresholdDepth,stochasticOffset,scale,false,res);
	vec4 lin						=depthToFadeDistance(res,frustum_clip_pos.xy,dis,tanHalfFov);
	targetTexture[idx]				=vec4(1.0,0.0000001,0.0000001,0.0000001);//lin;
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Direct_ReverseDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	Direct(pos,true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_Direct_ForwardDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	Direct(pos,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_DownscaleStochastic_ReverseDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
		
	//nextUpdateTexture[pos]	=vec4(0,0,1,0);
	DownscaleStochastic(pos,true,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_DownscaleStochastic_ForwardDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	DownscaleStochastic(pos,false,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_DownscaleStochastic_ReverseDepth_TwoStep(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
		
	//nextUpdateTexture[pos]	=vec4(0,0,1,0);
	DownscaleStochastic(pos,true,true);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_DownscaleStochastic_ForwardDepth_TwoStep(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	DownscaleStochastic(pos,false,true);
}

void MinMax(uint3 idx,bool reverseDepth)
{
	vec2 texCoords			=vec2(idx.xy)/vec2(target_dims);
	vec4 frustum_clip_pos	=GetFrustumClipPos(idx);

	vec2 sourceTexCoords	=0.5*(frustum_clip_pos.xy+vec2(1.0,1.0));
	sourceTexCoords.y		=1.0-sourceTexCoords.y;
	vec4 clipRange			=frustumClipRange;

	if (updateTexture[idx].b == 0.0)
		return;
	vec2 thr	=vec2(nearThresholdDist, nearThresholdDist);
	vec4 fn1	=sourceTexture1[idx];
	vec4 fn2	=sourceTexture2[idx];
	vec4 fn3	=sourceTexture3[idx];
	vec4 fn		=vec4(0.0,1.0,0.0,1.0);
	fn.yw		=min(fn.yw,fn1.yw);
	fn.xz		=max(fn.xz,fn1.xz);
	if(updateTexture[idx].r>=1.0)
	{
		fn.yw	=min(fn.yw,fn2.yw);
		fn.xz	=max(fn.xz,fn2.xz);
		fn.yw	=min(fn.yw,fn3.yw);
		fn.xz	=max(fn.xz,fn3.xz);
	}
	fn.z		=nearThresholdDist;
	targetTexture[idx]	=saturate(fn);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_MinMax_ForwardDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID) 
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	if (pos.x<targetRange[Z].x || pos.x>=targetRange[Z].z || pos.y<targetRange[Z].y || pos.y>=targetRange[Z].w)
	{
		return;
	}
	MinMax(pos,false);
}

CS_LAYOUT(BLOCK_SIZE,BLOCK_SIZE,1)
shader void CS_MinMax_ReverseDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint2 idx		=uint2(g.xy*BLOCK_SIZE+t.xy);
	uint Z			=cubeIndex[g.z+t.z].x;
	uint3 pos		=uint3(drawRange[Z].xy+idx,Z);
	if (pos.x<targetRange[Z].x || pos.x>=targetRange[Z].z || pos.y<targetRange[Z].y || pos.y>=targetRange[Z].w)
	{
		return;
	}
	MinMax(pos,true);
}
technique direct
{
    pass reverse_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Direct_ReverseDepth()));
    }
    pass forward_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Direct_ForwardDepth()));
    }
}

technique downscale_stochastic_compute
{
    pass reverse_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_DownscaleStochastic_ReverseDepth()));
    }
    pass forward_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_DownscaleStochastic_ForwardDepth()));
    }
}

technique downscale_stochastic_compute_two_step
{
    pass reverse_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_DownscaleStochastic_ReverseDepth_TwoStep()));
    }
    pass forward_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_DownscaleStochastic_ForwardDepth_TwoStep()));
    }
}
technique minmax
{
    pass reverse_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MinMax_ReverseDepth()));
    }
    pass forward_depth
    {
		SetComputeShader(CompileShader(cs_5_0,CS_MinMax_ForwardDepth()));
    }
}
