//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/depth.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/cloud_shadow.sl"
#include "../SL/atmospherics.sl"
#include "../SL/atmospherics_constants.sl"
#include "../SL/earth_shadow_uniforms.sl"
#include "../SL/colour_packing.sl"
#include "../SL/illumination.sl"

uniform Texture2D depthTexture;
uniform Texture2DMS<vec4> depthTextureMS;
uniform Texture2D cloudDepthTexture;
uniform Texture2D imageTexture;
uniform Texture2D lossTexture;
uniform Texture2D inscTexture;
uniform Texture2D overcTexture;
uniform Texture2D skylTexture;
uniform Texture2D illuminationTexture;
uniform Texture2D cloudShadowTexture;
uniform Texture2D cloudNearFarTexture;
uniform Texture2D cloudGodraysTexture;

uniform Texture3D cloudTexture;
SamplerState cloudSamplerState;
uniform Texture2D moistureTexture;

uniform RWTexture3D<vec4> targetVolume;

#include "../SL/cloud_shadow.sl"
#include "../SL/godrays.sl"

#define pi (3.1415926536)

struct atmosVertexInput
{
	uint vertex_id			: SV_VertexID;
};

struct atmosVertexOutput
{
    vec4 position		: SV_POSITION;
    vec2 texCoords		: TEXCOORD0;
    vec2 pos			: TEXCOORD1;
};

shader atmosVertexOutput VS_Atmos(atmosVertexInput IN)
{
	atmosVertexOutput OUT;
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	OUT.pos			=poss[IN.vertex_id];
	OUT.position	=vec4(OUT.pos,0.0,1.0);
	// Set to far plane so can use depth test as want this geometry effectively at infinity

	OUT.position.z	=0.0; 

    OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(OUT.pos.x,-OUT.pos.y));
	return OUT;
}

vec4 PS_NearFarShadow(atmosVertexOutput IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 texCoords		=mixedResolutionTransformXYWH.xy/mixedResolutionTransformXYWH.zw+IN.texCoords.xy;
	texCoords			-=0.5*(vec2(1.0,1.0)/mixedResolutionTransformXYWH.zw-vec2(1.0,1.0));
	texCoords			=frac(texCoords);
	texCoords			*=mixedResolutionTransformXYWH.zw;
	texCoords			+=0.5*(vec2(1.0,1.0)-mixedResolutionTransformXYWH.zw);
	vec4 clip_pos		=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x			+=2.0*texCoords.x;
	clip_pos.y			-=2.0*texCoords.y;
	vec3 wOffset		=mul(invViewProj,clip_pos).xyz;
	vec3 view			=normalize(wOffset);
	vec2 depth_texc		=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	vec4 depth			=texture_wrap_lod(depthTexture,IN.texCoords.xy,0);

	vec2 dist			=depthToFadeDistance(depth.zw,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
	vec3 texc			=mul(invShadowMatrix,vec4(viewPosition+dist.x*view*maxFadeDistanceMetres,1.0)).xyz;
	vec4 texel			=texture_wrap_lod(cloudShadowTexture,texc.xy,0);
	float shadow1		=GetSimpleIlluminationAt(cloudShadowTexture,invShadowMatrix,viewPosition+dist.x*view*maxFadeDistanceMetres).x;
	float shadow2		=GetSimpleIlluminationAt(cloudShadowTexture,invShadowMatrix,viewPosition+dist.y*view*maxFadeDistanceMetres).x;
	//float sine		=view.z;
	//float texy		=0.5*(1.f-sine);
	//vec2 texx			=pow(dist,vec2(0.5,0.5));
	//now shadow1 and shadow2 are from 0 (shadowed) to 1 (light).
	vec2 sharp_mul		=vec2(1.0,1.0);//+500.0*cloudShadowSharpness*(vec2(1.0,1.0)-texx);
	vec2 shadow			=vec2(shadow1,shadow2);
	shadow				=saturate(vec2(0.5,0.5)*(1.0+sharp_mul)-sharp_mul*shadow);
	float at_inf		=0.0;
	if(depthInterpretationStruct.reverseDepth)
		at_inf			=step(0.0,-depth.w);
	else
		at_inf			=step(1.0,depth.w);
	shadow				*=cloudShadowing*(1.0-at_inf);
	shadow				=saturate(vec2(1.0,1.0)-shadow);
	return vec4(shadow1,shadow1,shadow1,1);
}

shader vec4 PS_NearFarShadow_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_NearFarShadow(IN,true);
}

shader vec4 PS_NearFarShadow_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_NearFarShadow(IN,false);
}

vec4 PS_Loss(atmosVertexOutput IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	//vec2 depth_texc	=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	vec3 loss		=AtmosphericsLoss(depthTexture
									,viewportToTexRegionScaleBias
									,lossTexture
									,invViewProj
									,IN.texCoords
									,IN.pos
									,depthInterpretationStruct
									,tanHalfFov);
    return vec4(loss.rgb,1.0);
}

shader vec4 PS_Loss_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_Loss(IN,true);
}

shader vec4 PS_Loss_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_Loss(IN,false);
}


vec4 PS_Inscatter(atmosVertexOutput IN,bool reverseDepth) 
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec4 insc		=Inscatter(	 inscTexture
								,skylTexture
								,depthTexture
								,illuminationTexture
								,invViewProj
								,IN.texCoords
								,lightDir
								,hazeEccentricity
								,mieRayleighRatio
								,viewportToTexRegionScaleBias
								,depthInterpretationStruct
								,tanHalfFov);
    vec4 res=vec4(insc.rgb*exposure,1.0);
	return res;
}

shader vec4 PS_Inscatter_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	vec4 res= PS_Inscatter(IN,true);
	return res;
}

shader vec4 PS_Inscatter_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	vec4 res= PS_Inscatter(IN,false);
	return res;
}


All8Output psLossVolume(atmosVertexOutput IN)
{
	vec2 texCoords		=mixedResolutionTransformXYWH.xy+IN.texCoords.xy*mixedResolutionTransformXYWH.zw;
	vec4 colours[8];
	Loss_All( colours
				,lossTexture
				,cloudTexture
				,cloudSamplerState
				,viewPosition
				,invShadowMatrix
				,texCoords
				,invViewProj
				,lightDir
				,maxFadeDistanceMetres);
	
	All8Output all8Output;
	all8Output.colour1	=colours[0];
	all8Output.colour2	=colours[1];
	all8Output.colour3	=colours[2];
	all8Output.colour4	=colours[3];
	all8Output.colour5	=colours[4];
	all8Output.colour6	=colours[5];
	all8Output.colour7	=colours[6];
	all8Output.colour8	=colours[7];
	return all8Output;
}


shader All8Output PS_LossVolume(atmosVertexOutput IN)
{
	return psLossVolume(IN);
}


// With this function we will create a 3D volume texture that encompasses the scattering for a frame,
// where the x-axis is azimuth around the light source, y-axis is angle from the light source (maximum = 180 deg)
// and z-axis is distance from the viewer.

CS_LAYOUT(8,8,1)
shader void CS_ScatteringVolume(uint3 p: SV_DispatchThreadID)
{
	uint3 idx			=p*amortization+amortizationOffset;
	if(p.x>=edge.x||p.y>=edge.y)
		return;
	// We must convert the idx values into a direction and distance in real space.
	vec2 texc			=vec2(float(idx.x)/float(scatteringVolumeDims.x),float(idx.y)/float((scatteringVolumeDims.y-1)));
	float azimuth		=texc.x*2.0*PI;
	float elevation		=(1.0-texc.y)*PI;
	float se			=sin(elevation);
	float ce			=cos(elevation);
	float x				=sin(azimuth)*se;
	float y				=cos(azimuth)*se;
	vec3 view			=mul(lightspaceToWorldMatrix,vec4(x,y,ce,1.0)).xyz;//x*xAxis+y*yAxis+lightDir*ce;

	float sine			=view.z;
	float cosine		=max(0.001,sqrt(1.0-sine*sine));
	float fade_texc_y	=0.5*(1.0-sine);
	// Illumination texture is worldspace:
	float world_azimuth	=atan2(view.x,view.y);
	vec2 illum_texc		=vec2(world_azimuth/(2.0*PI),(1.0+sine)*0.5);
	vec4 colour			=vec4(0,0,0,0);
	vec4 last			=vec4(0,0,0,0);
	float godraysIntensity=1.0;
	vec3 lightDirCloudspace	=normalize(mul(worldToCloudMatrix,vec4(lightDir,0.0)).xyz);
	vec3 viewCloudspace		=mul(worldToCloudMatrix,vec4(view,0.0)).xyz*1000.0;
	vec3 viewposCloudspace	=mul(worldToCloudMatrix,vec4(viewPosition,1.0)).xyz;

	vec3 viewPosKm			=vec3(0.0,0.0,viewPosition.z/1000.0);
	float maxFadeDistanceKm	=maxFadeDistanceMetres*0.001;
	
	for(int i=0;i<scatteringVolumeDims.z;i++)
	{
		float dist_texc	=float(i)/float(scatteringVolumeDims.z-1);
		float dist		=pow(dist_texc,2.0)/cosine;
		vec2 fade_texc	=vec2(pow(dist,0.5f),fade_texc_y);
		vec4 insc		=texture_clamp_mirror_lod(inscTexture,fade_texc,0);
		vec3 skyl		=texture_clamp_mirror_lod(skylTexture,fade_texc,0).rgb;

	#ifdef INFRARED
		vec4 next		=vec4(skyl.rgb,1.0);
		float shadow	=1.0;
		colour			+=max(vec4(0,0,0,0),(next-last));
	#else
		float illum=0;
		vec3 earth_shadow_illum=vec3(0,0,0);


#define INTER_STEPS 10
		if(godraysIntensity>0.0)
		{
			for(int j=0;j<INTER_STEPS;j++)
			{
				float inter				=float(j+0.5)/float(INTER_STEPS)/float(scatteringVolumeDims.z-1);
				float distanceKm		=maxFadeDistanceKm*pow(dist_texc+inter,2.0);
				vec3 pos_km				=viewPosKm+view*distanceKm;
				vec3 texc				=viewposCloudspace+distanceKm*viewCloudspace;
				illum					+=GetCloudIllum(cloudTexture, cloudSamplerState, texc, lightDirCloudspace) / float(INTER_STEPS);
			}
		}
		earth_shadow_illum	=IlluminationAtPosition(viewPosKm+view*dist*maxFadeDistanceKm,sunDir,planetRadiusKm,vec3(45.0,35.0,25.0));
		float il			=1.0-godraysIntensity*(1.0-illum);
		float cos0			=ce;
		vec4 next			=vec4(InscatterFunction(insc,hazeEccentricity,cos0,mieRayleighRatio),1.0);
		vec4 dc				=max(vec4(0,0,0,0),(next-last))*il;
		dc.rgb				*=earth_shadow_illum;
		colour				+=dc;
#endif
		vec4 res			=colour+vec4(skyl,0);
		int3 pos			=int3(idx.xy,i);
		//res.rgb			=frac(vec3(pos)/256.0);
		IMAGE_STORE_3D(targetVolume,pos,res);
		last				=next;
	}
}
VertexShader vs_atmos=CompileShader(vs_5_0,VS_Atmos());

technique near_far_shadow
{
    pass reverse_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(vs_atmos);
		SetPixelShader(CompileShader(ps_5_0,PS_NearFarShadow_ReverseDepth()));
    }
    pass forward_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(vs_atmos);
		SetPixelShader(CompileShader(ps_5_0,PS_NearFarShadow_ForwardDepth()));
    }
}

BlendState DontBlend8
{
	BlendEnable[0] = FALSE;
	BlendEnable[1]	=FALSE;
	BlendEnable[2] = FALSE;
	BlendEnable[3]	=FALSE;
	BlendEnable[4] = FALSE;
	BlendEnable[5]	=FALSE;
	BlendEnable[6] = FALSE;
	BlendEnable[7]	=FALSE;
};

group loss_volume
{
	technique unshadowed
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_LossVolume()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0, PS_LossVolume()));
		}
    }
	technique shadowed
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0, PS_LossVolume()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0, PS_LossVolume()));
		}
    }
}

fxgroup atmospherics_overlay
{
	technique loss
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(MultiplyBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Loss_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(MultiplyBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Loss_ForwardDepth()));
		}
	}
	technique inscatter
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_ForwardDepth()));
		}
	}
}

technique scattering_volume
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_ScatteringVolume()));
    }
}