#include "shader_platform.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/depth.sl"
#include "../../CrossPlatform/SL/simul_inscatter_fns.sl"
#include "../../CrossPlatform/SL/cloud_shadow.sl"
#include "../../CrossPlatform/SL/atmospherics.sl"
#include "../../CrossPlatform/SL/atmospherics_constants.sl"
#include "../../CrossPlatform/SL/colour_packing.sl"

uniform Texture2D depthTexture;
uniform TEXTURE2DMS_FLOAT4 depthTextureMS;
uniform Texture2D cloudDepthTexture;
uniform Texture2D imageTexture;
uniform Texture2D lossTexture;
uniform Texture2D inscTexture;
uniform Texture2D overcTexture;
uniform Texture2D skylTexture;
uniform Texture2D illuminationTexture;
uniform Texture2D cloudShadowTexture;
uniform Texture2D cloudNearFarTexture;
uniform Texture2D cloudGodraysTexture;

uniform Texture3D cloudTexture;
SamplerState cloudSamplerState;
uniform Texture2D moistureTexture;

uniform RWTexture3D<vec4> targetVolume;

#include "../../CrossPlatform/SL/cloud_shadow.sl"
#include "../../CrossPlatform/SL/godrays.sl"

#define pi (3.1415926536)

struct atmosVertexInput
{
	uint vertex_id			: SV_VertexID;
};

struct atmosVertexOutput
{
    vec4 position			: SV_POSITION;
    vec2 texCoords		: TEXCOORD0;
    vec2 pos				: TEXCOORD1;
};

shader atmosVertexOutput VS_Atmos(atmosVertexInput IN)
{
	atmosVertexOutput OUT;
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	OUT.pos			=poss[IN.vertex_id];
	OUT.position	=vec4(OUT.pos,0.0,1.0);
	// Set to far plane so can use depth test as want this geometry effectively at infinity

	OUT.position.z	=0.0; 

    OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(OUT.pos.x,-OUT.pos.y));
	OUT.texCoords	+=0.5*texelOffsets;
	return OUT;
}

vec4 PS_NearFarShadow(atmosVertexOutput IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 depth_texc	=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	vec2 nf=NearFarShadow(depthTexture,cloudShadowTexture
						,viewportToTexRegionScaleBias
						,lossTexture
						,invViewProj
						,IN.texCoords
						,IN.pos
						,depthInterpretationStruct
						,maxFadeDistanceMetres
						,tanHalfFov
						,invShadowMatrix,viewPosition,cloudShadowing,cloudShadowSharpness);

    return vec4(nf,0,0);
}

shader vec4 PS_NearFarShadow_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_NearFarShadow(IN,true);
}

shader vec4 PS_NearFarShadow_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_NearFarShadow(IN,false);
}

vec4 PS_Loss(atmosVertexOutput IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 depth_texc	=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	vec3 loss		=AtmosphericsLoss(depthTexture
									,viewportToTexRegionScaleBias
									,lossTexture
									,invViewProj
									,IN.texCoords
									,IN.pos
									,depthInterpretationStruct
									,tanHalfFov);
    return vec4(loss.rgb,1.0);
}

shader vec4 PS_Loss_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_Loss(IN,true);
}

shader vec4 PS_Loss_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	return PS_Loss(IN,false);
}

shader vec4 PS_LossMSAA(atmosVertexOutput IN,uint sampleIndex : SV_SampleIndex,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 depth_texc	=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	int2 pos2;
	uint numSamples;
	GetMSAACoordinates(depthTextureMS,depth_texc,pos2,numSamples);
	vec3 loss		=AtmosphericsLossMSAA(depthTextureMS
											,sampleIndex
											,viewportToTexRegionScaleBias
											,lossTexture
											,invViewProj
											,IN.texCoords
											,pos2
											,IN.pos
											,depthInterpretationStruct
											,tanHalfFov);
    return vec4(loss.rgb,1.0);
}

shader vec4 PS_LossMSAA_ReverseDepth(atmosVertexOutput IN,uint sampleIndex:SV_SampleIndex) : SV_TARGET
{
	return PS_LossMSAA(IN,sampleIndex,true);
}

shader vec4 PS_LossMSAA_ForwardDepth(atmosVertexOutput IN,uint sampleIndex:SV_SampleIndex) : SV_TARGET
{
	return PS_LossMSAA(IN,sampleIndex,false);
}

vec4 PS_Inscatter(atmosVertexOutput IN,bool reverseDepth) 
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	int numSamples	=1;
	vec4 insc		=Inscatter(	 inscTexture
								,skylTexture
								,depthTexture
								,numSamples
								,illuminationTexture
								,invViewProj
								,IN.texCoords
								,lightDir
								,hazeEccentricity
								,mieRayleighRatio
								,viewportToTexRegionScaleBias
								,depthInterpretationStruct
								,tanHalfFov
								,true
								,false);
    vec4 res=vec4(insc.rgb*exposure,1.0);
	return res;
}

shader vec4 PS_Inscatter_ReverseDepth(atmosVertexOutput IN) : SV_TARGET
{
	vec4 res= PS_Inscatter(IN,true);
	return res;
}

shader vec4 PS_Inscatter_ForwardDepth(atmosVertexOutput IN) : SV_TARGET
{
	vec4 res= PS_Inscatter(IN,false);
	return res;
}

vec4 PS_InscatterMSAA(atmosVertexOutput IN,uint sampleIndex,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	uint2 dims;
	uint numSamples;
	GET_DIMENSIONS_MSAA(depthTextureMS,dims.x,dims.y,numSamples);
	int2 pos2=int2(IN.texCoords*vec2(dims.xy));
	vec4 res=InscatterMSAA(	inscTexture
							,skylTexture
							,illuminationTexture
							,depthTextureMS
							,int(numSamples)
							,IN.texCoords
							,pos2
							,invViewProj
							,lightDir
							,hazeEccentricity
							,mieRayleighRatio
							,viewportToTexRegionScaleBias
							,depthInterpretationStruct
							,tanHalfFov
							,false
							,false);
	res.rgb	*=exposure;
	return res;
}

shader vec4 PS_InscatterMSAA_ReverseDepth(atmosVertexOutput IN,uint sampleIndex:SV_SampleIndex) : SV_TARGET
{
	return PS_InscatterMSAA(IN,sampleIndex,true);
}

shader vec4 PS_InscatterMSAA_ForwardDepth(atmosVertexOutput IN,uint sampleIndex:SV_SampleIndex) : SV_TARGET
{
	return PS_InscatterMSAA(IN,sampleIndex,false);
}

All8Output psInscatter_Volume(atmosVertexOutput IN,float godrays,bool reverseDepth)
{
	vec4 depth_lookup	=vec4(0.0,1.0,1.0,0.0);
	vec2 texCoords		=mixedResolutionTransformXYWH.xy+IN.texCoords.xy*mixedResolutionTransformXYWH.zw;
	vec4 colours[8];
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	Inscatter_All( colours
					,inscTexture
					,skylTexture
					,illuminationTexture
					,cloudShadowTexture
					,cloudTexture
					,cloudSamplerState
					,viewPosition
					,invShadowMatrix
					,depth_lookup
					,texCoords
					,invViewProj
					,lightDir
					,hazeEccentricity
					,mieRayleighRatio
					,depthInterpretationStruct
					,maxFadeDistanceMetres
					,godrays);
	
	All8Output all8Output;
	all8Output.colour1	=colours[0]*exposure;
	all8Output.colour2	=colours[1]*exposure;
	all8Output.colour3	=colours[2]*exposure;
	all8Output.colour4	=colours[3]*exposure;
	all8Output.colour5	=colours[4]*exposure;
	all8Output.colour6	=colours[5]*exposure;
	all8Output.colour7	=colours[6]*exposure;
	all8Output.colour8	=colours[7]*exposure;
	return all8Output;
}

shader All8Output PS_Inscatter_Volume_WithGodrays_reverseDepth(atmosVertexOutput IN)
{
	return psInscatter_Volume(IN,godraysIntensity,true);
}

shader All8Output PS_Inscatter_Volume_WithoutGodrays_reverseDepth(atmosVertexOutput IN)
{
	return psInscatter_Volume(IN,0.0,true);
}

shader All8Output PS_Inscatter_Volume_WithGodrays_forwardDepth(atmosVertexOutput IN)
{
	return psInscatter_Volume(IN,godraysIntensity,false);
}

shader All8Output PS_Inscatter_Volume_WithoutGodrays_forwardDepth(atmosVertexOutput IN)
{
	return psInscatter_Volume(IN,0.0,false);
}

All8Output psLossVolume(atmosVertexOutput IN,bool shadowed,bool reverseDepth)
{
	vec4 depth_lookup	=vec4(0.0,1.0,1.0,0.0);
	vec2 texCoords		=mixedResolutionTransformXYWH.xy+IN.texCoords.xy*mixedResolutionTransformXYWH.zw;
	vec4 colours[8];
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	Loss_All( colours
				,lossTexture
				,depthTexture
				,cloudTexture
				,cloudSamplerState
				,viewPosition
				,invShadowMatrix
				,depth_lookup
				,texCoords
				,invViewProj
				,lightDir
				,hazeEccentricity
				,mieRayleighRatio
				,depthInterpretationStruct,tanHalfFov
				,viewportToTexRegionScaleBias
				,maxFadeDistanceMetres
				,shadowed,cloudShadowing,cloudShadowSharpness);
	
	All8Output all8Output;
	all8Output.colour1	=colours[0];
	all8Output.colour2	=colours[1];
	all8Output.colour3	=colours[2];
	all8Output.colour4	=colours[3];
	all8Output.colour5	=colours[4];
	all8Output.colour6	=colours[5];
	all8Output.colour7	=colours[6];
	all8Output.colour8	=colours[7];
	return all8Output;
}


shader All8Output PS_LossVolumeShadowed_reverseDepth(atmosVertexOutput IN)
{
	return psLossVolume(IN,true,true);
}

shader All8Output PS_LossVolumeUnshadowed_reverseDepth(atmosVertexOutput IN)
{
	return psLossVolume(IN,false,true);
}


shader All8Output PS_LossVolumeShadowed_forwardDepth(atmosVertexOutput IN)
{
	return psLossVolume(IN,true,false);
}

shader All8Output PS_LossVolumeUnshadowed_forwardDepth(atmosVertexOutput IN)
{
	return psLossVolume(IN,false,false);
}

// With this function we will create a 3D volume texture that encompasses the scattering for a frame,
// where the x-axis is azimuth around the light source, y-axis is angle from the light source (maximum = 180 deg)
// and z-axis is distance from the viewer.

CS_LAYOUT(8,8,1)
shader void CS_ScatteringVolume(uint3 idx: SV_DispatchThreadID)
{
	/*ScatteringVolume(targetVolume,	int3(idx)
									,inscTexture
									,skylTexture
									,illuminationTexture
									,cloudShadowTexture,invShadowMatrix,cloudTexture,worldToCloudMatrix,viewPosition
									,xAxis
									,yAxis
									,lightDir
									,scatteringVolumeDims
									,hazeEccentricity
									,mieRayleighRatio
									,maxFadeDistanceMetres);*/
	// We must convert the idx values into a direction and distance in real space.
	float azimuth		=float(idx.x)/float(scatteringVolumeDims.x*2.0)*PI;
	float elevation		=float(idx.y)/float((scatteringVolumeDims.y-1))*PI;
	float se			=sin(elevation);
	float ce			=cos(elevation);
	float x				=sin(azimuth)*se;
	float y				=cos(azimuth)*se;
	vec3 dir			=x*xAxis+y*yAxis+lightDir*ce;

	float sine			=dir.z;
	float fade_texc_y	=0.5*(1.0-sine);
	vec2 illum_texc		=vec2(atan2(dir.x,dir.y)/(PI*2.0),fade_texc_y);
	vec4 colour			=vec4(0,0,0,0);
	vec4 last			=vec4(0,0,0,0);
	for(int i=0;i<scatteringVolumeDims.z;i++)
	{
		float dist			=pow(float(i)/float(scatteringVolumeDims.z-1),2.0);
		vec4 insc;
		vec3 skyl;
		CalcInsc(	inscTexture
					,skylTexture
					,illuminationTexture
					,dist
					,fade_texc_y
					,illum_texc
					,insc
					,skyl);

	#ifdef INFRARED
		vec4 next		=vec4(skyl.rgb,1.0);
		float shadow	=1.0;
	#else
		float shadow	=GetCloudIlluminationAt(cloudTexture,worldToCloudMatrix,viewPosition+dist*dir*maxFadeDistanceMetres,lightDir).x;//worldspaceToShadowspaceMatrix
		float cos0		=ce;
		vec4 next	    =vec4(InscatterFunction(insc,hazeEccentricity,cos0,mieRayleighRatio),1.0);
		next.rgb		+=skyl.rgb;
	#endif
		colour			+=max(vec4(0,0,0,0),(next-last))*shadow;
		IMAGE_STORE_3D(targetVolume,int3(idx.xy,i),colour);
		last			=next;
	}
}
VertexShader vs_atmos=CompileShader(vs_5_0,VS_Atmos());

technique near_far_shadow
{
    pass reverse_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(vs_atmos);
		SetPixelShader(CompileShader(ps_5_0,PS_NearFarShadow_ReverseDepth()));
    }
    pass forward_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(vs_atmos);
		SetPixelShader(CompileShader(ps_5_0,PS_NearFarShadow_ForwardDepth()));
    }
}

BlendState DontBlend8
{
	BlendEnable[0] = FALSE;
	BlendEnable[1]	=FALSE;
	BlendEnable[2] = FALSE;
	BlendEnable[3]	=FALSE;
	BlendEnable[4] = FALSE;
	BlendEnable[5]	=FALSE;
	BlendEnable[6] = FALSE;
	BlendEnable[7]	=FALSE;
};

group inscatter_volume
{
	technique with_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_Volume_WithGodrays_reverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_Volume_WithGodrays_forwardDepth()));
		}
	}
	technique without_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_Volume_WithoutGodrays_reverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_Volume_WithoutGodrays_forwardDepth()));
		}
	}
}

group loss_volume
{
	technique unshadowed
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_LossVolumeUnshadowed_reverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_LossVolumeUnshadowed_forwardDepth()));
		}
    }
	technique shadowed
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_LossVolumeShadowed_reverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(DontBlend8, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetVertexShader(vs_atmos);
			SetGeometryShader(NULL);
			SetPixelShader(CompileShader(ps_5_0,PS_LossVolumeShadowed_forwardDepth()));
		}
    }
}

fxgroup atmospherics_overlay
{
	technique loss
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(MultiplyBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Loss_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(MultiplyBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Loss_ForwardDepth()));
		}
	}
	technique inscatter
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(vs_atmos);
			SetPixelShader(CompileShader(ps_5_0,PS_Inscatter_ForwardDepth()));
		}
	}
}

technique scattering_volume
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_ScatteringVolume()));
    }
}