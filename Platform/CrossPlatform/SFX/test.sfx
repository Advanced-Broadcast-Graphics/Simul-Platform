//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.

// Recommended by D Cook of MS to fix Xbox compiler crash:
#define __XBOX_DISABLE_ITERATION

#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/simul_cloud_constants.sl"
#include "../SL/depth.sl"

uniform Texture3D smallWorleyTexture3D				SIMUL_TEXTURE_REGISTER(12);

#include "../SL/simul_clouds.sl"
#include "../SL/clouds_lightpass.sl"
#include "../SL/clouds_simple.sl"
#include "../SL/clouds_raytrace.sl"
#include "../SL/states.sl"
#include "../SL/earth_shadow_fade.sl"
#include "../SL/debug_constants.sl"
#include "../SL/gpu_cloud_constants.sl"
#include "../SL/simul_gpu_clouds.sl"
#include "../SL/noise.sl"

uniform Texture3D cloudDensity				SIMUL_TEXTURE_REGISTER(0);
uniform Texture3D cloudDensity2				SIMUL_TEXTURE_REGISTER(1);
uniform Texture3D noiseTexture3D			SIMUL_TEXTURE_REGISTER(2);
uniform Texture3D godraysTexture			SIMUL_TEXTURE_REGISTER(3);
uniform Texture3D volumeInscatterTexture	SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D skylTexture				SIMUL_TEXTURE_REGISTER(3);
uniform Texture2D inscTexture				SIMUL_TEXTURE_REGISTER(4);
uniform Texture2D lossTexture				SIMUL_TEXTURE_REGISTER(5);
uniform TextureCube depthTexture;
uniform Texture2D illuminationTexture;
uniform Texture2D lightTableTexture;
uniform Texture2D rainbowLookupTexture;
uniform Texture2D coronaLookupTexture;
uniform Texture2D rainMapTexture;
/// The previous texture area:
uniform Texture2DArray updateTexture;
uniform RWTexture3D<uchar4> outputTexture3d			SIMUL_RWTEXTURE_REGISTER(0);
#ifdef SFX_TYPED_UAV_LOADS
uniform RWTexture3D<uchar4> packedOutputTexture3d	SIMUL_RWTEXTURE_REGISTER(0);
#else
uniform RWTexture3D<uint> packedOutputTexture3d		SIMUL_RWTEXTURE_REGISTER(0);
#endif
uniform RWTexture2DArray<vec4> outputTexture1		SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture2DArray<vec4> outputTexture3		SIMUL_RWTEXTURE_REGISTER(2);

uniform RWStructuredBuffer<VolumeQueryResult> volumeQueries SIMUL_RWTEXTURE_REGISTER(4);

uniform StructuredBuffer<vec3> queryInputs SIMUL_TEXTURE_REGISTER(3);

uniform RWStructuredBuffer<LineQueryResult> lineQueryResults SIMUL_RWTEXTURE_REGISTER(5);

CS_LAYOUT(1,1,1)
shader void CS_PointQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	uint num=0;
	uint byteStride=0;
	//queryInputs.GetDimensions(num,byteStride);
	//if(sub_pos.x>=num)
	//	return;
	VolumeQueryResult res;
	res.pos_km						=queryInputs[sub_pos.x+firstInput];
	res.valid						=1;
	vec3 cloudWorldOffsetKm			=res.pos_km-cornerPosKm;
	vec3 cloudTexCoords				=cloudWorldOffsetKm*inverseScalesKm;
	vec4 lookup						=sample_3d_lod(cloudDensity,wwcSamplerState,cloudTexCoords,0);
	res.density						=lookup.z;
	vec4 light_lookup				=sample_3d_lod(cloudDensity2,wwcSamplerState,cloudTexCoords,0);
	res.direct_light				=light_lookup.y;
	res.indirect_light				=light_lookup.x;
	res.ambient_light				=light_lookup.w;
	res.precipitation				=GetRainAtOffsetKm( rainMapTexture, cloudWorldOffsetKm, inverseScalesKm, res.pos_km, rainCentreKm.xy, rainRadiusKm,rainEdgeKm);
	res.rain_to_snow				=0.0;
	res.padding						=vec2(0,0);
	volumeQueries[sub_pos.x]		=res;
}

CS_LAYOUT(1,1,1)
shader void CS_LineQueries(uint3 sub_pos: SV_DispatchThreadID )
{
	vec3 orig						=queryInputs[sub_pos.x*2+firstInput];
	vec3 start_pos					=orig;
	vec3 end_pos					=queryInputs[sub_pos.x*2+1+firstInput];
	vec3 diff						=end_pos-start_pos;
	float total_dist				=length(diff);
	if(total_dist<=0.0000001)
		return;
	float max_dist					=total_dist;
	LineQueryResult res;
	res.valid						=1;
	res.density						=0.0;
	res.visibility					=1.0;
	res.optical_thickness_km		=0.0;
	res.first_contact_km			=max_dist;
	vec3 dir						=diff/total_dist;
	float dz_plus					=max(0.0001, dir.z);
	float dz_minus					=max(0.0001,-dir.z);
	float start_dist=0;
	// How far under?
	vec3 offsetKm1					=start_pos-cornerPosKm;
	float under						=max(0.0,-offsetKm1.z);
	float over						=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
	start_dist						=max(over/dz_minus,under/dz_plus);
	start_dist						=min(start_dist,total_dist);
	start_pos						+=dir*start_dist;
	
	vec3 offsetKm2					=end_pos-cornerPosKm;
	// How far under?
	float under2					=max(0.0,-offsetKm2.z);
	float over2						=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
	float end_dist					=total_dist+max(over2/dz_minus,under2/dz_plus);
	end_dist						=min(end_dist,total_dist);
	end_dist						=max(start_dist,end_dist);
	end_pos							=start_pos+dir*end_dist;
	diff							=end_pos-start_pos;
	total_dist						=length(diff);
	
	res.pos1_km						=start_pos;
	res.pos2_km						=end_pos;

	//if(total_dist>0&&dot(dir,res.pos2_km-res.pos1_km)>0.0)
	if(start_dist<max_dist)
	{
		float stepSize						=total_dist/32.0;
		int i=0;
		for( i=0;i<33;i++)
		{
			vec3 pos						=lerp(start_pos,end_pos,float(i)/32.0);
			vec3 cloudTexCoords				=(pos-cornerPosKm)*inverseScalesKm;
			vec4 lookup						=sample_3d_lod(cloudDensity,wwcSamplerState,cloudTexCoords,0);
			if(res.density==0.0&&lookup.z>0)
				res.first_contact_km		=min(res.first_contact_km,length(pos-orig));
			res.density						+=lookup.z/32.0;
			res.visibility					*=1.0-lookup.z;
			res.optical_thickness_km		+=stepSize*lookup.z;
		}
	}
	lineQueryResults[sub_pos.x]	=res;
}

technique point_queries
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0,CS_PointQueries()));
	}
}

technique line_queries
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0,CS_LineQueries()));
		}
	}