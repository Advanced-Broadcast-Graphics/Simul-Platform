//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/mixed_resolution_constants.sl"
#include "../SL/depth.sl"
#include "../SL/colour_packing.sl"
#include "../SL/debug_constants.sl"

uniform TEXTURE2DMS_FLOAT4 sourceMSDepthTexture SIMUL_TEXTURE_REGISTER(0);
uniform Texture2D sourceDepthTexture SIMUL_TEXTURE_REGISTER(1);

uniform Texture2DArray<vec4> previousCombinedTexture;
uniform Texture2DArray<vec4> sourceTexture1;
uniform Texture2DArray<vec4> sourceTexture2;
uniform Texture2DArray<vec4> sourceTexture3;
uniform Texture2DArray<uchar4> updateTexture;
uniform RWTexture2DArray<vec4> targetTexture;
uniform RWTexture2DArray<uchar4> nextUpdateTexture;

uniform RWTexture2DArray<vec4> targetTexture2;
uniform RWTexture2DArray<vec4> targetTexture3;
#define BLOCK_SIZE 8


bool GetStochasticSamples(Texture2D sourceDepthTexture,vec4 depthWind,vec2 sourceTexCoords,vec2 frustum_clip_pos, vec2 texelRange
	, DepthInterpretationStruct depthInterpretationStruct,vec4 tanHalfFov, float nearThresholdDepth
	,vec2 stochasticOffset
	,uint2 scale,int j
	,out vec4 result)
{
	// Stochastic offset goes from -1 to +1
	vec2 texCoords		=sourceTexCoords + .3*texelRange*stochasticOffset;// / vec2(scale);
	vec4 fn				=vec4(0.0,1.0,0.0,1.0);
	vec2 thr			=vec2(nearThresholdDist, nearThresholdDist);
	vec2 offsets[3];
	offsets[0]	=vec2(-0.4,0.3);
	offsets[1]	=vec2(0.4,0.3);
	offsets[2]	=vec2(0.0,-0.5);
	bool any_result=false;
	for(int i=0;i<3;i++)
	{
		//float x=(0.5+float(i)-scale.x/2.0)/float(scale.x);
		//for(int j=0;j<scale.y;j++)
		{
			//float y	=(0.5+float(j)-scale.y/2.0)/float(scale.y);
			vec2 offs	=texelRange*offsets[i];//texelRange*vec2(x,y);
			vec2 texc	=saturate(1.01*(texCoords+.6*offs))/1.01;
			texc		*= depthWind.zw;
			texc		+= depthWind.xy;
			// VERY important to use NEAREST, and not filter the source depth texture!
			vec2 d		=texture_nearest_lod(sourceDepthTexture,texc,0).xx;
			if(depthInterpretationStruct.reverseDepth)
			{
				if(d.x>=1.0)
					continue;
			}
			else
			{
				if(d.x<=0.0)
					continue;
			}
			vec2 dist	=depthToFadeDistance(d,frustum_clip_pos.xy,depthInterpretationStruct,tanHalfFov);
			if(dist.x<thr.x)
				 continue;
			float s		=saturate((dist.x)/thr.x);
			fn.yw		=min(fn.yw,vec2((1.0-s),0.0)+dist);
			fn.xz		=max(fn.xz,dist);
			any_result=true;
		}
	}
	result=saturate(fn.xyzw);
	return any_result;
}

// This function should track the above, but use MSAA Load instead of Sample
bool GetStochasticSamples_MSAA(Texture2DMS<float4> sourceDepthTextureMS,vec4 depthWind,vec2 sourceTexCoords,vec2 frustum_clip_pos, vec2 texelRange
	, DepthInterpretationStruct depthInterpretationStruct,vec4 tanHalfFov, float nearThresholdDepth
	,vec2 stochasticOffset
	,uint2 scale,int j
	,out vec4 result)
{
	// Stochastic offset goes from -1 to +1
	vec2 texCoords		=sourceTexCoords + .3*texelRange*stochasticOffset;// / vec2(scale);
	vec4 fn				=vec4(0.0,1.0,0.0,1.0);
	vec2 thr			=vec2(nearThresholdDist, nearThresholdDist);
	vec2 offsets[3];
	offsets[0]	=vec2(-0.4,0.3);
	offsets[1]	=vec2(0.4,0.3);
	offsets[2]	=vec2(0.0,-0.5);
	bool any_result=false;
	for(int i=0;i<3;i++)
	{
		{
			vec2 offs	=texelRange*offsets[i];
			vec2 texc	=saturate(1.01*(texCoords+.6*offs))/1.01;
			texc		*=vec2(depthWind.zw);
			texc		+=vec2(depthWind.xy);
			uint2 tex_pos=uint2(texc*source_dims+vec2(0.5,0.5));
			//fn=vec4(texc,0,0);
			// VERY important to use NEAREST, and not filter the source depth texture!
			vec2 d		=sourceDepthTextureMS.Load(tex_pos,0).xx;
			if(depthInterpretationStruct.reverseDepth)
			{
				if(d.x>=1.0)
					continue;
			}
			else
			{
				if(d.x<=0.0)
					continue;
			}
			vec2 dist	=depthToFadeDistance(d,frustum_clip_pos.xy,depthInterpretationStruct,tanHalfFov);
			if(dist.x<thr.x)
				 continue;
			float s		=saturate((dist.x)/thr.x);
			fn.yw		=min(fn.yw,vec2((1.0-s),0.0)+dist);
			fn.xz		=max(fn.xz,dist);
			any_result=true;
		}
	}
	if(!any_result)
		fn=vec4(1.0,1.0,1.0,1.0);
	result=saturate(fn.xyzw);
	return any_result;
}


bool GetStochasticSamples_twoEyes(Texture2D sourceDepthTexture
	, vec2 sourceTexCoords[2]
	, vec4 frustum_clip_pos[2]
	, vec2 texelRange
	, DepthInterpretationStruct depthInterpretationStruct, vec4 tanHalfFov, float nearThresholdDepth
	, vec2 stochasticOffset
	, uint2 scale
	, out vec4 result)
{
	// Stochastic offset goes from -1 to +1
	vec2 texCoords[2];
	texCoords[0] = sourceTexCoords[0] + .3*texelRange*stochasticOffset;
	texCoords[1] = sourceTexCoords[1] + .3*texelRange*stochasticOffset;
	vec4 fn = vec4(0.0, 1.0, 0.0, 1.0);
	vec2 thr = vec2(nearThresholdDist, nearThresholdDist);
	vec2 offsets[3];
	offsets[0] = vec2(-0.4, 0.3);
	offsets[1] = vec2(0.4, 0.3);
	offsets[2] = vec2(0.0, -0.5);
	bool any_result = false;
	for (int i = 0; i<3; i++)
	{
		vec2 offs = texelRange*offsets[i];
		for (int j = 0; j<2; j++)
		{
			vec2 texc = saturate(1.01*(texCoords[j] + .6*offs)) / 1.01;
			texc *= depthWindow[j].zw;
			texc += depthWindow[j].xy;
			// VERY important to use NEAREST, and not filter the source depth texture!
			vec2 d = texture_nearest_lod(sourceDepthTexture, texc, 0).xx;
			if(depthInterpretationStruct.reverseDepth)
			{
				if(d.x>=1.0)
					continue;
			}
			else
			{
				if(d.x<=0.0)
					continue;
			}
			vec2 dist = depthToFadeDistance(d, frustum_clip_pos[j].xy, depthInterpretationStruct, tanHalfFov);
			float s = saturate((dist.x) / thr.x);
			fn.yw = min(fn.yw, vec2((1.0 - s), 0.0) + dist);
			fn.xz = max(fn.xz, dist);
			any_result = true;
		}
	}
	result = saturate(fn.xyzw);
	return any_result;
}

void DownscaleStochastic_twoEyes(uint3 idx,bool depth,bool reverseDepth,bool msaa) 
{
	if(idx.x<targetRange[idx.z].x||idx.x>=targetRange[idx.z].z||idx.y<targetRange[idx.z].y||idx.y>=targetRange[idx.z].w)
	{
		nextUpdateTexture[idx]	=vec4(0,0,0,0);
		return;
	}
	// old update
	vec4 u							=updateTexture[idx];
	vec2 texCoords					=(vec2(idx.xy)+vec2(0.5,0.5))/vec2(target_dims);
	vec4 clip_pos					=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x						+=2.0*texCoords.x;
	clip_pos.y						-=2.0*texCoords.y;
	vec3 view						=-normalize(mul(invViewProj[idx.z],clip_pos).xyz);
	// Transform view into the proper frustum
	vec4 frustum_clip_pos[2];
	vec2 sourceTexCoords[2];
	frustum_clip_pos [0]			= mul(viewProj, vec4(view, 1.0));
	frustum_clip_pos[0]				/=frustum_clip_pos[0].w;
	sourceTexCoords[0]				= 0.5*(frustum_clip_pos[0].xy + vec2(1.0, 1.0));
	sourceTexCoords[0].y			=1.0-sourceTexCoords[0].y;

	frustum_clip_pos[1]				=mul(viewProj_alternateEye,vec4(view,1.0));
	frustum_clip_pos[1]				/= frustum_clip_pos[1].w;
	sourceTexCoords [1]				=0.5*(frustum_clip_pos[1].xy+vec2(1.0,1.0));
	
	sourceTexCoords[1].y			=1.0- sourceTexCoords[1].y;
	vec4 clipRange					=frustumClipRange;//vec4(-1.0,-1.0,1.0,1.0);

	bool invalid0 = frustum_clip_pos[0].z < 0.0 || frustum_clip_pos[0].x<clipRange.x || frustum_clip_pos[0].x>clipRange.z || frustum_clip_pos[0].y<clipRange.y || frustum_clip_pos[0].y>clipRange.w;
	bool invalid1 = frustum_clip_pos[1].z < 0.0 || frustum_clip_pos[1].x<clipRange.x || frustum_clip_pos[1].x>clipRange.z || frustum_clip_pos[1].y<clipRange.y || frustum_clip_pos[1].y>clipRange.w;

	if (invalid0&&invalid1)
	{
		nextUpdateTexture[idx] = vec4(0, 0, 0, 0);
		return;
	}
	float oldDepthValid = u.b;
	if (depth)
	{
		DepthInterpretationStruct ds;
		ds.depthToLinFadeDistParams		= depthToLinFadeDistParams;
		ds.reverseDepth					= reverseDepth;
		vec4 res						= vec4(0, 0, 0, 0);
		bool any_result					= false;
		if (!invalid0 && !invalid1)
		{
			if(msaa)
				any_result	=GetStochasticSamples_twoEyes_MSAA(sourceMSDepthTexture
																, sourceTexCoords
																, frustum_clip_pos
																, texelRange
																, ds
																, tanHalfFov
																, nearThresholdDepth
																, stochasticOffset
																, scale
																, res);
			else
				any_result = GetStochasticSamples_twoEyes(sourceDepthTexture
														, sourceTexCoords
														, frustum_clip_pos
														, texelRange
														, ds
														, tanHalfFov
														, nearThresholdDepth
														, stochasticOffset
														, scale
														, res);
	}
	else
	{
		vec2 sourct ;
		vec4 frustum_clip;
		vec4 depthw;
		int j=0;
		if (!invalid1)
		{
			j=1;
		}
		sourct = sourceTexCoords[j];
		frustum_clip = frustum_clip_pos[j];
		depthw = depthWindow[j];
		any_result = GetStochasticSamples(
			 sourceDepthTexture
			, depthw
			, sourct
			, frustum_clip.xy
			, texelRange
			, ds
			, tanHalfFov
			, nearThresholdDepth
			, stochasticOffset
				, scale,  j, res);
		}
		if(!any_result)
		{
			nextUpdateTexture[idx]=vec4(0,0,0,0);
			return;
		}
		targetTexture[idx]		=res;
		vec4 oldAggregateDepth	=sourceTexture1[idx];
		// If the far depth (x) has radically increased, we need to fill in behind:
			oldDepthValid		=u.b*step((res.x-oldAggregateDepth.x),0.01)*step(oldAggregateDepth.y-res.y,0.01);//+saturate(res.y-oldAggregateDepth.y));
		// This part was not previously updated. Therefore we will calculate all THREE target depth textures:
		if(u.b==0)
		{
			targetTexture2[idx]		=res;
			targetTexture3[idx]		=res;
		}
	}
	nextUpdateTexture[idx] = vec4(u.b, oldDepthValid, 1.0, 0.0);
}

CS_LAYOUT(BLOCK_SIZE, BLOCK_SIZE, 1)
shader void CS_DownscaleStochastic_twoEyes_ForwardDepth(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint2 idx = uint2(g.xy*BLOCK_SIZE + t.xy);
	uint Z = cubeIndex[g.z + t.z].x;
	uint3 pos = uint3(drawRange[Z].xy + idx, Z);
	DownscaleStochastic_twoEyes(pos, true,false,  false);
}


technique downscale_stochastic_two_eyes
{
		pass forward_depth
	{
		SetComputeShader(CompileShader(cs_5_0,CS_DownscaleStochastic_twoEyes_ForwardDepth()));
	}
}
