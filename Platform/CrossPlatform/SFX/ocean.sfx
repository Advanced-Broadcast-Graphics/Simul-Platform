//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/states.sl"
#include "../SL/ocean_constants.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/debug_constants.sl"
#include "../SL/depth.sl"
#include "../SL/noise.sl"

#define PATCH_BLEND_BEGIN		2000
#define PATCH_BLEND_END			4000

#define PI 3.1415926536f
#define BLOCK_SIZE_X 16
#define BLOCK_SIZE_Y 16

uniform Texture2D	g_samplerDisplacementMap	SIMUL_TEXTURE_REGISTER(0);

uniform Texture2D	showTexture					SIMUL_TEXTURE_REGISTER(0);

uniform Texture2D	g_texDisplacement			SIMUL_TEXTURE_REGISTER(0);		// FFT wave displacement map in VS
uniform Texture2D	g_texGradient				SIMUL_TEXTURE_REGISTER(1);		// FFT wave gradient map in PS
uniform Texture2D	g_texColour					SIMUL_TEXTURE_REGISTER(2);		// Colour of the render target, used for refraction
uniform Texture2D	g_texDepth					SIMUL_TEXTURE_REGISTER(3);		// Depth of rendered scene up till now
uniform Texture2D	g_waterRefractColour		SIMUL_TEXTURE_REGISTER(4);		// Colour of the refracted underwater surface
uniform Texture2D	g_foamTexture				SIMUL_TEXTURE_REGISTER(5);		// Foam colour
uniform Texture2D	g_foamAlpha					SIMUL_TEXTURE_REGISTER(6);		// Foam Alpha
uniform Texture2D	g_surfaceFoamTexture		SIMUL_TEXTURE_REGISTER(7);		// Foam Surface colour
uniform Texture2D	g_shoreDepthTexture			SIMUL_TEXTURE_REGISTER(8);		// Shore depth for shallow water effects
uniform Texture2D	g_texDetailMapDisplacement	SIMUL_TEXTURE_REGISTER(9);	// Detail map displacement

uniform Texture2D	g_waterDepth				SIMUL_TEXTURE_REGISTER(0);		// Depth of the water
uniform Texture2D	g_waterAbsorption			SIMUL_TEXTURE_REGISTER(1);		// Absorption of the water, 4th value Salinity
uniform Texture2D	g_waterScattering			SIMUL_TEXTURE_REGISTER(2);		// Scattering of the water, 4th value Foam Colour
uniform Texture2D	g_waterNormals				SIMUL_TEXTURE_REGISTER(3);		// Normals of the water held in seperate texture to allow for multiple instances
uniform TextureCube	g_texReflectCube			: register(t5);					// A skybox cube texture for reflection

// The following three should contains only real numbers. But we have only C2C FFT now.
uniform StructuredBuffer<vec2>		g_InputDxyz;
uniform RWStructuredBuffer<vec2>	g_InputH0	: register(u5);
uniform RWStructuredBuffer<vec2>	g_OutputHt;
uniform RWStructuredBuffer<float>	g_InputOmega: register(u6);
uniform RWStructuredBuffer<vec3>	g_ProbePos:	register(u7);
uniform RWStructuredBuffer<vec4>	g_ProbeOutputs;

struct TwoColourCompositeOutput
{
	vec4 add		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 multiply	SIMUL_RENDERTARGET_OUTPUT(1);
};

// FFT wave displacement map in VS, XY for choppy field, Z for height field
//SamplerState g_samplerDisplacement	now use nearestWrap

// Perlin noise for composing distant waves, W for height field, XY for gradient
SamplerState g_samplerPerlin SIMUL_STATE_REGISTER(3)
{
	Filter =ANISOTROPIC;
	AddressU =WRAP;
	AddressV =WRAP;
	AddressW =WRAP;
	MipLODBias = 0;
	//ComparisonFunc = NEVER;
	MinLOD = 0;
	MaxLOD = 1000000;
	MaxAnisotropy = 16;
};

// FFT wave gradient map, converted to normal value in PS
SamplerState g_samplerGradient SIMUL_STATE_REGISTER(6)
{
	Filter =ANISOTROPIC;
	AddressU =WRAP;
	AddressV =WRAP;
	AddressW =WRAP;
	MipLODBias = 0;
	MaxAnisotropy = 16;
};

SamplerState bbbSamplerState SIMUL_STATE_REGISTER(8)
{
	Filter = ANISOTROPIC;
	AddressU = BORDER;
	AddressV = BORDER;
	AddressW = BORDER;
};

#define COS_PI_4_16 0.70710678118654752440084436210485f
#define TWIDDLE_1_8 COS_PI_4_16, -COS_PI_4_16
#define TWIDDLE_3_8 -COS_PI_4_16, -COS_PI_4_16

#define COHERENCY_GRANULARITY 128

#define RAND_MAX 0x7fff

float fresnel(vec3 incident, vec3 normal, float sourceIndex, float mediumIndex)
{
	float fresnel;
	float cos_incident = clamp(-1.0, 1.0, dot(incident, normal));

	float sint = (sourceIndex / mediumIndex) * sqrt(max(0.0, 1 - (cos_incident * cos_incident)));
	if (sint >= 1.0)
	{
		fresnel = 0.0;
	}
	else
	{
		float cost = sqrt(max(0.0, 1 - sint * sint));
		cos_incident = abs(cos_incident);
		float Rs = ((mediumIndex * cos_incident) - (sourceIndex * cost)) / ((mediumIndex * cos_incident) + (sourceIndex * cost));
		float Rp = ((sourceIndex * cos_incident) - (mediumIndex * cost)) / ((sourceIndex * cos_incident) + (mediumIndex * cost));
		fresnel = ((Rs * Rs + Rp * Rp) / 2.0);
	}

	return fresnel;

}

void FT2(inout float2 a, inout float2 b)
{
	float t;

	t = a.x;
	a.x += b.x;
	b.x = t - b.x;

	t = a.y;
	a.y += b.y;
	b.y = t - b.y;
}

void CMUL_forward(inout float2 a, float bx, float by)
{
	float t = a.x;
	a.x = t * bx - a.y * by;
	a.y = t * by + a.y * bx;
}

void UPD_forward(inout float2 a, inout float2 b)
{
	float A = a.x;
	float B = b.y;

	a.x += b.y;
	b.y = a.y + b.x;
	a.y -= b.x;
	b.x = A - B;
}


void FFT_forward_4(inout float2 D[8])
{
	FT2(D[0], D[2]);
	FT2(D[1], D[3]);
	FT2(D[0], D[1]);

	UPD_forward(D[2], D[3]);
}

void FFT_forward_8(inout float2 D[8])
{
	FT2(D[0], D[4]);
	FT2(D[1], D[5]);
	FT2(D[2], D[6]);
	FT2(D[3], D[7]);

	UPD_forward(D[4], D[6]);
	UPD_forward(D[5], D[7]);

	CMUL_forward(D[5], TWIDDLE_1_8);
	CMUL_forward(D[7], TWIDDLE_3_8);

	FFT_forward_4(D);
	FT2(D[4], D[5]);
	FT2(D[6], D[7]);
}

void TWIDDLE(inout float2 d, float phase)
{
	float tx, ty;

	sincos(phase, ty, tx);
	float t = d.x;
	d.x = t * tx - d.y * ty;
	d.y = t * ty + d.y * tx;
}

void TWIDDLE_8(inout float2 D[8], float phase)
{
	TWIDDLE(D[4], 1 * phase);
	TWIDDLE(D[2], 2 * phase);
	TWIDDLE(D[6], 3 * phase);
	TWIDDLE(D[1], 4 * phase);
	TWIDDLE(D[5], 5 * phase);
	TWIDDLE(D[3], 6 * phase);
	TWIDDLE(D[7], 7 * phase);
}

uniform StructuredBuffer<float2>	g_SrcData ;
uniform RWStructuredBuffer<float2>	g_DstData ;

[numthreads(COHERENCY_GRANULARITY, 1, 1)]
shader void Radix008A_CS(uint3 thread_id : SV_DispatchThreadID)
{
	if (thread_id.x >= thread_count)
		return;
	uint threadx=thread_id.x;
	// Fetch 8 complex numbers
	float2 D[8];
	uint i;
	uint imod = threadx & (istride - 1);
	uint iaddr = ((threadx - imod) << 3) + imod;
	for (i = 0; i < 8; i++)
		D[i] = g_SrcData[iaddr + i * istride];

	// Math
	FFT_forward_8(D);
	uint p = threadx & (istride - pstride);
	float phase = phase_base * float(p);
	TWIDDLE_8(D, phase);

	// Store the result
	uint omod = threadx & (ostride - 1);
	uint oaddr = ((threadx - omod) << 3) + omod;
	g_DstData[oaddr + 0 * ostride] = D[0];
	g_DstData[oaddr + 1 * ostride] = D[4];
	g_DstData[oaddr + 2 * ostride] = D[2];
	g_DstData[oaddr + 3 * ostride] = D[6];
	g_DstData[oaddr + 4 * ostride] = D[1];
	g_DstData[oaddr + 5 * ostride] = D[5];
	g_DstData[oaddr + 6 * ostride] = D[3];
	g_DstData[oaddr + 7 * ostride] = D[7];
}


[numthreads(COHERENCY_GRANULARITY, 1, 1)]
shader void Radix008A_CS2(uint3 thread_id : SV_DispatchThreadID)
{
	if(thread_id.x >= thread_count)
		return;
	uint threadx=thread_id.x;
	// Fetch 8 complex numbers
	uint i;
	float2 D[8];
	uint iaddr = threadx << 3;
	for (i = 0; i < 8; i++)
		D[i] = g_SrcData[iaddr + i];

	// Math
	FFT_forward_8(D);

	// Store the result
	uint omod = threadx & (ostride - 1);
	uint oaddr = ((threadx - omod) << 3) + omod;
	g_DstData[oaddr + 0 * ostride] = D[0];
	g_DstData[oaddr + 1 * ostride] = D[4];
	g_DstData[oaddr + 2 * ostride] = D[2];
	g_DstData[oaddr + 3 * ostride] = D[6];
	g_DstData[oaddr + 4 * ostride] = D[1];
	g_DstData[oaddr + 5 * ostride] = D[5];
	g_DstData[oaddr + 6 * ostride] = D[3];
	g_DstData[oaddr + 7 * ostride] = D[7];
}

// Generating gaussian random number with mean 0 and standard deviation 1.
float Gauss(vec2 values)
{
	float u1 = rand(values.xy);
	float u2 = rand(values.yx * 0.5);
	if (u1 < 0.0000001f)
		u1 = 0.0000001f;
	return sqrt(-2.f* log(u1)) * cos(2.f*3.1415926536f * u2);
}

// Phillips Spectrum
// K: normalized wave vector, W: wind direction, v: wind velocity, a: amplitude constant
float Phillips2(vec2 K, vec2 W, float v, float a, float dir_depend)
{
	static float g = 981.f;
	// largest possible wave from constant wind of velocity v
	float l = v * v / g;
	// damp out waves with very small length w << l
	float w = l / 10000.f;

	float Ksqr = K.x * K.x + K.y * K.y;
	float Kcos = K.x * W.x + K.y * W.y;
	float phillips = a * exp(-1 / (l * l * Ksqr)) / (Ksqr * Ksqr * Ksqr) * (Kcos * Kcos);

	// filter out waves moving opposite to wind
	if (Kcos < 0)
		phillips *= dir_depend;

	// damp out waves with very small length w << l
	return phillips *exp(-Ksqr * w * w);
}

//---------------------------------------- Compute Shaders -----------------------------------------

// Pre-FFT data preparation:

// Notice: In CS5.0, we can output up to 8 RWBuffers but in CS4.x only one output buffer is allowed,
// that way we have to allocate one big buffer and manage the offsets manually. The restriction is
// not caused by NVIDIA GPUs and does not present on NVIDIA GPUs when using other computing APIs like
// CUDA and OpenCL.

// Generate H(0)
[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
shader void GenerateHeightMapCS(uint3 sub_pos : SV_DispatchThreadID)
{
	if (sub_pos.x > g_gridSize || sub_pos.y > g_gridSize)
		return;

	static float scale = 0.5f;
	const float HALF_SQRT_2 = 0.7071068f;
	static float g = 981.f;

	vec2 K;

	// K is wave-vector, range [-|DX/W, |DX/W], [-|DY/H, |DY/H]
	// According to Tessendorf, k points in the wave's direction of travel,
	// and has magnitude k related to the wavelength l by k=2pi/l.
	K.y = (-1.0f + 2.0f*(float)sub_pos.x / (float)g_gridSize)*2.0f*SIMUL_PI_F / scale;
	// So K.y goes from -2 SIMUL_PI_F/scale to +2 SIMUL_PI_F/scale
	// And so the wavelength range goes from scale to scale*gridsize/2
	K.x = (-1.0f + 2.0f*(float)sub_pos.y / (float)g_gridSize)*2.0f*SIMUL_PI_F / scale;
	// i.e. K.x goes from 
	float phil = (K.x == 0 && K.y == 0) ? 0 : sqrt(Phillips2(K, g_windDir, g_windSpeed, g_amplitude, g_windDependency));

	g_InputH0[(sub_pos.x * (g_gridSize + 4)) + sub_pos.y].x = phil*Gauss(vec2((vec2)sub_pos.xy / (float)g_gridSize))*HALF_SQRT_2;
	g_InputH0[(sub_pos.x * (g_gridSize + 4)) + sub_pos.y].y = phil*Gauss(vec2((vec2)sub_pos.xy / (float)g_gridSize))*HALF_SQRT_2;

	// The angular frequency is following the dispersion relation:
	//            out_omega^2 = g |k|
	// The equation of Gerstner wave:
	//            x = x0 - K/k * A * sin(dot(K, x0) - sqrt(g * k) * t), x is a 2D vector.
	//            z = A * cos(dot(K, x0) - sqrt(g * k) * t)
	// Gerstner wave shows that a point on a simple sinusoid wave is doing a uniform circular
	// motion with the center (x0, y0, z0), radius A, and the circular plane is parallel to
	// vector K.
	g_InputOmega[sub_pos.x * (g_gridSize + 4) + sub_pos.y] = sqrt(g * sqrt(K.x * K.x + K.y * K.y));

}


// H(0) -> H(t)
[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
shader void UpdateSpectrumCS(uint3 sub_pos : SV_DispatchThreadID)
{
//	g_OutputHt[sub_pos.y*512+sub_pos.x]=vec2(0.2,.5);
	int in_index = int(sub_pos.y * g_InWidth + sub_pos.x);
	int in_mindex =int( (g_ActualDim - sub_pos.y) * g_InWidth + (g_ActualDim - sub_pos.x));
	int out_index = int(sub_pos.y * g_OutWidth + sub_pos.x);

	// H(0) -> H(t)
	vec2 h0_k  = g_InputH0[in_index];
	vec2 h0_mk = g_InputH0[in_mindex];
	float sin_v, cos_v;
	sincos(g_InputOmega[in_index] * g_Time, sin_v, cos_v);

	vec2 ht;
	ht.x = (h0_k.x + h0_mk.x) * cos_v - (h0_k.y + h0_mk.y) * sin_v;
	ht.y = (h0_k.x - h0_mk.x) * sin_v + (h0_k.y - h0_mk.y) * cos_v;

	// H(t) -> Dx(t), Dy(t)
	float kx = sub_pos.x - g_ActualDim * 0.5;
	float ky = sub_pos.y - g_ActualDim * 0.5;
	float sqr_k = kx * kx + ky * ky;
	float rsqr_k = 0;
	if (sqr_k > 1.e-12f)
		rsqr_k = 1 / sqrt(sqr_k);
	//float rsqr_k = 1 / sqrtf(kx * kx + ky * ky);
	kx *= rsqr_k;
	ky *= rsqr_k;
	vec2 dt_x=vec2(ht.y * kx, -ht.x * kx);
	vec2 dt_y=vec2(ht.y * ky, -ht.x * ky);

	if ((sub_pos.x < g_OutWidth) && (sub_pos.y < g_OutHeight))
	{
		g_OutputHt[out_index] = ht;
		g_OutputHt[out_index + g_DxAddressOffset] = dt_x;
		g_OutputHt[out_index + g_DyAddressOffset] = dt_y;
	}
}

// Post-FFT data wrap up: Dx, Dy, Dz -> Displacement
shader vec4 UpdateDisplacementPS(posTexVertexOutput In) : SV_Target
{
	uint index_x = uint(In.texCoords.x * float(g_OutWidth));
	uint index_y = uint(In.texCoords.y * float(g_OutHeight));
	uint addr = g_OutWidth * index_y + index_x;

	// cos(SIMUL_PI_F * (m1 + m2))
	int sign_correction = (((index_x + index_y) & 1) != 0) ? -1 : 1;

	float dx = 100.0f*g_InputDxyz[addr + g_DxAddressOffset] * sign_correction * g_ChoppyScale;
	float dy = 100.0f*g_InputDxyz[addr + g_DyAddressOffset] * sign_correction * g_ChoppyScale;
	float dz = 100.0f*g_InputDxyz[addr].x * sign_correction;
	
	return float4(dx, dy, dz, 1);
}

shader vec4 PS_ShowFrequencyStructuredBuffer( posTexVertexOutput In):SV_TARGET
{
	uint index_x = uint(In.texCoords.x *float(g_ActualDim));
	uint index_y = uint((1.0-In.texCoords.y) *float(g_ActualDim));
	uint addr = int(bufferGrid.x) * index_y + index_x;
    vec2 lookup	=g_InputDxyz[addr];
	return vec4(showMultiplier*lookup.rg,0,1.0);
}

shader vec4 PS_ShowSpatialStructuredBuffer( posTexVertexOutput In):SV_TARGET
{ 
	uint index_x = uint(In.texCoords.x *float(g_ActualDim));
	uint index_y = uint((1.0-In.texCoords.y) *float(g_ActualDim));

	uint addr = int(bufferGrid.x) * index_y + index_x;
	float dx=g_InputDxyz[g_DxAddressOffset+addr].x*g_ChoppyScale;
	float dy=g_InputDxyz[g_DyAddressOffset+addr].x*g_ChoppyScale;
	float dz=g_InputDxyz[addr].x;
	
    vec3 lookup	=vec3(dx,dy,dz);
	int sign_correction = (((index_x + index_y) & 1) != 0) ? -1 : 1;
	lookup  *= sign_correction;
	return vec4(showMultiplier*lookup.rgb,1.0);
}


// Displacement -> Normal, Folding
shader float4 GenGradientFoldingPS(posTexVertexOutput In) : SV_Target
{
	// Sample neighbour texels
	vec2 one_texel = vec2(1.0 / float(g_OutWidth*2), 1.0 / float(g_OutHeight*2));

	vec2 tc_left  = vec2(In.texCoords.x - one_texel.x, In.texCoords.y);
	vec2 tc_right = vec2(In.texCoords.x + one_texel.x, In.texCoords.y);
	vec2 tc_back  = vec2(In.texCoords.x, In.texCoords.y - one_texel.y);
	vec2 tc_front = vec2(In.texCoords.x, In.texCoords.y + one_texel.y);

	vec3 displace_left  = g_samplerDisplacementMap.Sample(wwcSamplerState, tc_left).xyz;
	vec3 displace_right = g_samplerDisplacementMap.Sample(wwcSamplerState, tc_right).xyz;
	vec3 displace_back  = g_samplerDisplacementMap.Sample(wwcSamplerState, tc_back).xyz;
	vec3 displace_front = g_samplerDisplacementMap.Sample(wwcSamplerState, tc_front).xyz;
	
	// Do not store the actual normal value. Using gradient instead, which preserves two differential values.
	vec2 gradient = vec2(-(displace_right.z - displace_left.z), -(displace_front.z - displace_back.z));

	// Calculate Jacobian correlation from the partial differential of height field
	vec2 Dx = (displace_right.xy - displace_left.xy) * g_ChoppyScale;
	vec2 Dy = (displace_front.xy - displace_back.xy) * g_ChoppyScale;
	float J = (1.0 + Dx.x) * (1.0 + Dy.y) - Dx.y * Dy.x;

	// Practical subsurface scale calculation: max[0, (1 - J) + Amplitude * (2 * Coverage - 1)].
	float fold = max(1.0 - J, 0);

	// Output
	return vec4(gradient, 0, fold);
}


[numthreads(BLOCK_SIZE_X, 1, 1)]
shader void UpdateProbeValuesCS(uint3 sub_pos : SV_DispatchThreadID)
{
	vec2 uv_local = (g_ProbePos[sub_pos.x].xy * g_UVScale2 + g_UVOffset2);
	vec3 displacement = g_texDisplacement.SampleLevel(wwcSamplerState, uv_local, 0).xyz + g_texDisplacement.SampleLevel(wwcSamplerState, uv_local / 3.95, 0).xyz;
	float height = max((displacement.z + g_surfaceHeight) - g_ProbePos[sub_pos.x].z, 0.0);
	g_ProbeOutputs[sub_pos.x] = vec4(height, displacement);
}

struct VS_OUTPUT
{
	vec4 Position	: SV_POSITION;
	vec2 texCoords	: TEXCOORD0;
	vec3 LocalPos	: TEXCOORD1;
	vec4 vecColour  : TEXCOORD2;
	vec4 SurePosition : TEXCOORD3;
};

struct PS_WATER_OUTPUTS
{
	vec4 Depth			SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 Scattering		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 Absorption		SIMUL_RENDERTARGET_OUTPUT(2);
	vec4 Normals		SIMUL_RENDERTARGET_OUTPUT(3);
	vec4 RefractColour	SIMUL_RENDERTARGET_OUTPUT(4);
};

//-----------------------------------------------------------------------------
// Name: VS_OceanSurfVS
// Type: Vertex shader									  
// Desc: Ocean shading vertex shader. Check SDK document for more details
//-----------------------------------------------------------------------------
#ifndef MAX_FADE_DISTANCE_METRES
	#define MAX_FADE_DISTANCE_METRES (300000.0)
#endif
VS_OUTPUT VS_OceanSurf(idOnly IN, bool shoreEffects)
{
	VS_OUTPUT Output;
	
	vec3 vPos;
	vec2 cameraCenter;
	cameraCenter.x = g_LocalEye.x;
	cameraCenter.y = g_LocalEye.y;
	Output.vecColour = vec4(0.0, 0.0, 0.0, 0.0);
	vPos = vec3(0.0, 0.0, 0.0);
	float layerQuadSize;
	float layerX = 0.0;
	float layerY = 0.0;
	float perlinMovement = 0;

	uint boundingVerticies = ((8 * g_layerDensity) + 4) * 4;
	uint centerVerticies = (boundingVerticies * g_layerDensity) + 1;
	bool noDisplacement = false;

	//if (g_verticiesPerLayer < 500)
		//noDisplacement = true;

	uint vertexNo = IN.vertex_id;

	if (vertexNo) vertexNo--;

	if (vertexNo < 6)
	{
		noDisplacement = true;
		vPos.z = -10000;
		layerQuadSize = pow(2, g_noOfLayers - 2) * g_minQuadSize;

		float externalLayerQuadSize = layerQuadSize * 2.0;
		float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
		float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

		//Calculate snapped positions
		if (xSnapDifference > layerQuadSize)
		{
			layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
		}
		else
		{
			layerX = cameraCenter.x - xSnapDifference;
		}

		if (ySnapDifference > layerQuadSize)
		{
			layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
		}
		else
		{
			layerY = cameraCenter.y - ySnapDifference;
		}

		if (vertexNo) vertexNo--;
		if (vertexNo > 3) vertexNo--;
		if (vertexNo % 2) vPos.y = g_layerDensity * 4;
		if (vertexNo < 2) vPos.x = g_layerDensity * 4;
	}
	else if (vertexNo < boundingVerticies + 6)
	{
		vertexNo -= 6;
		layerQuadSize = pow(2, g_noOfLayers - 2) * g_minQuadSize;
		uint boundingEdgeVerticies = boundingVerticies / 4;

		float externalLayerQuadSize = layerQuadSize * 2.0;
		float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
		float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

		//Calculate snapped positions
		if (xSnapDifference > layerQuadSize)
		{
			layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
		}
		else
		{
			layerX = cameraCenter.x - xSnapDifference;
		}

		if (ySnapDifference > layerQuadSize)
		{
			layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
		}
		else
		{
			layerY = cameraCenter.y - ySnapDifference;
		}

		int edgeNo = 0;
		if (vertexNo >= boundingEdgeVerticies * 2)
		{
			edgeNo += 2;
			vertexNo -= boundingEdgeVerticies * 2;
			//Output.vecColour += vec4(1.0, 0.0, 0.0, 0.0);
		}
		if (vertexNo >= boundingEdgeVerticies)
		{
			edgeNo++;
			vertexNo -= boundingEdgeVerticies;
			//Output.vecColour += vec4(0.0, 1.0, 0.0, 0.0);
		}
		if (vertexNo == 0) vertexNo++;
		if (edgeNo % 2 == 0)
		{
			if (vertexNo == (boundingEdgeVerticies - 1)) vertexNo--;
			if (vertexNo % 2 == 0)
			{
				vPos.x = (vertexNo - 2) / 2;
			}
			else
			{
				vPos.x = (vertexNo - 1) / 2;
				vPos.z = -10000;
				noDisplacement = true;
			}
			if (edgeNo)
			{
				vPos.x = (g_layerDensity * 4) - vPos.x;
				vPos.y = g_layerDensity * 4;
			}
		}
		else
		{
			edgeNo--;
			if (vertexNo == (boundingEdgeVerticies - 1)) vertexNo--;
				vPos.x = (g_layerDensity * 4);
			if (vertexNo % 2 == 0)
			{
				vPos.y = (vertexNo - 2) / 2;
			}
			else
			{
				vPos.y = (vertexNo - 1) / 2;
				vPos.z = -10000;
				noDisplacement = true;
			}
			if (edgeNo)
			{
				vPos.x = 0;
				vPos.y = (g_layerDensity * 4) - vPos.y;
			}
		}
	}
	else 
	{
		vertexNo -= boundingVerticies + 6;
		if (vertexNo < centerVerticies)
		{
			if (vertexNo == centerVerticies - 1)
				vertexNo--;
			layerQuadSize = (g_minQuadSize / 2.0);
			float externalLayerQuadSize = layerQuadSize * 2.0;
			float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
			float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

			//Calculate snapped positions
			if (xSnapDifference > layerQuadSize)
			{
				layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
			}
			else
			{
				layerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > layerQuadSize)
			{
				layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
			}
			else
			{
				layerY = cameraCenter.y - ySnapDifference;
			}

			uint rowVerticies = ((g_layerDensity * 8) + 4);
			uint vertexRowNo = vertexNo % rowVerticies;
			uint rowNo = (vertexNo - vertexRowNo) / rowVerticies;

			//Assign local position
			if (vertexRowNo == (rowVerticies - 1)) vertexRowNo--;
			if (vertexRowNo == 0) vertexRowNo++;
			if (vertexRowNo % 2 == 0)
			{
				vPos.x = (vertexRowNo - 2) / 2;
				vPos.y = 1;
			}
			else
			{
				vPos.x = (vertexRowNo - 1) / 2;
				vPos.y = 0;
			}
			vPos.y += rowNo;
			//Output.vecColour = vec4(((float)vPos.y / (float)(g_layerDensity * 2)), 1.0 - (float)((float)vPos.y / (float)(g_layerDensity * 2)), 0.0, 1.0);
			//Output.vecColour = vec4( ((float)vertexBlockNo / (float)blockVerticies), 1.0 - (float)((float)vertexBlockNo / (float)blockVerticies), 0.0, 1.0);

		}
		else
		{
			vertexNo = vertexNo - centerVerticies;
			vertexNo = vertexNo % (g_verticiesPerLayer + 1);
			if (vertexNo > 0) vertexNo--;
			uint layerNo = (((IN.vertex_id) - centerVerticies) - vertexNo) / g_verticiesPerLayer;
			layerQuadSize = pow(2, layerNo) * g_minQuadSize;
			float externalLayerQuadSize = pow(2, layerNo + 1) * g_minQuadSize;
			float internalLayerQuadSize = pow(2, layerNo - 1) * g_minQuadSize;
			if (!layerNo)
				internalLayerQuadSize = layerQuadSize / 2.0;

			float internalLayerX;
			float internalLayerY;

			float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
			float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

			//Calculate snapped positions
			if (xSnapDifference > layerQuadSize)
			{
				layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
			}
			else
			{
				layerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > layerQuadSize)
			{
				layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
			}
			else
			{
				layerY = cameraCenter.y - ySnapDifference;
			}

			xSnapDifference = fmod(cameraCenter.x, layerQuadSize);
			ySnapDifference = fmod(cameraCenter.y, layerQuadSize);

			//Calculate internal snapped positions
			if (xSnapDifference > internalLayerQuadSize)
			{
				internalLayerX = cameraCenter.x + layerQuadSize - xSnapDifference;
			}
			else
			{
				internalLayerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > internalLayerQuadSize)
			{
				internalLayerY = cameraCenter.y + layerQuadSize - ySnapDifference;
			}
			else
			{
				internalLayerY = cameraCenter.y - ySnapDifference;
			}

			//Get quad offsets
			int xQuadOffset = 0;
			int yQuadOffset = 0;

			if (layerX != internalLayerX)
			{
				if ((internalLayerX - layerX) < 0.001* g_minQuadSize)
				{
					xQuadOffset++;
				}
				if ((layerX - internalLayerX) < 0.001* g_minQuadSize)
				{
					xQuadOffset--;
				}
			}
			if ((layerY != internalLayerY))
			{
				if ((internalLayerY - layerY) < 0.001* g_minQuadSize)
				{
					yQuadOffset++;
				}
				if ((layerY - internalLayerY) < 0.001* g_minQuadSize)
				{
					yQuadOffset--;
				}
			}
			//More elegant, but precision issues result in layers flickering between correct and incorrect positions (kept for reference)
			//xQuadOffset = (int)(layerX / layerQuadSize) - (int)(internalLayerX / layerQuadSize);
			//yQuadOffset = (int)(layerY / layerQuadSize) - (int)(internalLayerY / layerQuadSize);

			uint totalColumnVerticies = (8 * g_layerDensity + 4) * g_layerDensity * 2;
			uint columnWidth = g_layerDensity - xQuadOffset;
			if ((layerNo % 2) == 1) totalColumnVerticies++;
			if (vertexNo >= g_verticiesPerLayer - totalColumnVerticies)//Is the vertex in a column
			{
				//Output.vecColour = vec4(1.0, 0.0, 0.0, 0.0);
				vertexNo -= g_verticiesPerLayer - totalColumnVerticies;
				if (((layerNo % 2) == 1) && (vertexNo > 0)) vertexNo--;
				uint sideColumnVerticies = (8 * g_layerDensity) + 4;
				uint vertexColumnNo = vertexNo % sideColumnVerticies;
				uint columnNo = (vertexNo - vertexColumnNo) / sideColumnVerticies;

				//Assign local position
				if (vertexColumnNo == 0) vertexColumnNo++;
				if (vertexColumnNo == sideColumnVerticies - 1) vertexColumnNo--;
				if (vertexColumnNo % 2 == 0)
				{
					vPos.x = 1;
					vPos.y = (vertexColumnNo / 2) - 1;
				}
				else
				{
					vPos.x = 0;
					vPos.y = ((vertexColumnNo + 1) / 2) - 1;
				}

				if (columnNo >= g_layerDensity - xQuadOffset)
				{
					vPos.x += columnNo;
					vPos.x += 2 * (int)g_layerDensity;
				}
				else
				{
					vPos.x += columnNo;
				}
				//Output.vecColour = vec4((float)vertexNo / ((float)totalColumnVerticies), 1.0 - ((float)vertexNo / ((float)totalColumnVerticies)), 0.0, 1.0);
			}
			else
			{
				//Output.vecColour = vec4(0.0, 1.0, 0.0, 0.0);
				uint sideRowVerticies = (4 * g_layerDensity) + 4;
				if (((layerNo % 2) == 0) && (vertexNo == (g_verticiesPerLayer - totalColumnVerticies - 1))) vertexNo--;

				uint vertexRowNo = vertexNo % sideRowVerticies;
				uint rowNo = (vertexNo - vertexRowNo) / sideRowVerticies;

				//Assign local position
				if (vertexRowNo == 0) vertexRowNo++;
				if (vertexRowNo == sideRowVerticies - 1) vertexRowNo--;
				if (vertexRowNo % 2 == 0)
				{
					vPos.x = (vertexRowNo - 2) / 2;
					vPos.y = 1;
				}
				else
				{
					vPos.x = (vertexRowNo - 1) / 2;
					vPos.y = 0;
				}
				vPos.x += columnWidth;

				if (rowNo >= g_layerDensity - yQuadOffset)
				{
					vPos.y += rowNo;
					vPos.y += 2 * g_layerDensity;
				}
				else
				{
					vPos.y += rowNo;
				}
				//Output.vecColour = vec4((float)rowNo/(float)(2 *g_layerDensity),1 - ((float)rowNo / (float)(2 * g_layerDensity)), 0.0, 1.0);

			}
			//Output.vecColour = vec4(0.0, 1.0, 0.0, 1.0);
		}
	}

	bool lerpDisplacement = false;
	vec2 lerpSample1;
	vec2 lerpSample2;

	if (((vPos.x == 0) || (vPos.x == (g_layerDensity * 4))) && (vPos.y % 2 == 1))
	{
		lerpDisplacement = true;
		lerpSample1.x = vPos.x;
		lerpSample1.y = vPos.y + 1;
		lerpSample2.x = vPos.x;
		lerpSample2.y = vPos.y - 1;
	} else if (((vPos.y == 0) || (vPos.y == (g_layerDensity * 4))) && (vPos.x % 2 == 1))
	{
		lerpDisplacement = true;
		lerpSample1.x = vPos.x + 1;
		lerpSample1.y = vPos.y;
		lerpSample2.x = vPos.x - 1;
		lerpSample2.y = vPos.y;		
	}
	
	//Center and scale verticies to final position
	vPos *= layerQuadSize;

	vPos.x += layerX - (layerQuadSize * g_layerDensity * 2);
	vPos.y += layerY - (layerQuadSize * g_layerDensity * 2);
	
	float4 pos_local = float4(vPos, 1);
	
	vec2 detail_uv_local = ((vPos.xy) * g_UVScale);
	vec2 detail_uv_local1 = vec2(0.0, 0.0);
	vec2 detail_uv_local2 = vec2(0.0, 0.0);

	if (length(pos_local.xy - cameraCenter) > 50000)
		noDisplacement = true;

	// UV
	vec2 uv_local = (pos_local.xy * g_UVScale + g_UVOffset);
	vec2 uv_local1 = vec2(0.0, 0.0);
	vec2 uv_local2 = vec2(0.0, 0.0);

	if (lerpDisplacement)
	{
		lerpSample1 *= layerQuadSize;
		lerpSample1.x += layerX - (layerQuadSize * g_layerDensity * 2);
		lerpSample1.y += layerY - (layerQuadSize * g_layerDensity * 2);

		lerpSample2 *= layerQuadSize;
		lerpSample2.x += layerX - (layerQuadSize * g_layerDensity * 2);
		lerpSample2.y += layerY - (layerQuadSize * g_layerDensity * 2);

		uv_local1 = (lerpSample1 * g_UVScale + g_UVOffset);
		uv_local2 = (lerpSample2 * g_UVScale + g_UVOffset);

		if (shoreEffects)
		{
			detail_uv_local1 = ((lerpSample1 ) * g_UVScale);
			detail_uv_local2 = ((lerpSample2) * g_UVScale);
		}
	}
	
	if (!noDisplacement)
	{
		// Blend displacement to avoid tiling artifact
		vec3 eye_vec = pos_local.xyz - g_LocalEye;
		float dist_2d = length(eye_vec.xy);
		float blend_factor = (PATCH_BLEND_END - dist_2d) / (PATCH_BLEND_END - PATCH_BLEND_BEGIN);
		blend_factor = 1.0;// clamp(blend_factor, 0, 1);
		
		// Add perlin noise to distant patches
		float perlin = 0;
		vec2 perlin_tc = uv_local * g_PerlinSize + g_UVBase;
		
		// Displacement map
		vec3 displacement = vec3(0, 0, 0);

		if (blend_factor > 0) {
			if (lerpDisplacement)
			{
				vec3 displacement1 = (g_texDisplacement.SampleLevel(wwcSamplerState, uv_local1, 0).xyz + g_texDisplacement.SampleLevel(wwcSamplerState, uv_local1 / 3.95, 1).xyz);
				vec3 displacement2 = (g_texDisplacement.SampleLevel(wwcSamplerState, uv_local2, 0).xyz + g_texDisplacement.SampleLevel(wwcSamplerState, uv_local2 / 3.95, 1).xyz);
				displacement = lerp(displacement1, displacement2, 0.5) * g_WorldScale;
			}
			else
			{
				displacement = (g_texDisplacement.SampleLevel(wwcSamplerState, uv_local, 0).xyz + g_texDisplacement.SampleLevel(wwcSamplerState, uv_local / 3.95, 1).xyz) * g_WorldScale;
			}
		}
		
		float shoreDepth = 1.0;
		vec3 detailDisplacement = vec3(0.0, 0.0, 0.0);
		float fade = 1.0;

		if (shoreEffects)
		{
			fade = saturate(((length(pos_local.xy - cameraCenter) * g_UVScale) - 0.4) / 0.6);

			vec2 shoreCoords = (((vec2(pos_local.x, -pos_local.y) * (1.0 / g_ShoreWidth)) + vec2(0.5, 0.5))) - (vec2(g_ShoreDepthTextureLocation.y, -g_ShoreDepthTextureLocation.x) * (1.0 / g_ShoreWidth));
			shoreDepth = clamp((g_shoreDepthTexture.SampleLevel(clampSamplerState, shoreCoords, 0).x * 0.01) + 1.0 - g_ShoreDepthTextureLocation.z, 0.0, 5.0) / 5.0;
			displacement *= shoreDepth;
			/*
			if (lerpDisplacement)
			{
				vec3 detailDisplacement1 = g_texDisplacement.SampleLevel(wwcSamplerState, -detail_uv_local1, 0).xyz;
				vec3 detailDisplacement2 = g_texDisplacement.SampleLevel(wwcSamplerState, -detail_uv_local2, 0).xyz;
				detailDisplacement = lerp(detailDisplacement1, detailDisplacement2, 0.5) * g_WorldScale;
			}
			else
			{
				detailDisplacement = g_texDisplacement.SampleLevel(wwcSamplerState, -detail_uv_local, 0).xyz * g_WorldScale;//1.0 - g_texDetailMapDisplacement.SampleLevel(bbbSamplerState, detail_uv_local, 0).x;
			}
			*/
//			float zdisplacement = g_amplitude * ((sin((dot(2 * SIMUL_PI_F * g_windDir, pos_local) / (0.1 + ((2 * 0.5 * shoreDepth) / 0.1) - 0.5)) + (((2 * SIMUL_PI_F * g_windSpeed) / 0.1) * g_Time)) + 1) / 2.0);

			//zdisplacement *= (1.0 - fade);

			//pos_local.z += zdisplacement * 100.0;

			//detailDisplacement *= (1.0 - fade);

			//displacement *= fade;
			
			displacement += detailDisplacement.xyz;
		}

		pos_local.xyz += displacement;

		Output.vecColour.w = shoreDepth;
		Output.vecColour.z = fade;
		Output.vecColour.xy = -detail_uv_local;// detailDisplacement;
	}
	//pos_local.z += perlinMovement * g_WorldScale;

	// Transform
	Output.Position = mul(g_matWorldViewProj, pos_local);
	Output.LocalPos = pos_local.xyz;
	// Pass through texture coordinate
	Output.texCoords = uv_local;
	//Output.vecColour = vec4(1.0, 1.0, 1.0, 1.0);
	Output.SurePosition = Output.Position;
	return Output; 
}

shader VS_OUTPUT VS_OceanSurfShore(idOnly IN)
{
	return VS_OceanSurf(IN, true);
}

shader VS_OUTPUT VS_OceanSurfNoShore(idOnly IN)
{
	return VS_OceanSurf(IN, false);
}

shader VS_OUTPUT VS_BoundedWaterSurf(idOnly IN)
{
	VS_OUTPUT Output;

	uint vertexNo = IN.vertex_id;
	//if (vertexNo != g_totalVertices - 1) vertexNo++;
	Output.vecColour = vec4(0.0, 0.0, 0.0, 1.0);
	vec3 vPos = (0.0,0.0,0.0);

	uint boundingVerticies = ((((2 * g_boundedDensity.x) + 4) + ((2 * g_boundedDensity.y) + 4)) * 2);
	uint xBoundingVerticies = (2 * g_boundedDensity.x) + 4;
	uint yBoundingVerticies = (2 * g_boundedDensity.y) + 4;
	bool noDisplacement = false;

	if (vertexNo) vertexNo--;

	if (vertexNo <= 6)
	{
		noDisplacement = true;
		vPos.z = -g_boundedDimension.z;
		if (vertexNo) vertexNo--;
		if (vertexNo > 3) vertexNo--;
		if (vertexNo % 2) vPos.y = g_boundedDensity.y;
		if (vertexNo < 2) vPos.x = g_boundedDensity.x;
	}
	else
	{
		vertexNo -= 6;
		if (vertexNo < boundingVerticies) {
			int edgeNo = 0;
			if (vertexNo >= boundingVerticies / 2)
			{
				edgeNo += 2;
				vertexNo -= boundingVerticies / 2;
			}
			if (vertexNo >= xBoundingVerticies)
			{
				edgeNo++;
				vertexNo -= xBoundingVerticies;
			}
			if (vertexNo == 0) vertexNo++;
			if (edgeNo % 2 == 0)
			{
				if (vertexNo == (xBoundingVerticies - 1)) vertexNo--;
				if (vertexNo % 2 == 0)
				{
					vPos.x = (vertexNo - 2) / 2;
				}
				else
				{
					vPos.x = (vertexNo - 1) / 2;
					vPos.z = -g_boundedDimension.z;
					noDisplacement = true;
				}
				if (edgeNo)
				{
					vPos.x = g_boundedDensity.x - vPos.x;
					vPos.y = g_boundedDensity.y;
				}
			}
			else
			{
				edgeNo--;
				if (vertexNo == (yBoundingVerticies - 1)) vertexNo--;
				vPos.x = g_boundedDensity.x;
				if (vertexNo % 2 == 0)
				{
					vPos.y = (vertexNo - 2) / 2;
				}
				else
				{
					vPos.y = (vertexNo - 1) / 2;
					vPos.z = -g_boundedDimension.z;
					noDisplacement = true;
				}
				if (edgeNo)
				{
					vPos.x = 0;
					vPos.y = g_boundedDensity.y - vPos.y;
				}
			}
		}
		else
		{
			vertexNo -= boundingVerticies;
			uint rowVerticies = ((g_boundedDensity.x * 2) + 4);
			uint vertexRowNo = vertexNo % rowVerticies;
			uint rowNo = (vertexNo - vertexRowNo) / rowVerticies;
			//Assign local position
			if (vertexRowNo == (rowVerticies - 1)) vertexRowNo--;
			if (vertexRowNo == 0) vertexRowNo++;
			if (vertexRowNo % 2 == 0)
			{
				vPos.x = (vertexRowNo - 2) / 2;
				vPos.y = 1;
			}
			else
			{
				vPos.x = (vertexRowNo - 1) / 2;
				vPos.y = 0;
			}
			vPos.y += rowNo;
			//Output.vecColour = vec4(vPos.y / (g_layerDensity * 2), 1.0 - (vPos.y / (g_layerDensity * 2)), 0.0, 1.0);
		}
	}
	vPos.x *= (g_boundedDimension.x / (float)g_boundedDensity.x);
	vPos.y *= (g_boundedDimension.y / (float)g_boundedDensity.y);

	vPos.x -= (g_boundedDimension.x / 2.0);
	vPos.y -= (g_boundedDimension.y / 2.0);

	float rotation = -(g_boundedRotation / 360.0) * PI * 2.0;

	float tempx = vPos.x*cos(rotation) - vPos.y*sin(rotation);
	float tempy = vPos.y*cos(rotation) + vPos.x*sin(rotation);
	vPos.x = tempx;
	vPos.y = tempy;

	vPos += g_boundedLocation.yxz;

	float4 pos_local = float4(vPos, 1);

	// UV
	vec2 uv_local = pos_local.xy * g_UVScale + g_UVOffset;
	if (!noDisplacement)
	{
		// Blend displacement to avoid tiling artifact
		vec3 eye_vec = pos_local.xyz - g_LocalEye;
		float dist_2d = length(eye_vec.xy);
		float blend_factor = (PATCH_BLEND_END - dist_2d) / (PATCH_BLEND_END - PATCH_BLEND_BEGIN);
		blend_factor = clamp(blend_factor, 0, 1);
		
		// Add perlin noise to distant patches
		float perlin = 0;
		vec2 perlin_tc = uv_local * g_PerlinSize + g_UVBase;
		float perlinMovement = 0;

		// Displacement map
		vec3 displacement = vec3(0, 0, 0);

		if (blend_factor > 0)
		{
			displacement = (g_texDisplacement.SampleLevel(wwcSamplerState, uv_local, 0).xyz + g_texDisplacement.SampleLevel(wwcSamplerState, uv_local / 3.95, 1).xyz) * g_WorldScale;
		}

		displacement = lerp(vec3(0, 0, perlin), displacement, blend_factor);
		pos_local.xyz += displacement;
	}
	// Transform
	Output.Position = mul(g_matWorldViewProj, pos_local);
	Output.LocalPos = pos_local.xyz;
	// Pass through texture coordinates
	Output.texCoords = uv_local;

	Output.SurePosition = Output.Position;

	return Output;
}

//Calculate water depth and render values
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction)
{
	PS_WATER_OUTPUTS Output;
	//Calculate depth
	vec3 eye_vec = g_LocalEye - In.LocalPos;
	float surfaceDepth = length(eye_vec)/ 300000.0;

	if(enableRefraction)
		if (surfaceDepth > 50.0)
		{
			enableRefraction = false;
		}

	DepthInterpretationStruct dis;
	dis.reverseDepth = true;
	dis.depthToLinFadeDistParams = g_DepthToLinFadeParams;
	vec2 TexCoord = (vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w) +vec2(1.0, 1.0))/ 2.0;
	vec2 baseTexCoord = TexCoord;

	float actualDepth = 0.0;
	float offset = 0.0;
	vec3 refract_vec = vec3(0.0, 0.0, 0.0);
	vec3 viewNormal = vec3(0.0, 0.0, 0.0);
	vec3 eyeViewVec = vec3(0.0, 0.0, 1.0);

	float backfaceOccluded = 0.0;
	float finalDepth;
	float eyeDepth;

	float foamValue = 0.0;
	float surfaceFoamValue = 0.0;
	float subsurfaceSample;
	float subsurfaceDepth;

	vec2 grad = ((g_texGradient.Sample(g_samplerGradient, In.texCoords).xy + g_texGradient.Sample(g_samplerGradient, In.texCoords / 3.95).xy) / 2.0);// *In.vecColour.w;
	
	if (In.vecColour.z != 1.0)
	{
		grad *= In.vecColour.w;// ((g_texGradient.Sample(g_samplerGradient, fft_tc).xy + g_texGradient.Sample(g_samplerGradient, fft_tc / 3.95).xy) / 2.0);
		//grad += g_texGradient.Sample(g_samplerGradient, In.vecColour.xy).xy * (1.0 - In.vecColour.z);
	}
	
	//grad = lerp(perlin, grad, blend_factor);
	if (abs(grad.x) < 0.0001)
		grad.x = 0.0001 * (grad.x / grad.x);

	if (abs(grad.y) < 0.0001)
		grad.y = 0.0001 * (grad.y / grad.y);
	
	// Calculate normal here.
	vec3 normal = normalize(vec3(grad.x, grad.y, 1.0)) ;

	//Caluclate refraction
	float tempsample = g_texDepth.Sample(clampSamplerState,TexCoord*g_DepthScale);
	float fulldepth =  depthToFadeDistance(tempsample, vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w), dis, g_HalfTan);
	
	float fresnelFactor = 1.0;

	if (frontFacing)
	{			
		actualDepth = saturate(fulldepth - surfaceDepth);

		if (actualDepth > 0.0)
		{
			if (enableRefraction)
			{
				viewNormal = mul(vec4(normal, 0.0), g_matWorldViewProj);
				refract_vec = refract(eyeViewVec, viewNormal, 1.0 / 1.33);

				float cosangle = acos(dot(eyeViewVec, refract_vec) / (length(eyeViewVec) * length(refract_vec)));
				offset = tan(cosangle) * (actualDepth / fulldepth) * (1.0 - saturate((g_LocalEye.z - 35.0) / 5.0));
				TexCoord += offset * (normalize(refract_vec.xy) * g_screenScale);

				TexCoord = abs(TexCoord);
			}
		}
		else 
		{
			actualDepth = 0.0;
			Output.Scattering = vec4(g_scattering, 0.0);
			Output.Absorption = vec4(g_absorption, 0.0);
			Output.RefractColour = vec4(0.0,0.0,0.0,0.0);
			Output.Normals = vec4(0.0, 0.0, 0.0, 0.0);
			Output.Depth = vec4(0.0, 0.0, 0.0, 0.0);

			return Output;
		}
	}
	else
	{
		actualDepth = min(fulldepth, surfaceDepth);

		if (enableRefraction)
		{
			if (actualDepth == surfaceDepth && actualDepth < 0.0001)
			{
				viewNormal = mul(vec4(-normal, 0.0), g_matWorldViewProj);
				refract_vec = normalize(refract(eyeViewVec, viewNormal, 1.0 / 1.33));

				fresnelFactor = fresnel(eyeViewVec, viewNormal, 1.33, 1.0);

				float cosangle = acos(dot(-eyeViewVec, refract_vec) / (length(eyeViewVec) * length(refract_vec)));
				offset = tan(cosangle) *((fulldepth - surfaceDepth) / fulldepth) * (1.0 - saturate((g_LocalEye.z - 35.0) / 5.0));
				TexCoord += offset *(normalize(refract_vec.xy) * g_screenScale);

				TexCoord = abs(TexCoord);
			}
		}
	}
	
	if (TexCoord.y >= 1.0)
		TexCoord.y = 2.0 - TexCoord.y;

	if (TexCoord.x >= 1.0)
		TexCoord.x = 2.0 - TexCoord.x;

	if (enableRefraction)
	{
		subsurfaceSample = g_texDepth.Sample(clampSamplerState, TexCoord*g_DepthScale);
		subsurfaceDepth = depthToFadeDistance(subsurfaceSample, vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w), dis, g_HalfTan);
		if (subsurfaceDepth < surfaceDepth)
		{
			TexCoord = baseTexCoord;
			subsurfaceDepth = fulldepth;
		}
	}
	else
	{
		subsurfaceDepth = fulldepth;
	}
	//else if (g_enableRefraction)
		//TexCoord = lerp(TexCoord, ((vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w) + vec2(1.0, 1.0)) / 2.0), exp(tempsample - subsurfaceSample) );
	
	if (!frontFacing)
	{
		finalDepth = -min(actualDepth, surfaceDepth);
		if (subsurfaceDepth > actualDepth) {
			backfaceOccluded = 1.0;
		}
	}
	else 
	{
		if (subsurfaceDepth > surfaceDepth) 
		{
			finalDepth = subsurfaceDepth - surfaceDepth;
		}
		else
		{
			finalDepth = 0.0;
		}
	}

	if (enableFoam) //Make sure foam only generated for the ocean.
	{
		vec2 foamSamples = g_foamAlpha.Sample(wwcSamplerState, vec3(In.texCoords, 0));
		float bubbles = g_foamTexture.Sample(wwcSamplerState, vec3(In.texCoords * 4, 0)).x;
		float surfaceFoamTextureSample = g_surfaceFoamTexture.Sample(wwcSamplerState, In.texCoords * 6.0).x / 2.0;

		//foamSamples = vec2(0.0, 0.0);
		//bubbles = 0.0;
		//surfaceFoamTextureSample = 0.0;

		foamValue = (1.0 - bubbles) * foamSamples.x;

		surfaceFoamValue = foamSamples.y * pow(surfaceFoamTextureSample, 5.0);

		if (foamSamples.y / 8.0 > 0.95)
			surfaceFoamValue += ((foamSamples.y / 8.0) - 0.95) / 10.0;

		if ((bubbles * bubbles) > surfaceFoamValue)
			surfaceFoamValue = 0.0;
		//surfaceFoamValue = foamSamples.y;

		clamp(surfaceFoamValue, 0.0, 1.0);
		clamp(foamValue, 0.0, 1.0);

		eyeDepth = g_LocalEye.z / 300000.0;
	}
	else
	{
		eyeDepth = (g_LocalEye.z - g_boundedLocation.z) / 300000.0;
	}
	
	float4 refractColour = g_texColour.Sample(clampSamplerState, TexCoord*g_DepthScale); //vec4(offset,0.0, 0.0,0.0); // length(g_texDisplacement.SampleLevel(wrapSamplerState, In.texCoords, 0).xy);//

	//float4 refractColour = vec4(0.0,0.0,0.0,1.0);

	Output.Scattering = vec4(g_scattering, foamValue);
	Output.Absorption = vec4(g_absorption, surfaceFoamValue);
	Output.RefractColour = refractColour;
	Output.Normals = vec4(normal, backfaceOccluded);
	Output.Depth = vec4(finalDepth, actualDepth, eyeDepth, fulldepth);

	return Output;
}

shader PS_WATER_OUTPUTS PS_OceanWaterSurfDepth(VS_OUTPUT In, bool frontFacing : SV_IsFrontFace) : SV_Target
{
	return PS_WaterSurfDepth(In, frontFacing, true, false);
}

shader PS_WATER_OUTPUTS PS_BoundedWaterSurfDepth(VS_OUTPUT In, bool frontFacing : SV_IsFrontFace) : SV_Target
{
	return PS_WaterSurfDepth(In, frontFacing, false, false);
}

shader PS_WATER_OUTPUTS PS_OceanWaterSurfDepthRefraction(VS_OUTPUT In, bool frontFacing : SV_IsFrontFace) : SV_Target
{
	return PS_WaterSurfDepth(In, frontFacing, true, true);
}

shader PS_WATER_OUTPUTS PS_BoundedWaterSurfDepthRefraction(VS_OUTPUT In, bool frontFacing : SV_IsFrontFace) : SV_Target
{
	return PS_WaterSurfDepth(In, frontFacing, false, true);
}


shader float4 WaterSurfFinalPS(posTexVertexOutput In) : SV_Target
{
	float4 depthInput = g_waterDepth.Sample(clampSamplerState, In.texCoords);

	//Discard occluded fragments
	if (depthInput.y == 0.0)
		discard;

	float waterDepth = depthInput.x;

	if (waterDepth == 0.0)
		waterDepth = depthInput.y;

	float4 Output = vec4(0.0, 0.0, 0.0, 0.0);

	float4 absorptionInput = g_waterAbsorption.Sample(clampSamplerState, In.texCoords);
	vec3 absorption = absorptionInput.xyz;//vec3(0.2916, 0.0474, 0.0092);

	float4 scatteringInput = g_waterScattering.Sample(clampSamplerState, In.texCoords);
	vec3 scattering = scatteringInput.xyz;//vec3(0.17, 0.2, 0.234); //Ocean scattering

	float4 normalsInput = g_waterNormals.Sample(clampSamplerState, In.texCoords);
	float4 refractColourInput = g_waterRefractColour.Sample(clampSamplerState, In.texCoords);
	vec3 normal = normalsInput.xyz;
	
	//return refractColourInput;

	float scatterDepth = 0.0;
	float fadeDistance = 300000;
	float absoluteDepth = depthInput.y;

	vec4 clip = vec4((In.texCoords.x * 2) - 1, ((1 - In.texCoords.y) * 2) - 1, 1.0, 1.0);
	vec4 view = mul(g_matInvViewProj, clip);
	vec3 eye_dir = normalize(view.xyz / view.w);
	vec3 sun_dir = normalize(g_SunDir);

	float sunAngle = dot(sun_dir, vec3(0.0, 0.0, 1.0)) / (length(sun_dir) * length(vec3(0.0, 0.0, 1.0)));

	// Fournier-Forand phase function
	float u = 4.0;
	float v = (3 - u) / 2;
	float b = (4 / (3 * pow(1.33 - 1, 2))) * (0.5 - 0.5 * (dot(eye_dir, sun_dir)));
	float p = 1 - ((1 - pow(b, v + 1) - (0.5 * (1 - pow(b, v)))) / ((1 - b) * pow(b, v)));
	
	//float A = acos(dot(sun_dir, vec3(0.0, 0.0, 1.0)) / (length(sun_dir) * length(vec3(0.0, 0.0, 1.0))));
	//float B = acos(dot(eye_dir, -vec3(0.0, 0.0, 1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, 1.0))));
	float c = 1.0;// (sin(A) / sin(B));

	vec3 extinction = scattering + absorption;
	vec3 albedo = scattering / extinction;
	
	//Camera is below the water
	if (waterDepth < 0.0)
	{
		waterDepth *= -1.0;
		float eye_depth = abs(depthInput.z);
		float pointDepth = 0.0;
		
		if (normalsInput.w == 0.0) //Depth hits a solid surface first
		{
			if (eye_dir.z < 0.0)
			{
				pointDepth = eye_depth + abs(waterDepth * dot(eye_dir, vec3(0.0, 0.0, -1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, -1.0))));
			}
			else
			{
				pointDepth = eye_depth - abs(waterDepth * sin((PI / 2.0) - acos(dot(eye_dir, vec3(0.0, 0.0, 1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, 1.0))))));
			}
			if ((sun_dir.z >= 0.0))
			{
				
				scatterDepth = pointDepth / sunAngle;
			}
			else
			{
				scatterDepth = pointDepth;
			}
		}
		else {
			if (scatteringInput.w  > 0.0 || absorptionInput.w > 0.0)
			{
				vec3 foamEffect = vec3(scatteringInput.w  * g_SunColor.xyz);
				refractColourInput += vec4(foamEffect * 0.5, scatteringInput.w);
				refractColourInput += vec4(absorptionInput.w * g_SunColor* clamp(dot(normal, sun_dir), 0.1, 1.0), 0.0);
			}
			//refractColourInput += vec4(scatteringInput.w, scatteringInput.w, scatteringInput.w, 0.0);
			scatterDepth = eye_depth;
		}


		float sunEffect = ((dot(eye_dir, sun_dir) + 1.0) / 2.0);

		if (sun_dir.z <= 0.0)
			sunEffect = 0.0;
		/*
		if (normalsInput.w)
		{
			float refractFresnel = fresnel(eye_dir, -normal, 1.0, 1.33);
			if (!length(refractFresnel))
				refractColourInput = vec4(sunEffect, sunEffect, sunEffect, sunEffect);
		}*/

		vec3 incomingRadiance = exp(-extinction * scatterDepth * fadeDistance) * g_SunColor;
		vec4 mult = vec4(exp(-extinction * (waterDepth + scatterDepth) * fadeDistance) * refractColourInput, 0.0);
		vec4 surfaceScattering = vec4(g_SunColor * exp(-fadeDistance * (eye_depth ) * extinction ) , 0.0);
		vec4 SSS = vec4((albedo * (p / (1 + c)) * (1 - (exp(-extinction * (1 + c) * fadeDistance *  waterDepth)))), 0.0);

		SSS = max(SSS, vec4(0.0, 0.0, 0.0, 0.0));
		surfaceScattering = max(surfaceScattering, vec4(0.0, 0.0, 0.0, 0.0));

		Output += mult;
		Output += SSS * surfaceScattering;

		//float temp = (3 * (0.5 + 0.5 * cos(2 * acos(dot(eye_dir, sun_dir)))) - 1.0);//((3 * (dot(eye_dir, sun_dir) * dot(eye_dir, sun_dir))) - 1.0);

		return max(Output, vec4(0.0,0.0,0.0,0.0));
	}

	float pointDepth = abs(absoluteDepth * (dot(eye_dir, vec3(0.0, 0.0, -1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, -1.0)))));
	if ((sun_dir.z >= 0.0))
	{
		float sunAngle = dot(-sun_dir, vec3(-sun_dir.xy,0.0)) / (length(-sun_dir) * length(vec3(-sun_dir.xy, 0.0)));
		scatterDepth = pointDepth / sin(acos(sunAngle)); //Water Depth to the sun
	}
	else {
		scatterDepth = pointDepth;
	}

	vec3 reflect_vec = reflect(eye_dir, normal);
	vec3 refract_vec = refract(eye_dir, normal, 1.0 / 1.33);

	float sunEffect = (dot(normal, sun_dir) + 1.0) / 2.0;

	reflect_vec.z = max(reflect_vec.z, 0.0);
	sun_dir.z = max(sun_dir.z, 0.0);

	float sunScatter = saturate(dot(refract_vec, sun_dir));

	if (!sun_dir.z)
		sunScatter = 0.0;

	float eye_depth = abs(depthInput.z);

	vec3 incomingRadiance = exp(-extinction  *(waterDepth) * fadeDistance) * g_SunColor;
	vec4 mult = vec4(exp(-extinction * (waterDepth + scatterDepth) * fadeDistance) * refractColourInput, 0.0);
	vec4 surfaceScattering = vec4(g_SunColor * exp(-extinction) , 0.0);
	vec4 SSS = vec4((albedo * (p / (1 + c)) * (1 - (exp(-extinction * (1 + c)  * fadeDistance * absoluteDepth)))), 0.0);

	//SSS = max(SSS, vec4(0.0, 0.0, 0.0, 0.0));
	//surfaceScattering = max(surfaceScattering, vec4(0.0, 0.0, 0.0, 0.0));

	Output += mult;
	Output += SSS * surfaceScattering;
	Output += SSS * sunScatter;

	// --------------- Sun spots
	float cos_spec = dot(normalize(reflect_vec), sun_dir);
	//float sun_spot = pow(cos_spec, g_Shineness);
	//vec4 sunSpec = max(vec4(g_SunColor * sun_spot * sun_spot * sun_spot, 0.0), 0.0);

	vec4 sunSpec = vec4(((g_Shineness + 1) / (2 * SIMUL_PI_F)) * pow(saturate(cos_spec), g_Shineness) *g_SunColor, 0.0);
	float sunFresnel = fresnel(-sun_dir, normal, 1.0, 1.33);
	Output += sunSpec *sunFresnel;
	
	// --------------- Reflected colour
	vec3 refl = texture_cube_lod(g_texReflectCube, reflect_vec.yxz, 0);
	float reflectFresnel = fresnel(-reflect_vec, normal, 1.0, 1.33);


	float ramp = lerp(reflectFresnel, 0.2f, (0.1f - reflect_vec.z) / 0.5);

	Output += vec4(refl * reflectFresnel, 0.0);

	// --------------- Foam colour
	if (scatteringInput.w  > 0.0 || absorptionInput.w > 0.0)
	{
			//refl -= vec3(scatteringInput.w, scatteringInput.w, scatteringInput.w);
			vec3 foamEffect = vec3(scatteringInput.w, scatteringInput.w, scatteringInput.w);
			//Output -= vec4(vec3(scatteringInput.w, scatteringInput.w, scatteringInput.w) , scatteringInput.w);
			//Output -= vec4(vec3(absorptionInput.w, absorptionInput.w, absorptionInput.w), 0.0)  * 0.5;
			Output += vec4(foamEffect * albedo, 1.0) * surfaceScattering * clamp(dot(normal, sun_dir), 0.1, 1.0);
			Output += vec4(g_SunColor, 0.0) * absorptionInput.w * clamp(dot(normal, sun_dir), 0.1, 1.0);
	}

	return Output;
}

shader float4 CopyDepthStencilPS(posTexVertexOutput In) : SV_Target
{
	float4 Output = g_texDepth.Sample(wwcSamplerState, In.texCoords);
	return Output;
}

shader float4 UpdateFoamAlphaPS(posTexVertexOutput In) : SV_Target
{
	float foam = 0.0;
	float surfaceFoam = 0.0;
	float alpha = 0.98;
	float displacement = g_texDisplacement.Sample(g_samplerGradient, In.texCoords).z;

	float derivativeX = ddx(g_texDisplacement.Sample(g_samplerGradient, In.texCoords).x);
	float derivativeY = ddy(g_texDisplacement.Sample(g_samplerGradient, In.texCoords).y);

	if (displacement > g_foamHeight)
	{
		if (derivativeY < 0.0001)
		{
			surfaceFoam += 0.5;// 1.0 - (derivativeY * 10000);
			//surfaceFoam = 1.0;
			alpha = 1.0;
		}

		if (derivativeX < 0.0001)
		{
			surfaceFoam += 0.5;// 1.0 - (derivativeX * 10000);
			//surfaceFoam = 1.0;
			alpha = 1.0;
		}
	}
	if ((displacement >= g_foamChurn))
	{
		foam = (displacement - g_foamChurn) / 10.0;
		alpha = 1.0;
	}

	return float4(foam / 2.0, surfaceFoam, 0.0, alpha);
}

shader float4 WireframePS(VS_OUTPUT IN) : SV_Target
{
	return IN.vecColour;
}

shader posTexVertexOutput VS_ShowTexture(idOnly id)
{
	return VS_ScreenQuad(id,rect);
}

shader vec4 PS_ShowTexture( posTexVertexOutput IN):SV_TARGET
{
	vec4 lookup=showTexture.Sample(wwcSamplerState,IN.texCoords.xy);
	return vec4(showMultiplier*lookup.rgb,1.0);
}

shader vec4 PS_ClearTexture(posTexVertexOutput IN) :SV_TARGET
{
	return vec4(0.0,0.0,0.0,0.0);
}

technique water_final_pass
{
	pass p0 
	{
		SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, WaterSurfFinalPS()));
	}
}

technique copy_stencil
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, CopyDepthStencilPS()));
	}
}

technique show_texture
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
}

technique show_frequency_structured_buffer
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowFrequencyStructuredBuffer()));
	}
}
technique show_spatial_structured_buffer
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowSpatialStructuredBuffer()));
	}
}

technique wireframe_ocean
{
	pass p0 
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState(TestReverseDepth, 0 );
		SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,WireframePS()));
	}
}

technique wireframe_bounded
{
	pass p0
	{
		SetRasterizerState(wireframeRasterizer);
		SetDepthStencilState(TestReverseDepth, 0);
		SetBlendState(AddBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_BoundedWaterSurf()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, WireframePS()));
	}
}

technique render_boundless_depth
{
	pass no_refraction
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0 );
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0,VS_OceanSurfNoShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepth()));
	}

	pass refraction_no_backface
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfNoShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepthRefraction()));
	}

	pass refraction
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfNoShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepthRefraction()));
	}
}

technique render_boundless_depth_shore
{
	pass no_refraction
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepth()));
	}

	pass refraction_no_backface
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepthRefraction()));
	}

	pass refraction
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_OceanSurfShore()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_OceanWaterSurfDepthRefraction()));
	}
}

technique render_bounded_depth
{
	pass no_refraction
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_BoundedWaterSurf()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_BoundedWaterSurfDepth()));
	}

	pass refraction
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_BoundedWaterSurf()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_BoundedWaterSurfDepthRefraction()));
	}

	pass refraction_no_backface
	{
		SetRasterizerState(RenderBackfaceCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_BoundedWaterSurf()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_BoundedWaterSurfDepthRefraction()));
	}
}

technique update_foam
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetBlendState(FoamBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, UpdateFoamAlphaPS()));
	}
}

technique generate_heightmap
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0, GenerateHeightMapCS()));
	}
}

technique update_spectrum
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,UpdateSpectrumCS()));
	}
}

technique radix_008a
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,Radix008A_CS()));
	}
}


technique radix_008a2
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,Radix008A_CS2()));
	}
}


technique update_displacement
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,UpdateDisplacementPS()));
	}
}

technique gradient_folding
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,GenGradientFoldingPS()));
	}
}

technique clear_gradient
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(DontBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_ClearTexture()));
	}
}

technique update_probes
	{
		pass p0
		{
			SetComputeShader(CompileShader(cs_5_0, UpdateProbeValuesCS()));
		}
	}
