//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/states.sl"
#include "../SL/ocean_constants.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/debug_constants.sl"
#include "../SL/depth.sl"
#include "../SL/noise.sl"

#define PATCH_BLEND_BEGIN		2000
#define PATCH_BLEND_END			4000

#define PI 3.1415926536f
#define BLOCK_SIZE_X 16
#define BLOCK_SIZE_Y 16

uniform Texture2D	g_samplerDisplacementMap	SIMUL_TEXTURE_REGISTER(0);

uniform Texture2D	showTexture					SIMUL_TEXTURE_REGISTER(0);

uniform Texture2D	g_texDisplacement			SIMUL_TEXTURE_REGISTER(0);		// FFT wave displacement map in VS
uniform Texture2D	g_texPerlin					SIMUL_TEXTURE_REGISTER(1);		// Perlin wave displacement & gradient map in both VS & PS
uniform Texture2D	g_texGradient				SIMUL_TEXTURE_REGISTER(2);		// FFT wave gradient map in PS
uniform Texture2D	g_texColour					SIMUL_TEXTURE_REGISTER(3);		// Colour of the render target, used for refraction
uniform Texture2D	g_texDepth					SIMUL_TEXTURE_REGISTER(4);		// Depth of rendered scene up till now
uniform Texture2D	g_waterRefractColour		SIMUL_TEXTURE_REGISTER(5);		// Colour of the refracted underwater surface
uniform Texture2D	g_waterStencil				SIMUL_TEXTURE_REGISTER(6);		// Depth Stencil generated by the water to be applied to the global depth buffer
uniform Texture2D	g_foamTexture				SIMUL_TEXTURE_REGISTER(7);		// Foam colour
uniform Texture2D	g_foamAlpha					SIMUL_TEXTURE_REGISTER(8);		// Foam Alpha

uniform Texture2D	g_waterDepth				SIMUL_TEXTURE_REGISTER(0);		// Depth of the water
uniform Texture2D	g_waterAbsorption			SIMUL_TEXTURE_REGISTER(1);		// Absorption of the water, 4th value Salinity
uniform Texture2D	g_waterScattering			SIMUL_TEXTURE_REGISTER(2);		// Scattering of the water, 4th value Foam Colour
uniform Texture2D	g_waterNormals				SIMUL_TEXTURE_REGISTER(3);		// Normals of the water held in seperate texture to allow for multiple instances
uniform TextureCube	g_texReflectCube			: register(t4);					// A skybox cube texture for reflection

// The following three should contains only real numbers. But we have only C2C FFT now.
uniform StructuredBuffer<vec2>		g_InputDxyz;
uniform RWStructuredBuffer<vec2>	g_InputH0	: register(u5);
uniform RWStructuredBuffer<vec2>	g_OutputHt;
uniform RWStructuredBuffer<float>	g_InputOmega: register(u6);

struct TwoColourCompositeOutput
{
	vec4 add		SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 multiply	SIMUL_RENDERTARGET_OUTPUT(1);
};

// FFT wave displacement map in VS, XY for choppy field, Z for height field
//SamplerState g_samplerDisplacement	now use nearestWrap

// Perlin noise for composing distant waves, W for height field, XY for gradient
SamplerState g_samplerPerlin SIMUL_STATE_REGISTER(3)
{
	Filter =ANISOTROPIC;
	AddressU =WRAP;
	AddressV =WRAP;
	AddressW =WRAP;
	MipLODBias = 0;
	//ComparisonFunc = NEVER;
	MinLOD = 0;
	MaxLOD = 1000000;
	MaxAnisotropy = 16;
};

// FFT wave gradient map, converted to normal value in PS
SamplerState g_samplerGradient SIMUL_STATE_REGISTER(7)
{
	Filter =ANISOTROPIC;
	AddressU =WRAP;
	AddressV =WRAP;
	AddressW =WRAP;
	MipLODBias = 0;
	MaxAnisotropy = 8;
};

#define COS_PI_4_16 0.70710678118654752440084436210485f
#define TWIDDLE_1_8 COS_PI_4_16, -COS_PI_4_16
#define TWIDDLE_3_8 -COS_PI_4_16, -COS_PI_4_16

#define COHERENCY_GRANULARITY 128

#define RAND_MAX 0x7fff

float fresnel(vec3 incident, vec3 normal, float sourceIndex, float mediumIndex)
{
	float fresnel;
	float cos_incident = clamp(-1.0, 1.0, dot(incident, normal));

	float sint = (sourceIndex / mediumIndex) * sqrt(max(0.0, 1 - (cos_incident * cos_incident)));
	if (sint >= 1.0)
	{
		fresnel = 0.0;
	}
	else
	{
		float cost = sqrt(max(0.0, 1 - sint * sint));
		cos_incident = abs(cos_incident);
		float Rs = ((mediumIndex * cos_incident) - (sourceIndex * cost)) / ((mediumIndex * cos_incident) + (sourceIndex * cost));
		float Rp = ((sourceIndex * cos_incident) - (mediumIndex * cost)) / ((sourceIndex * cos_incident) + (mediumIndex * cost));
		fresnel = ((Rs * Rs + Rp * Rp) / 2.0);
	}

	return fresnel;

}

void FT2(inout float2 a, inout float2 b)
{
	float t;

	t = a.x;
	a.x += b.x;
	b.x = t - b.x;

	t = a.y;
	a.y += b.y;
	b.y = t - b.y;
}

void CMUL_forward(inout float2 a, float bx, float by)
{
	float t = a.x;
	a.x = t * bx - a.y * by;
	a.y = t * by + a.y * bx;
}

void UPD_forward(inout float2 a, inout float2 b)
{
	float A = a.x;
	float B = b.y;

	a.x += b.y;
	b.y = a.y + b.x;
	a.y -= b.x;
	b.x = A - B;
}


void FFT_forward_4(inout float2 D[8])
{
	FT2(D[0], D[2]);
	FT2(D[1], D[3]);
	FT2(D[0], D[1]);

	UPD_forward(D[2], D[3]);
}

void FFT_forward_8(inout float2 D[8])
{
	FT2(D[0], D[4]);
	FT2(D[1], D[5]);
	FT2(D[2], D[6]);
	FT2(D[3], D[7]);

	UPD_forward(D[4], D[6]);
	UPD_forward(D[5], D[7]);

	CMUL_forward(D[5], TWIDDLE_1_8);
	CMUL_forward(D[7], TWIDDLE_3_8);

	FFT_forward_4(D);
	FT2(D[4], D[5]);
	FT2(D[6], D[7]);
}

void TWIDDLE(inout float2 d, float phase)
{
	float tx, ty;

	sincos(phase, ty, tx);
	float t = d.x;
	d.x = t * tx - d.y * ty;
	d.y = t * ty + d.y * tx;
}

void TWIDDLE_8(inout float2 D[8], float phase)
{
	TWIDDLE(D[4], 1 * phase);
	TWIDDLE(D[2], 2 * phase);
	TWIDDLE(D[6], 3 * phase);
	TWIDDLE(D[1], 4 * phase);
	TWIDDLE(D[5], 5 * phase);
	TWIDDLE(D[3], 6 * phase);
	TWIDDLE(D[7], 7 * phase);
}

uniform StructuredBuffer<float2>	g_SrcData ;
uniform RWStructuredBuffer<float2>	g_DstData ;

[numthreads(COHERENCY_GRANULARITY, 1, 1)]
shader void Radix008A_CS(uint3 thread_id : SV_DispatchThreadID)
{
	if (thread_id.x >= thread_count)
		return;
	uint threadx=thread_id.x;
	// Fetch 8 complex numbers
	float2 D[8];
	uint i;
	uint imod = threadx & (istride - 1);
	uint iaddr = ((threadx - imod) << 3) + imod;
	for (i = 0; i < 8; i++)
		D[i] = g_SrcData[iaddr + i * istride];

	// Math
	FFT_forward_8(D);
	uint p = threadx & (istride - pstride);
	float phase = phase_base * float(p);
	TWIDDLE_8(D, phase);

	// Store the result
	uint omod = threadx & (ostride - 1);
	uint oaddr = ((threadx - omod) << 3) + omod;
	g_DstData[oaddr + 0 * ostride] = D[0];
	g_DstData[oaddr + 1 * ostride] = D[4];
	g_DstData[oaddr + 2 * ostride] = D[2];
	g_DstData[oaddr + 3 * ostride] = D[6];
	g_DstData[oaddr + 4 * ostride] = D[1];
	g_DstData[oaddr + 5 * ostride] = D[5];
	g_DstData[oaddr + 6 * ostride] = D[3];
	g_DstData[oaddr + 7 * ostride] = D[7];
}


[numthreads(COHERENCY_GRANULARITY, 1, 1)]
shader void Radix008A_CS2(uint3 thread_id : SV_DispatchThreadID)
{
	if(thread_id.x >= thread_count)
		return;
	uint threadx=thread_id.x;
	// Fetch 8 complex numbers
	uint i;
	float2 D[8];
	uint iaddr = threadx << 3;
	for (i = 0; i < 8; i++)
		D[i] = g_SrcData[iaddr + i];

	// Math
	FFT_forward_8(D);

	// Store the result
	uint omod = threadx & (ostride - 1);
	uint oaddr = ((threadx - omod) << 3) + omod;
	g_DstData[oaddr + 0 * ostride] = D[0];
	g_DstData[oaddr + 1 * ostride] = D[4];
	g_DstData[oaddr + 2 * ostride] = D[2];
	g_DstData[oaddr + 3 * ostride] = D[6];
	g_DstData[oaddr + 4 * ostride] = D[1];
	g_DstData[oaddr + 5 * ostride] = D[5];
	g_DstData[oaddr + 6 * ostride] = D[3];
	g_DstData[oaddr + 7 * ostride] = D[7];
}

// Generating gaussian random number with mean 0 and standard deviation 1.
float Gauss(vec2 values)
{
	float u1 = rand(values.xy);
	float u2 = rand(values.yx * 0.5);
	if (u1 < 0.0000001f)
		u1 = 0.0000001f;
	return sqrt(-2.f* log(u1)) * cos(2.f*3.1415926536f * u2);
}

// Phillips Spectrum
// K: normalized wave vector, W: wind direction, v: wind velocity, a: amplitude constant
float Phillips2(vec2 K, vec2 W, float v, float a, float dir_depend)
{
	static float g = 981.f;
	// largest possible wave from constant wind of velocity v
	float l = v * v / g;
	// damp out waves with very small length w << l
	float w = l / 10000.f;

	float Ksqr = K.x * K.x + K.y * K.y;
	float Kcos = K.x * W.x + K.y * W.y;
	float phillips = a * exp(-1 / (l * l * Ksqr)) / (Ksqr * Ksqr * Ksqr) * (Kcos * Kcos);

	// filter out waves moving opposite to wind
	if (Kcos < 0)
		phillips *= dir_depend;

	// damp out waves with very small length w << l
	return phillips;// *exp(-Ksqr * w * w);
}

//---------------------------------------- Compute Shaders -----------------------------------------

// Pre-FFT data preparation:

// Notice: In CS5.0, we can output up to 8 RWBuffers but in CS4.x only one output buffer is allowed,
// that way we have to allocate one big buffer and manage the offsets manually. The restriction is
// not caused by NVIDIA GPUs and does not present on NVIDIA GPUs when using other computing APIs like
// CUDA and OpenCL.

// Generate H(0)
[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
shader void GenerateHeightMapCS(uint3 sub_pos : SV_DispatchThreadID)
{
	if (sub_pos.x > g_gridSize || sub_pos.y > g_gridSize)
		return;

	static float scale = 0.5f;
	const float HALF_SQRT_2 = 0.7071068f;
	static float g = 981.f;

	vec2 K;

	// K is wave-vector, range [-|DX/W, |DX/W], [-|DY/H, |DY/H]
	// According to Tessendorf, k points in the wave's direction of travel,
	// and has magnitude k related to the wavelength l by k=2pi/l.
	K.y = (-1.0f + 2.0f*(float)sub_pos.x / (float)g_gridSize)*2.0f*SIMUL_PI_F / scale;
	// So K.y goes from -2 SIMUL_PI_F/scale to +2 SIMUL_PI_F/scale
	// And so the wavelength range goes from scale to scale*gridsize/2
	K.x = (-1.0f + 2.0f*(float)sub_pos.y / (float)g_gridSize)*2.0f*SIMUL_PI_F / scale;
	// i.e. K.x goes from 
	float phil = (K.x == 0 && K.y == 0) ? 0 : sqrt(Phillips2(K, g_windDir, g_windSpeed, g_amplitude, g_windDependency));

	g_InputH0[(sub_pos.x * (g_gridSize + 4)) + sub_pos.y].x = phil*Gauss(vec2((vec2)sub_pos.xy / (float)g_gridSize))*HALF_SQRT_2;
	g_InputH0[(sub_pos.x * (g_gridSize + 4)) + sub_pos.y].y = phil*Gauss(vec2((vec2)sub_pos.xy / (float)g_gridSize))*HALF_SQRT_2;

	// The angular frequency is following the dispersion relation:
	//            out_omega^2 = g |k|
	// The equation of Gerstner wave:
	//            x = x0 - K/k * A * sin(dot(K, x0) - sqrt(g * k) * t), x is a 2D vector.
	//            z = A * cos(dot(K, x0) - sqrt(g * k) * t)
	// Gerstner wave shows that a point on a simple sinusoid wave is doing a uniform circular
	// motion with the center (x0, y0, z0), radius A, and the circular plane is parallel to
	// vector K.
	g_InputOmega[sub_pos.x * (g_gridSize + 4) + sub_pos.y] = sqrt(g * sqrt(K.x * K.x + K.y * K.y));

}


// H(0) -> H(t)
[numthreads(BLOCK_SIZE_X, BLOCK_SIZE_Y, 1)]
shader void UpdateSpectrumCS(uint3 sub_pos : SV_DispatchThreadID)
{
//	g_OutputHt[sub_pos.y*512+sub_pos.x]=vec2(0.2,.5);
	int in_index = int(sub_pos.y * g_InWidth + sub_pos.x);
	int in_mindex =int( (g_ActualDim - sub_pos.y) * g_InWidth + (g_ActualDim - sub_pos.x));
	int out_index = int(sub_pos.y * g_OutWidth + sub_pos.x);

	// H(0) -> H(t)
	vec2 h0_k  = g_InputH0[in_index];
	vec2 h0_mk = g_InputH0[in_mindex];
	float sin_v, cos_v;
	sincos(g_InputOmega[in_index] * g_Time, sin_v, cos_v);

	vec2 ht;
	ht.x = (h0_k.x + h0_mk.x) * cos_v - (h0_k.y + h0_mk.y) * sin_v;
	ht.y = (h0_k.x - h0_mk.x) * sin_v + (h0_k.y - h0_mk.y) * cos_v;

	// H(t) -> Dx(t), Dy(t)
	float kx = sub_pos.x - g_ActualDim * 0.5;
	float ky = sub_pos.y - g_ActualDim * 0.5;
	float sqr_k = kx * kx + ky * ky;
	float rsqr_k = 0;
	if (sqr_k > 1.e-12f)
		rsqr_k = 1 / sqrt(sqr_k);
	//float rsqr_k = 1 / sqrtf(kx * kx + ky * ky);
	kx *= rsqr_k;
	ky *= rsqr_k;
	vec2 dt_x=vec2(ht.y * kx, -ht.x * kx);
	vec2 dt_y=vec2(ht.y * ky, -ht.x * ky);

	if ((sub_pos.x < g_OutWidth) && (sub_pos.y < g_OutHeight))
	{
		g_OutputHt[out_index] = ht;
		g_OutputHt[out_index + g_DxAddressOffset] = dt_x;
		g_OutputHt[out_index + g_DyAddressOffset] = dt_y;
	}
}

// Post-FFT data wrap up: Dx, Dy, Dz -> Displacement
shader vec4 UpdateDisplacementPS(posTexVertexOutput In) : SV_Target
{
	uint index_x = uint(In.texCoords.x * float(g_OutWidth));
	uint index_y = uint(In.texCoords.y * float(g_OutHeight));
	uint addr = g_OutWidth * index_y + index_x;

	// cos(SIMUL_PI_F * (m1 + m2))
	int sign_correction = (((index_x + index_y) & 1) != 0) ? -1 : 1;

	float dx = 100.0f*g_InputDxyz[addr + g_DxAddressOffset] * sign_correction * g_ChoppyScale;
	float dy = 100.0f*g_InputDxyz[addr + g_DyAddressOffset] * sign_correction * g_ChoppyScale;
	float dz = 100.0f*g_InputDxyz[addr].x * sign_correction;
	
	return float4(dx, dy, dz, 1);
}

shader vec4 PS_ShowFrequencyStructuredBuffer( posTexVertexOutput In):SV_TARGET
{
	uint index_x = uint(In.texCoords.x *float(g_ActualDim));
	uint index_y = uint((1.0-In.texCoords.y) *float(g_ActualDim));
	uint addr = int(bufferGrid.x) * index_y + index_x;
    vec2 lookup	=g_InputDxyz[addr];
	return vec4(showMultiplier*lookup.rg,0,1.0);
}

shader vec4 PS_ShowSpatialStructuredBuffer( posTexVertexOutput In):SV_TARGET
{ 
	uint index_x = uint(In.texCoords.x *float(g_ActualDim));
	uint index_y = uint((1.0-In.texCoords.y) *float(g_ActualDim));

	uint addr = int(bufferGrid.x) * index_y + index_x;
	float dx=g_InputDxyz[g_DxAddressOffset+addr].x*g_ChoppyScale;
	float dy=g_InputDxyz[g_DyAddressOffset+addr].x*g_ChoppyScale;
	float dz=g_InputDxyz[addr].x;
	
    vec3 lookup	=vec3(dx,dy,dz);
	int sign_correction = (((index_x + index_y) & 1) != 0) ? -1 : 1;
	lookup  *= sign_correction;
	return vec4(showMultiplier*lookup.rgb,1.0);
}


// Displacement -> Normal, Folding
shader float4 GenGradientFoldingPS(posTexVertexOutput In) : SV_Target
{
	// Sample neighbour texels
	vec2 one_texel = vec2(1.0 / float(g_OutWidth*2), 1.0 / float(g_OutHeight*2));

	vec2 tc_left  = vec2(In.texCoords.x - one_texel.x, In.texCoords.y);
	vec2 tc_right = vec2(In.texCoords.x + one_texel.x, In.texCoords.y);
	vec2 tc_back  = vec2(In.texCoords.x, In.texCoords.y - one_texel.y);
	vec2 tc_front = vec2(In.texCoords.x, In.texCoords.y + one_texel.y);

	vec3 displace_left  = g_samplerDisplacementMap.Sample(wrapSamplerState, tc_left).xyz;
	vec3 displace_right = g_samplerDisplacementMap.Sample(wrapSamplerState, tc_right).xyz;
	vec3 displace_back  = g_samplerDisplacementMap.Sample(wrapSamplerState, tc_back).xyz;
	vec3 displace_front = g_samplerDisplacementMap.Sample(wrapSamplerState, tc_front).xyz;
	
	// Do not store the actual normal value. Using gradient instead, which preserves two differential values.
	vec2 gradient = vec2(-(displace_right.z - displace_left.z), -(displace_front.z - displace_back.z));

	// Calculate Jacobian correlation from the partial differential of height field
	vec2 Dx = (displace_right.xy - displace_left.xy) * g_ChoppyScale;
	vec2 Dy = (displace_front.xy - displace_back.xy) * g_ChoppyScale;
	float J = (1.0 + Dx.x) * (1.0 + Dy.y) - Dx.y * Dy.x;

	// Practical subsurface scale calculation: max[0, (1 - J) + Amplitude * (2 * Coverage - 1)].
	float fold = max(1.0 - J, 0);

	// Output
	return vec4(gradient, 0, fold);
}


struct VS_OUTPUT
{
	vec4 Position	: SV_POSITION;
	vec2 texCoords	: TEXCOORD0;
	vec3 LocalPos	: TEXCOORD1;
	vec4 vecColour  : TEXCOORD2;
	vec4 SurePosition : TEXCOORD3;
};

struct PS_WATER_OUTPUTS
{
	vec4 Depth			SIMUL_RENDERTARGET_OUTPUT(0);
	vec4 Scattering		SIMUL_RENDERTARGET_OUTPUT(1);
	vec4 Absorption		SIMUL_RENDERTARGET_OUTPUT(2);
	vec4 Normals		SIMUL_RENDERTARGET_OUTPUT(3);
	vec4 RefractColour	SIMUL_RENDERTARGET_OUTPUT(4);
};

//-----------------------------------------------------------------------------
// Name: OceanSurfVS
// Type: Vertex shader									  
// Desc: Ocean shading vertex shader. Check SDK document for more details
//-----------------------------------------------------------------------------
#ifndef MAX_FADE_DISTANCE_METRES
	#define MAX_FADE_DISTANCE_METRES (300000.0)
#endif
shader VS_OUTPUT OceanSurfVS(idOnly IN)
{
	VS_OUTPUT Output;
	
	uint centerVerticies = (((g_layerDensity * 8) + 4) * g_layerDensity * 4) + 1;

	vec3 vPos;
	vec2 cameraCenter;
	cameraCenter.x = g_LocalEye.x;
	cameraCenter.y = g_LocalEye.y;
	Output.vecColour = vec4(0.0, 0.0, 0.0, 0.0);
	vPos = vec3(0.0, 0.0, 0.0);
	float layerQuadSize;
	float layerX = 0.0;
	float layerY = 0.0;
	
	uint boundingVerticies = ((8 * g_layerDensity) + 4) * 4;
	bool noDisplacement = false;

	uint vertexNo = g_totalVertices-IN.vertex_id;

	if (vertexNo) vertexNo--;

	if (vertexNo < 6)
	{
		noDisplacement = true;
		vPos.z = -10000;
		layerQuadSize = pow(2, g_noOfLayers - 2) * g_minQuadSize;

		float externalLayerQuadSize = layerQuadSize * 2.0;
		float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
		float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

		//Calculate snapped positions
		if (xSnapDifference > layerQuadSize)
		{
			layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
		}
		else
		{
			layerX = cameraCenter.x - xSnapDifference;
		}

		if (ySnapDifference > layerQuadSize)
		{
			layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
		}
		else
		{
			layerY = cameraCenter.y - ySnapDifference;
		}

		if (vertexNo) vertexNo--;
		if (vertexNo > 3) vertexNo--;
		if (vertexNo % 2) vPos.y = g_layerDensity * 4;
		if (vertexNo < 2) vPos.x = g_layerDensity * 4;
	}
	else if (vertexNo < boundingVerticies + 6)
	{
		vertexNo -= 6;
		layerQuadSize = pow(2, g_noOfLayers - 2) * g_minQuadSize;
		uint boundingEdgeVerticies = boundingVerticies / 4;

		float externalLayerQuadSize = layerQuadSize * 2.0;
		float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
		float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

		//Calculate snapped positions
		if (xSnapDifference > layerQuadSize)
		{
			layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
		}
		else
		{
			layerX = cameraCenter.x - xSnapDifference;
		}

		if (ySnapDifference > layerQuadSize)
		{
			layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
		}
		else
		{
			layerY = cameraCenter.y - ySnapDifference;
		}

		int edgeNo = 0;
		if (vertexNo >= boundingEdgeVerticies * 2)
		{
			edgeNo += 2;
			vertexNo -= boundingEdgeVerticies * 2;
			Output.vecColour += vec4(1.0, 0.0, 0.0, 0.0);
		}
		if (vertexNo >= boundingEdgeVerticies)
		{
			edgeNo++;
			vertexNo -= boundingEdgeVerticies;
			Output.vecColour += vec4(0.0, 1.0, 0.0, 0.0);
		}
		if (vertexNo == 0) vertexNo++;
		if (edgeNo % 2 == 0)
		{
			if (vertexNo == (boundingEdgeVerticies - 1)) vertexNo--;
			if (vertexNo % 2 == 0)
			{
				vPos.x = (vertexNo - 2) / 2;
			}
			else
			{
				vPos.x = (vertexNo - 1) / 2;
				vPos.z = -10000;
				noDisplacement = true;
			}
			if (edgeNo)
			{
				vPos.x = (g_layerDensity * 4) - vPos.x;
				vPos.y = g_layerDensity * 4;
			}
		}
		else
		{
			edgeNo--;
			if (vertexNo == (boundingEdgeVerticies - 1)) vertexNo--;
				vPos.x = (g_layerDensity * 4);
			if (vertexNo % 2 == 0)
			{
				vPos.y = (vertexNo - 2) / 2;
			}
			else
			{
				vPos.y = (vertexNo - 1) / 2;
				vPos.z = -10000;
				noDisplacement = true;
			}
			if (edgeNo)
			{
				vPos.x = 0;
				vPos.y = (g_layerDensity * 4) - vPos.y;
			}
		}
	}
	else 
	{
		vertexNo -= boundingVerticies + 6;
		if (vertexNo < centerVerticies)
		{
			if (vertexNo == centerVerticies - 1)
				vertexNo--;
			layerQuadSize = (g_minQuadSize / 2.0);
			float externalLayerQuadSize = layerQuadSize * 2.0;
			float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
			float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

			//Calculate snapped positions
			if (xSnapDifference > layerQuadSize)
			{
				layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
			}
			else
			{
				layerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > layerQuadSize)
			{
				layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
			}
			else
			{
				layerY = cameraCenter.y - ySnapDifference;
			}

			uint rowVerticies = ((g_layerDensity * 8) + 4);
			uint vertexRowNo = vertexNo % rowVerticies;
			uint rowNo = (vertexNo - vertexRowNo) / rowVerticies;

			//Assign local position
			if (vertexRowNo == (rowVerticies - 1)) vertexRowNo--;
			if (vertexRowNo == 0) vertexRowNo++;
			if (vertexRowNo % 2 == 0)
			{
				vPos.x = (vertexRowNo - 2) / 2;
				vPos.y = 1;
			}
			else
			{
				vPos.x = (vertexRowNo - 1) / 2;
				vPos.y = 0;
			}
			vPos.y += rowNo;
			//Output.vecColour = vec4(((float)vPos.y / (float)(g_layerDensity * 2)), 1.0 - (float)((float)vPos.y / (float)(g_layerDensity * 2)), 0.0, 1.0);
			//Output.vecColour = vec4( ((float)vertexBlockNo / (float)blockVerticies), 1.0 - (float)((float)vertexBlockNo / (float)blockVerticies), 0.0, 1.0);

		}
		else
		{
			vertexNo = vertexNo - centerVerticies;
			vertexNo = vertexNo % (g_verticiesPerLayer + 1);
			if (vertexNo > 0) vertexNo--;
			uint layerNo = ((((g_totalVertices)-IN.vertex_id) - centerVerticies) - vertexNo) / g_verticiesPerLayer;
			layerQuadSize = pow(2, layerNo) * g_minQuadSize;
			float externalLayerQuadSize = pow(2, layerNo + 1) * g_minQuadSize;
			float internalLayerQuadSize = pow(2, layerNo - 1) * g_minQuadSize;
			if (!layerNo)
				internalLayerQuadSize = layerQuadSize / 2.0;

			float internalLayerX;
			float internalLayerY;

			float xSnapDifference = fmod(cameraCenter.x, externalLayerQuadSize);
			float ySnapDifference = fmod(cameraCenter.y, externalLayerQuadSize);

			//Calculate snapped positions
			if (xSnapDifference > layerQuadSize)
			{
				layerX = cameraCenter.x + externalLayerQuadSize - xSnapDifference;
			}
			else
			{
				layerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > layerQuadSize)
			{
				layerY = cameraCenter.y + externalLayerQuadSize - ySnapDifference;
			}
			else
			{
				layerY = cameraCenter.y - ySnapDifference;
			}

			xSnapDifference = fmod(cameraCenter.x, layerQuadSize);
			ySnapDifference = fmod(cameraCenter.y, layerQuadSize);

			//Calculate internal snapped positions
			if (xSnapDifference > internalLayerQuadSize)
			{
				internalLayerX = cameraCenter.x + layerQuadSize - xSnapDifference;
			}
			else
			{
				internalLayerX = cameraCenter.x - xSnapDifference;
			}

			if (ySnapDifference > internalLayerQuadSize)
			{
				internalLayerY = cameraCenter.y + layerQuadSize - ySnapDifference;
			}
			else
			{
				internalLayerY = cameraCenter.y - ySnapDifference;
			}

			//Get quad offsets
			int xQuadOffset = 0;
			int yQuadOffset = 0;

			if (layerX != internalLayerX)
			{
				if ((internalLayerX - layerX) < 0.001* g_minQuadSize)
				{
					xQuadOffset++;
				}
				if ((layerX - internalLayerX) < 0.001* g_minQuadSize)
				{
					xQuadOffset--;
				}
			}
			if ((layerY != internalLayerY))
			{
				if ((internalLayerY - layerY) < 0.001* g_minQuadSize)
				{
					yQuadOffset++;
				}
				if ((layerY - internalLayerY) < 0.001* g_minQuadSize)
				{
					yQuadOffset--;
				}
			}
			//More elegant, but precision issues (kept for reference)
			//xQuadOffset = (int)(layerX / layerQuadSize) - (int)(internalLayerX / layerQuadSize);
			//yQuadOffset = (int)(layerY / layerQuadSize) - (int)(internalLayerY / layerQuadSize);

			uint totalColumnVerticies = (8 * g_layerDensity + 4) * g_layerDensity * 2;
			if ((layerNo % 2) == 1) totalColumnVerticies++;
			uint columnWidth = g_layerDensity - xQuadOffset;
			if (vertexNo >= g_verticiesPerLayer - totalColumnVerticies)//Is the vertex in a column
			{
				//Output.vecColour = vec4(1.0, 0.0, 0.0, 0.0);
				vertexNo -= g_verticiesPerLayer - totalColumnVerticies;
				if (((layerNo % 2) == 1) && (vertexNo > 0)) vertexNo--;
				uint sideColumnVerticies = (8 * g_layerDensity) + 4;
				uint vertexColumnNo = vertexNo % sideColumnVerticies;

				uint columnNo = (vertexNo - vertexColumnNo) / sideColumnVerticies;

				//Assign local position
				if (vertexColumnNo == 0) vertexColumnNo++;
				if (vertexColumnNo == sideColumnVerticies - 1) vertexColumnNo--;
				if (vertexColumnNo % 2 == 0)
				{
					vPos.x = 1;
					vPos.y = (vertexColumnNo / 2) - 1;
				}
				else
				{
					vPos.x = 0;
					vPos.y = ((vertexColumnNo + 1) / 2) - 1;
				}

				if (columnNo >= g_layerDensity - xQuadOffset)
				{
					vPos.x += columnNo;
					vPos.x += 2 * (int)g_layerDensity;
				}
				else
				{
					vPos.x += columnNo;
				}
				//Output.vecColour = vec4((float)vertexNo / ((float)totalColumnVerticies), 1.0 - ((float)vertexNo / ((float)totalColumnVerticies)), 0.0, 1.0);
			}
			else
			{
				//Output.vecColour = vec4(0.0, 1.0, 0.0, 0.0);
				uint sideRowVerticies = (4 * g_layerDensity) + 4;
				if (((layerNo % 2) == 0) && (vertexNo == (g_verticiesPerLayer - totalColumnVerticies - 1))) vertexNo--;

				uint vertexRowNo = vertexNo % sideRowVerticies;
				uint rowNo = (vertexNo - vertexRowNo) / sideRowVerticies;

				//Assign local position
				if (vertexRowNo == 0) vertexRowNo++;
				if (vertexRowNo == sideRowVerticies - 1) vertexRowNo--;
				if (vertexRowNo % 2 == 0)
				{
					vPos.x = (vertexRowNo - 2) / 2;
					vPos.y = 1;
				}
				else
				{
					vPos.x = (vertexRowNo - 1) / 2;
					vPos.y = 0;
				}
				vPos.x += columnWidth;

				if (rowNo >= g_layerDensity - yQuadOffset)
				{
					vPos.y += rowNo;
					vPos.y += 2 * g_layerDensity;
				}
				else
				{
					vPos.y += rowNo;
				}
				//Output.vecColour = vec4((float)rowNo/(float)(2 *g_layerDensity),1 - ((float)rowNo / (float)(2 * g_layerDensity)), 0.0, 1.0);

			}
			//Output.vecColour = vec4(0.0, 1.0, 0.0, 1.0);
		}
	}
	bool lerpDisplacement = false;
	vec2 lerpSample1;
	vec2 lerpSample2;

	if (((vPos.x == 0) || (vPos.x == (g_layerDensity * 4))) && (vPos.y % 2 == 1))
	{
		lerpDisplacement = true;
		lerpSample1.x = vPos.x;
		lerpSample1.y = vPos.y + 1;
		lerpSample2.x = vPos.x;
		lerpSample2.y = vPos.y - 1;
	}

	if (((vPos.y == 0) || (vPos.y == (g_layerDensity * 4))) && (vPos.x % 2 == 1))
	{
		lerpDisplacement = true;
		lerpSample1.x = vPos.x + 1;
		lerpSample1.y = vPos.y;
		lerpSample2.x = vPos.x - 1;
		lerpSample2.y = vPos.y;		
	}

	if (lerpDisplacement)
	{
		lerpSample1.x *= layerQuadSize;
		lerpSample1.y *= layerQuadSize;
		lerpSample1.x += layerX - (layerQuadSize * g_layerDensity * 2 );
		lerpSample1.y += layerY - (layerQuadSize * g_layerDensity * 2 );

		lerpSample2.x *= layerQuadSize;
		lerpSample2.y *= layerQuadSize;
		lerpSample2.x += layerX - (layerQuadSize * g_layerDensity * 2);
		lerpSample2.y += layerY - (layerQuadSize * g_layerDensity * 2);
	}

	//Center and scale verticies to final position
	
	vPos.x *= layerQuadSize;
	vPos.y *= layerQuadSize;
	vPos.x += layerX - (layerQuadSize * g_layerDensity * 2);
	vPos.y += layerY - (layerQuadSize * g_layerDensity * 2);


	float4 pos_local = float4(vPos, 1);

	// UV
	vec2 uv_local = (pos_local.xy * g_UVScale + g_UVOffset);
	vec2 uv_local1 = vec2(0.0, 0.0);
	vec2 uv_local2 = vec2(0.0, 0.0);
	if (lerpDisplacement)
	{
		vec2 uv_local1 = (lerpSample1.xy * g_UVScale + g_UVOffset);
		vec2 uv_local2 = (lerpSample2.xy * g_UVScale + g_UVOffset);
	}

	if (length(pos_local.xy) > 10000)
		noDisplacement = true;

	if (!noDisplacement)
	{
		// Blend displacement to avoid tiling artifact
		vec3 eye_vec = pos_local.xyz - g_LocalEye;
		float dist_2d = length(eye_vec.xy);
		float blend_factor = (PATCH_BLEND_END - dist_2d) / (PATCH_BLEND_END - PATCH_BLEND_BEGIN);
		blend_factor = clamp(blend_factor, 0, 1);

		// Add perlin noise to distant patches
		float perlin = 0;
		vec2 perlin_tc = uv_local * g_PerlinSize + g_UVBase;
		float perlinMovement = 0;

		if (blend_factor < 1)
		{
			if (lerpDisplacement)
			{
				vec2 perlin_tc1 = uv_local1 * g_PerlinSize + g_UVBase;
				vec2 perlin_tc2 = uv_local2 * g_PerlinSize + g_UVBase;
				float perlin_01 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.x + g_PerlinMovement, 0).w;
				float perlin_02 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.x + g_PerlinMovement, 0).w;
				float perlin_11 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.y + g_PerlinMovement, 0).w;
				float perlin_12 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.y + g_PerlinMovement, 0).w;
				float perlin_21 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.z + g_PerlinMovement, 0).w;
				float perlin_22 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.z + g_PerlinMovement, 0).w;

				float perlin_0 = lerp(perlin_01, perlin_02, 0.5);
				float perlin_1 = lerp(perlin_11, perlin_12, 0.5);
				float perlin_2 = lerp(perlin_21, perlin_22, 0.5);

				perlin = perlin_0 * g_PerlinAmplitude.x + perlin_1 * g_PerlinAmplitude.y + perlin_2 * g_PerlinAmplitude.z;

				float perlinTemp1 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc1 / 32.f + g_PerlinMovement / 4.f, 0).w;
				float perlinTemp2 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc2 / 32.f + g_PerlinMovement / 4.f, 0).w;

				perlinMovement = lerp(perlinTemp1, perlinTemp2, 0.5);
			}
			else
			{
				float perlin_0 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.x + g_PerlinMovement, 0).w;
				float perlin_1 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.y + g_PerlinMovement, 0).w;
				float perlin_2 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.z + g_PerlinMovement, 0).w;

				perlin = perlin_0 * g_PerlinAmplitude.x + perlin_1 * g_PerlinAmplitude.y + perlin_2 * g_PerlinAmplitude.z;

				perlinMovement = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc / 32.f + g_PerlinMovement / 4.f, 0).w;
			}
		}

		// Displacement map
		vec3 displacement = vec3(0, 0, 0);

		if (blend_factor > 0) {
			if (lerpDisplacement)
			{
				vec2 uv_local1 = lerpSample1.xy * g_UVScale + g_UVOffset;
				vec2 uv_local2 = lerpSample2.xy * g_UVScale + g_UVOffset;
				vec3 displacement1 = (g_texDisplacement.SampleLevel(wrapSamplerState, uv_local1, 0).xyz + g_texDisplacement.SampleLevel(wrapSamplerState, uv_local1 / 3.5, 0).xyz);
				vec3 displacement2 = (g_texDisplacement.SampleLevel(wrapSamplerState, uv_local2, 0).xyz + g_texDisplacement.SampleLevel(wrapSamplerState, uv_local2 / 3.5, 0).xyz);
				displacement = lerp(displacement1, displacement2, 0.5) * g_WorldScale;
			}
			else
			{
				displacement = (g_texDisplacement.SampleLevel(wrapSamplerState, uv_local, 0).xyz + g_texDisplacement.SampleLevel(wrapSamplerState, uv_local / 3.5, 0).xyz) * g_WorldScale;
			}
		}
		//
		displacement = lerp(vec3(0, 0, perlin), displacement, blend_factor);
		pos_local.xyz += displacement + vec3(0.0, 0.0, 0.0);
	}
	//pos_local.z += perlinMovement * g_WorldScale;

	// Transform
	Output.Position = mul(g_matWorldViewProj, pos_local);
	Output.LocalPos = pos_local.xyz;
	// Pass thru texture coordinate
	Output.texCoords = uv_local;

	vec3 wPosition = pos_local.xyz;

	Output.SurePosition = Output.Position;
	return Output; 
}

shader VS_OUTPUT BoundedWaterSurfVS(idOnly IN)
{
	VS_OUTPUT Output;

	uint vertexNo = g_totalVertices-IN.vertex_id;
	//if (vertexNo != g_totalVertices - 1) vertexNo++;
	Output.vecColour = vec4(0.0, 0.0, 0.0, 0.0);
	vec3 vPos = (0.0,0.0,0.0);

	uint boundingVerticies = ((((2 * g_boundedDensity.x) + 4) + ((2 * g_boundedDensity.y) + 4)) * 2);
	uint xBoundingVerticies = (2 * g_boundedDensity.x) + 4;
	uint yBoundingVerticies = (2 * g_boundedDensity.y) + 4;
	bool noDisplacement = false;

	if (vertexNo <= 6)
	{
		noDisplacement = true;
		vPos.z = -g_boundedDimension.z;
		if (vertexNo) vertexNo--;
		if (vertexNo > 3) vertexNo--;
		if (vertexNo % 2) vPos.y = g_boundedDensity.y;
		if (vertexNo < 2) vPos.x = g_boundedDensity.x;
	}
	else
	{
		vertexNo -= 6;
		if (vertexNo < boundingVerticies) {
			int edgeNo = 0;
			if (vertexNo >= boundingVerticies / 2)
			{
				edgeNo += 2;
				vertexNo -= boundingVerticies / 2;
			}
			if (vertexNo >= xBoundingVerticies)
			{
				edgeNo++;
				vertexNo -= xBoundingVerticies;
			}
			if (vertexNo == 0) vertexNo++;
			if (edgeNo % 2 == 0)
			{
				if (vertexNo == (xBoundingVerticies - 1)) vertexNo--;
				if (vertexNo % 2 == 0)
				{
					vPos.x = (vertexNo - 2) / 2;
				}
				else
				{
					vPos.x = (vertexNo - 1) / 2;
					vPos.z = -g_boundedDimension.z;
					noDisplacement = true;
				}
				if (edgeNo)
				{
					vPos.x = g_boundedDensity.x - vPos.x;
					vPos.y = g_boundedDensity.y;
				}
			}
			else
			{
				edgeNo--;
				if (vertexNo == (yBoundingVerticies - 1)) vertexNo--;
				vPos.x = g_boundedDensity.x;
				if (vertexNo % 2 == 0)
				{
					vPos.y = (vertexNo - 2) / 2;
				}
				else
				{
					vPos.y = (vertexNo - 1) / 2;
					vPos.z = -g_boundedDimension.z;
					noDisplacement = true;
				}
				if (edgeNo)
				{
					vPos.x = 0;
					vPos.y = g_boundedDensity.y - vPos.y;
				}
			}
		}
		else
		{
			vertexNo -= boundingVerticies;
			uint rowVerticies = ((g_boundedDensity.x * 2) + 4);
			uint vertexRowNo = vertexNo % rowVerticies;
			uint rowNo = (vertexNo - vertexRowNo) / rowVerticies;
			//Assign local position
			if (vertexRowNo == (rowVerticies - 1)) vertexRowNo--;
			if (vertexRowNo == 0) vertexRowNo++;
			if (vertexRowNo % 2 == 0)
			{
				vPos.x = (vertexRowNo - 2) / 2;
				vPos.y = 1;
			}
			else
			{
				vPos.x = (vertexRowNo - 1) / 2;
				vPos.y = 0;
			}
			vPos.y += rowNo;
			//Output.vecColour = vec4(vPos.y / (g_layerDensity * 2), 1.0 - (vPos.y / (g_layerDensity * 2)), 0.0, 1.0);
		}
	}
	vPos.x *= (g_boundedDimension.x / (float)g_boundedDensity.x);
	vPos.y *= (g_boundedDimension.y / (float)g_boundedDensity.y);

	vPos.x -= (g_boundedDimension.x / 2.0);
	vPos.y -= (g_boundedDimension.y / 2.0);

	float rotation = -(g_boundedRotation / 360.0) * PI * 2.0;

	float tempx = vPos.x*cos(rotation) - vPos.y*sin(rotation);
	float tempy = vPos.y*cos(rotation) + vPos.x*sin(rotation);
	vPos.x = tempx;
	vPos.y = tempy;

	vPos.x += g_boundedLocation.y;
	vPos.y += g_boundedLocation.x;
	vPos.z += g_boundedLocation.z;

	float4 pos_local = float4(vPos, 1);

	// UV
	vec2 uv_local = pos_local.xy * g_UVScale + g_UVOffset;
	if (!noDisplacement)
	{
		// Blend displacement to avoid tiling artifact
		vec3 eye_vec = pos_local.xyz - g_LocalEye;
		float dist_2d = length(eye_vec.xy);
		float blend_factor = (PATCH_BLEND_END - dist_2d) / (PATCH_BLEND_END - PATCH_BLEND_BEGIN);
		blend_factor = clamp(blend_factor, 0, 1);

		// Add perlin noise to distant patches
		float perlin = 0;
		vec2 perlin_tc = uv_local * g_PerlinSize + g_UVBase;
		float perlinMovement = 0;

		if (blend_factor < 1)
		{
			float perlin_0 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.x + g_PerlinMovement, 0).w;
			float perlin_1 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.y + g_PerlinMovement, 0).w;
			float perlin_2 = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc * g_PerlinOctave.z + g_PerlinMovement, 0).w;

			perlin = perlin_0 * g_PerlinAmplitude.x + perlin_1 * g_PerlinAmplitude.y + perlin_2 * g_PerlinAmplitude.z;

			perlinMovement = g_texPerlin.SampleLevel(g_samplerPerlin, perlin_tc / 32.f + g_PerlinMovement / 4.f, 0).w;
		}

		// Displacement map
		vec3 displacement = vec3(0, 0, 0);

		if (blend_factor > 0)
		{
			displacement = (g_texDisplacement.SampleLevel(wrapSamplerState, uv_local, 0).xyz + g_texDisplacement.SampleLevel(wrapSamplerState, uv_local / 3.5, 0).xyz) * g_WorldScale;
		}

		displacement = lerp(vec3(0, 0, perlin), displacement, blend_factor);
		pos_local.xyz += displacement + vec3(0.0, 0.0, 0.0);
	}
	// Transform
	Output.Position = mul(g_matWorldViewProj, pos_local);
	Output.LocalPos = pos_local.xyz;
	// Pass through texture coordinate
	Output.texCoords = uv_local;

	vec3 wPosition = pos_local.xyz;

	Output.SurePosition = Output.Position;

	return Output;
}

//Calculate water depth and render values
shader PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing : SV_IsFrontFace) : SV_Target
{
	PS_WATER_OUTPUTS Output;
	//Calculate depth
	vec3 eye_vec = g_LocalEye - In.LocalPos;
	float surfaceDepth = length(eye_vec)/ 300000.0;
	DepthInterpretationStruct dis;
	dis.reverseDepth = true;
	dis.depthToLinFadeDistParams = g_DepthToLinFadeParams;
	vec2 TexCoord = (vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w) +vec2(1.0, 1.0))/ 2.0;

	float foamValue = 0.0;
	//foamValue = g_foamTexture.Sample(wrapSamplerState, In.texCoords * 4) / 2;

	//Calculate normals
	float blend_factor = (PATCH_BLEND_END - surfaceDepth) / (PATCH_BLEND_END - PATCH_BLEND_BEGIN);
	blend_factor = clamp(blend_factor * blend_factor * blend_factor, 0, 1);

	// Compose perlin waves from three octaves
	vec2 perlin_tc = In.texCoords * g_PerlinSize + g_UVBase;
	vec2 perlin_tc0 = (blend_factor < 1) ? perlin_tc * g_PerlinOctave.x + g_PerlinMovement : 0;
	vec2 perlin_tc1 = (blend_factor < 1) ? perlin_tc * g_PerlinOctave.y + g_PerlinMovement : 0;
	vec2 perlin_tc2 = (blend_factor < 1) ? perlin_tc * g_PerlinOctave.z + g_PerlinMovement : 0;

	vec2 perlin_0 = g_texPerlin.Sample(g_samplerPerlin, perlin_tc0).xy;
	vec2 perlin_1 = g_texPerlin.Sample(g_samplerPerlin, perlin_tc1).xy;
	vec2 perlin_2 = g_texPerlin.Sample(g_samplerPerlin, perlin_tc2).xy;

	vec2 perlin = (perlin_0 * g_PerlinGradient.x + perlin_1 * g_PerlinGradient.y + perlin_2 * g_PerlinGradient.z);

	// --------------- Water body color
	// Texcoord mash optimization: Texcoord of FFT wave is not required when blend_factor > 1
	vec2 fft_tc = (blend_factor > 0) ? In.texCoords : 0;

	vec2 grad = (g_texGradient.Sample(g_samplerGradient, fft_tc).xy + g_texGradient.Sample(g_samplerGradient, fft_tc / 3.5).xy) / 2.0;
	grad = lerp(perlin, grad, blend_factor);

	// Calculate normal here.
	vec3 normal = normalize(vec3(grad.x, grad.y, g_TexelLength_x2));

	//Caluclate refraction
	float actualDepth = 0.0;
	float tempsample = 0.0;
	float offset = 0.0;
	vec3 refract_vec = vec3(0.0,0.0,0.0);
	vec3 viewNormal = vec3(0.0, 0.0, 0.0);
	if (g_enableRefraction)
	{
		if (g_PassNo == 1)
		{
			tempsample = g_texDepth.Sample(wrapSamplerState, TexCoord*g_DepthScale);
		}
		else
		{
			tempsample = g_waterStencil.Sample(wrapSamplerState, TexCoord*g_DepthScale);
		}
		float fulldepth = depthToFadeDistance(tempsample, vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w), dis, g_HalfTan);
		vec3 eyeViewVec = vec3(0.0, 0.0, 1.0);

		if (!frontFacing)
		{			
			actualDepth = fulldepth - surfaceDepth;

			if (actualDepth > 0.0)
			{
				viewNormal = mul( vec4(normal, 0.0), g_matWorldViewProj);
				refract_vec = normalize(refract(eyeViewVec, viewNormal, 1.0 / 1.33));

				float cosangle = acos(dot(eyeViewVec, refract_vec) / (length(eyeViewVec) * length(refract_vec)));
				offset = tan(cosangle) *(actualDepth / fulldepth);
				TexCoord += offset * (normalize(refract_vec.xy) * g_screenScale);
			}
			else {
				actualDepth = 0.0;
				//discard;
			}
		}
		else
		{
			actualDepth = min(fulldepth, surfaceDepth);

			if (actualDepth == surfaceDepth)
			{
				viewNormal = mul(vec4(-normal, 0.0), g_matWorldViewProj);
				refract_vec = normalize(refract(eyeViewVec, viewNormal, 1.0 / 1.33));

				float cosangle = acos(dot(-eyeViewVec, refract_vec) / (length(eyeViewVec) * length(refract_vec)));
				offset = tan(cosangle) *((fulldepth - surfaceDepth) / fulldepth);
				TexCoord += offset *(normalize(refract_vec.xy) * g_screenScale);
			}
		}
	}

	TexCoord = clamp(TexCoord, vec2(0.0, 0.0), vec2(0.99,0.99));
	float subsurfaceSample;
	if (g_PassNo == 1)
	{
		subsurfaceSample = g_texDepth.Sample(clampSamplerState, TexCoord*g_DepthScale);
	}
	else
	{
		subsurfaceSample = g_waterStencil.Sample(clampSamplerState, TexCoord*g_DepthScale);
	}
	float subsurfaceDepth = depthToFadeDistance(subsurfaceSample, vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w), dis, g_HalfTan);

	if (subsurfaceDepth < surfaceDepth)
	{
		TexCoord = (vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w) + vec2(1.0, 1.0)) / 2.0;
		subsurfaceDepth = depthToFadeDistance(tempsample, vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w), dis, g_HalfTan);
	}

	//else if (g_enableRefraction)
		//TexCoord = lerp(TexCoord, ((vec2(In.SurePosition.x / In.SurePosition.w, In.SurePosition.y / -In.SurePosition.w) + vec2(1.0, 1.0)) / 2.0), exp(tempsample - subsurfaceSample) );

	float backfaceOccluded = 0.0;
	float finalDepth;
	
	if (frontFacing)
	{
		finalDepth = -min(actualDepth, surfaceDepth);
		if (subsurfaceDepth > actualDepth) {
			backfaceOccluded = 1.0;
		}		
	}
	else {
		if (subsurfaceDepth > surfaceDepth) {
			finalDepth = subsurfaceDepth - surfaceDepth;
		}
		else
		{
			finalDepth = 0.0;
		}
	}
	if (!g_enableRefraction)
	{
		actualDepth = finalDepth;
	}

	float eyeDepth;

	if (length(g_boundedDimension) == 0.0)
	{
		eyeDepth = g_LocalEye.z / 300000.0;
	}
	else
	{
		eyeDepth = (g_LocalEye.z - g_boundedLocation.z)  / 300000.0;
	}

	//if (actualDepth == 0)
		//discard;

	if (length(g_boundedDimension) == 0.0) //Make sure foam only generated for the ocean.
	{
		foamValue = g_foamAlpha.Sample(wrapSamplerState, In.texCoords).x * (g_foamTexture.Sample(wrapSamplerState, In.texCoords / 400.0) / 14.0);
		float bubbles = g_foamTexture.Sample(wrapSamplerState, In.texCoords * 4);
		float foamColour = 1.0 - bubbles;
		foamValue *= foamColour;
		if ((bubbles * bubbles) / 3.0 > foamValue)
			foamValue = 0.0;
	}

	float4 refractColour =  g_texColour.Sample(clampSamplerState, TexCoord*g_DepthScale); //vec4(offset,0.0, 0.0,0.0); //

	Output.Scattering = vec4(g_scattering, foamValue);
	Output.Absorption = vec4(g_absorption, g_temperature);
	Output.RefractColour = refractColour;
	Output.Normals = vec4(normal, backfaceOccluded);
	Output.Depth = vec4(finalDepth, actualDepth, eyeDepth, min(subsurfaceDepth, surfaceDepth));

	return Output;
}

shader float4 WaterSurfFinalPS(posTexVertexOutput In) : SV_Target
{
	float4 depthInput = g_waterDepth.Sample(wrapSamplerState, In.texCoords);
	float4 absorptionInput = g_waterAbsorption.Sample(wrapSamplerState, In.texCoords);
	float4 scatteringInput = g_waterScattering.Sample(wrapSamplerState, In.texCoords);
	float4 normalsInput = g_waterNormals.Sample(wrapSamplerState, In.texCoords);
	float4 refractColourInput = g_waterRefractColour.Sample(wrapSamplerState, In.texCoords);
	float waterDepth = depthInput.x;
	float scatterDepth = 0.0;
	float temperature = absorptionInput.w;
	float salinity = scatteringInput.w;
	float fadeDistance = 300000;

	//Discard occluded fragments
	if (depthInput.y == 0.0)
		discard;
	
	if (waterDepth == 0.0)
		waterDepth = depthInput.y;

	//return refractColourInput;

	vec4 clip = vec4((In.texCoords.x * 2) - 1, ((1 - In.texCoords.y) * 2) - 1, 1.0, 1.0);
	vec4 v = mul(g_matInvViewProj, clip);
	vec3 eye_dir = normalize(v.xyz / v.w);
	vec3 sun_dir = normalize(g_SunDir);

	// Set normal here.
	vec3 normal = normalsInput.xyz;//normalize(vec3(grad.x, grad.y, g_TexelLength_x2));

	float4 Output = vec4(0.0,0.0,0.0,0.0);

	//SSS calculations
	float p = 0.079577;

	//vec3 scattering = vec3(0.0007, 0.0013, 0.002); //Pure water scattering
	vec3 scattering = scatteringInput.xyz;//vec3(0.17, 0.2, 0.234); //Ocean scattering
	vec3 absorption = absorptionInput.xyz;//vec3(0.2916, 0.0474, 0.0092);
	vec3 extinction = scattering + absorption;
	vec3 albedo = scattering / extinction;

	float sunAngle = dot(sun_dir, vec3(0.0, 0.0, 1.0)) / (length(sun_dir) * length(vec3(0.0, 0.0, 1.0)));
	
	//Camera is below the water
	if (waterDepth < 0.0)
	{
		waterDepth *= -1.0;
		float eye_depth = abs(depthInput.z);
		float pointDepth = 0.0;
		
		if (normalsInput.w == 0.0) //Depth hits a solid surface first
		{
			if (eye_dir.z < 0.0)
			{
				pointDepth = eye_depth + abs(waterDepth * dot(eye_dir, vec3(0.0, 0.0, -1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, -1.0))));
			}
			else
			{
				pointDepth = eye_depth - abs(waterDepth * sin((PI / 2.0) - acos(dot(eye_dir, vec3(0.0, 0.0, 1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, 1.0))))));
			}
			if ((g_SunDir.z >= 0.0))
			{
				
				scatterDepth = pointDepth / sunAngle;
			}
			else
			{
				scatterDepth = pointDepth;
			}
		}
		else {
			refractColourInput += vec4(scatteringInput.w, scatteringInput.w, scatteringInput.w, 0.0);
			scatterDepth = eye_depth;
		}

		float A = acos(dot(sun_dir, vec3(0.0, 0.0, 1.0)) / (length(sun_dir) * length(vec3(0.0, 0.0, 1.0))));
		float B = acos(dot(eye_dir, -vec3(0.0, 0.0, 1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, 1.0))));
		float c = 1.0;// (sin(A) / sin(B));

		float refractFresnel = 1.0;

		float sunEffect = ((dot(eye_dir, g_SunDir) + 1.0) / 2.0);
		if (sun_dir.z < 0)
			sunEffect = 0.0;

		if (normalsInput.w)
		{
			refractFresnel = fresnel(eye_dir, -normal, 1.0, 1.33);
			if (!length(refractFresnel))
				refractColourInput = vec4(sunEffect, sunEffect, sunEffect, sunEffect);
		}
		
		vec3 incomingRadiance = exp(-extinction * scatterDepth * fadeDistance * c ) * g_SunColor;
		vec4 surfaceScattering = vec4(g_SunColor * exp(-fadeDistance * (eye_depth / sunAngle) * extinction), 0.0);
		vec4 mult = vec4(exp(-extinction * (waterDepth + scatterDepth) * fadeDistance) * refractColourInput, 0.0);
		vec4 SSS = vec4((albedo * (p / (1 + c)) * saturate(1 - (exp(-extinction * (1 + c)  * fadeDistance * waterDepth* incomingRadiance) ))), 0.0);

		Output += mult;
		//Output += SSS;
		Output += (surfaceScattering * SSS * sunEffect);
		return Output;
	}

	float A = acos(dot(sun_dir, vec3(0.0, 0.0, 1.0)) / (length(sun_dir) * length(vec3(0.0, 0.0, 1.0))));
	float B = acos(dot(eye_dir, vec3(0.0, 0.0, 1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, 1.0))));
	float c = 1.0; //(sin(A) / sin(B));

	float pointDepth = abs(waterDepth * (dot(eye_dir, vec3(0.0, 0.0, -1.0)) / (length(eye_dir) * length(vec3(0.0, 0.0, -1.0)))));
	if ((g_SunDir.z >= 0.0))
	{
		float sunAngle = dot(-sun_dir, vec3(0.0, 0.0, -1.0)) / (length(-sun_dir) * length(vec3(0.0, 0.0, -1.0)));
		scatterDepth = pointDepth / sunAngle; //Water Depth to the sun
	}
	else {
		scatterDepth = pointDepth;
	}

	vec3 reflect_vec = reflect(eye_dir, normal);
	float sunEffect = (dot(reflect_vec, sun_dir) + 1.0) / 2.0;
	if (sun_dir.z < 0)
		sunEffect = 0.0;
	vec3 incomingRadiance = exp(-extinction * scatterDepth * fadeDistance * scattering) * g_SunColor;
	vec4 surfaceScattering = vec4(g_SunColor * exp(-fadeDistance * scatterDepth * extinction) * sunEffect, 0.0);
	vec4 mult = vec4(exp(-extinction * (waterDepth + scatterDepth) * fadeDistance) *refractColourInput, 0.0);
	vec4 SSS = vec4((albedo * (p / (1 + c)) * saturate(1 - (exp(-extinction * (1 + c)  * fadeDistance * waterDepth) * incomingRadiance))), 0.0);

	// --------------- Sun spots
	float cos_spec = dot(normalize(reflect_vec), sun_dir);
	float sun_spot = pow(cos_spec, g_Shineness);
	vec4 sunSpec = max(vec4(g_SunColor * sun_spot * sun_spot * sun_spot, 0.0), 0.0);
	//if (length(sunSpec) < 1.0)
		//sunSpec = vec4(0.0, 0.0, 0.0, 0.0);

	// --------------- Reflected colour
	vec3 refl = texture_cube_lod(g_texReflectCube,reflect_vec.yxz, 0);
	float reflectFresnel = fresnel(-reflect_vec, normal, 1.0, 1.33);
	float sunFresnel = fresnel(-sun_dir, normal, 1.0, 1.33);

	//vec3 h = normalize(-eye_dir + sun_dir);
	//sunSpec = vec4( g_SunColor * (sunFresnel / (4 * pow(h , 4) * (eye_dir * normal) * dot(normalize(reflect_vec), sun_dir))), 0.0);
	
	Output += mult;
	//Output += SSS;
	Output += SSS * sunEffect;
	Output += sunSpec * sunFresnel;
	// --------------- Foam colour
	if (scatteringInput.w > 0.0)
	{
			//refl -= vec3(scatteringInput.w, scatteringInput.w, scatteringInput.w);
			vec3 foamEffect = vec3(scatteringInput.w * g_SunColor * clamp(dot(normal, g_SunDir), 0.1, 1.0));
			Output += vec4(foamEffect, scatteringInput.w);
	}

	Output += vec4(refl, 1.0) * reflectFresnel;

	return Output;
}

shader float4 CopyDepthStencilPS(posTexVertexOutput In) : SV_Target
{
	float4 Output = g_texDepth.Sample(wrapSamplerState, In.texCoords);
	return Output;
}

shader float4 UpdateFoamAlphaPS(posTexVertexOutput In) : SV_Target
{
	float foam = 0.00;
	float alpha = 0.97;
	float displacement = g_texDisplacement.Sample(g_samplerGradient, In.texCoords).z;

	float derivativeX = ddx(displacement);
	float derivativeY = ddy(displacement);

	if (displacement > g_foamHeight)
	{
		if (derivativeY < 0.0001)
		{
			foam += 1.0;// 1.0 - (derivativeY * 10000);
			alpha = 1.0;
		}

		if (derivativeX < 0.0001)
		{
			foam += 1.0;// 1.0 - (derivativeX * 10000);
			alpha = 1.0;
		}
	}
	if ((foam < 1.0) && (displacement >= g_foamChurn))
	{
		//foam = (displacement - g_foamChurn) / 10.0;
		//alpha = 0.95;
	}
	return float4(foam / 2.0, 0.0, 0.0, alpha);
}

shader float4 WireframePS(VS_OUTPUT IN) : SV_Target
{
	return IN.vecColour;
}

shader posTexVertexOutput VS_ShowTexture(idOnly id)
{
	return VS_ScreenQuad(id,rect);
}

shader vec4 PS_ShowTexture( posTexVertexOutput IN):SV_TARGET
{
	vec4 lookup=showTexture.Sample(wrapSamplerState,IN.texCoords.xy);
	return vec4(showMultiplier*lookup.rgb,1.0);
}

technique water_final_pass
{
	pass p0 
	{
		SetRasterizerState( RenderNoCull );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, WaterSurfFinalPS()));
	}
}

technique copy_stencil
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, CopyDepthStencilPS()));
	}
}

technique show_texture
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTexture()));
	}
}

technique show_frequency_structured_buffer
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowFrequencyStructuredBuffer()));
	}
}
technique show_spatial_structured_buffer
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_ShowTexture()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_ShowSpatialStructuredBuffer()));
	}
}

technique wireframe_ocean
{
	pass p0 
	{
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState(TestReverseDepth, 0 );
		SetBlendState(AddBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,OceanSurfVS()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,WireframePS()));
	}
}

technique wireframe_bounded
{
	pass p0
	{
		SetRasterizerState(wireframeRasterizer);
		SetDepthStencilState(TestReverseDepth, 0);
		SetBlendState(AddBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, BoundedWaterSurfVS()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, WireframePS()));
	}
}

technique render_boundless_depth
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(ReverseDepth, 0 );
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0,OceanSurfVS()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_WaterSurfDepth()));
	}
}

technique render_bounded_depth
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(ReverseDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 1.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, BoundedWaterSurfVS()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, PS_WaterSurfDepth()));
	}
}

technique update_foam
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetBlendState(FoamBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetVertexShader(CompileShader(vs_5_0, VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0, UpdateFoamAlphaPS()));
	}
}

technique generate_heightmap
{
	pass p0
	{
		SetComputeShader(CompileShader(cs_5_0, GenerateHeightMapCS()));
	}
}

technique update_spectrum
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,UpdateSpectrumCS()));
	}
}

technique radix_008a
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,Radix008A_CS()));
	}
}


technique radix_008a2
{
	pass p0 
	{
		SetComputeShader(CompileShader(cs_5_0,Radix008A_CS2()));
	}
}


technique update_displacement
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,UpdateDisplacementPS()));
	}
}

technique gradient_folding
{
	pass p0
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,GenGradientFoldingPS()));
	}
}


	