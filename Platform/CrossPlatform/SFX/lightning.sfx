//  Copyright (c) 2015-2018 Simul Software Ltd. All rights reserved.

#include "shader_platform.sl"

#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/lightning_constants.sl"
#include "../SL/depth.sl"
#include "../SL/render_states.sl"
#include "../SL/noise.sl"

uniform TextureCube cloudDepthTexture 					SIMUL_TEXTURE_REGISTER(0);
uniform Texture2D randomTexture 						SIMUL_TEXTURE_REGISTER(1);	
uniform Texture2D depthTexture 							SIMUL_TEXTURE_REGISTER(2);
uniform StructuredBuffer<LightningVertex> 	vertices;
uniform RWStructuredBuffer<LightningVertex> verticesRW;
 
shader vec4 PS_Random(posTexVertexOutput IN) : SV_TARGET
{
	vec4 c=2.0*vec4(rand(IN.texCoords),rand(1.7*IN.texCoords),rand(0.11*IN.texCoords),rand(513.1*IN.texCoords))-1.0;
    return c;
}

CS_LAYOUT(1, 1, 1)
shader void CS_InitialFractal(uint3 idx : SV_DispatchThreadID)
{
	int MAX_OCTAVES = 7;
	vec3 off		= vec3(1.0,1.0,1.0)*roughness;
	float t 		= phaseTime;
	int steps 		= 1 << MAX_OCTAVES; // 128
	int delta 		= steps;

	// Setup and array to hold all the tmp vertices:
	vec3 outpos[129];
	outpos[0]		= startPos;
	outpos[steps]	= endPos;

	// Mid point displacement over MAX_OCTAVES
	for(int i = 0; i < MAX_OCTAVES; i++)
	{
		for(int j = int(delta*0.5); j < steps; j += delta)
		{
			vec3 start = outpos[j - int(delta * 0.5)];
			vec3 end   = outpos[j + int(delta * 0.5)];

			vec3 XX	   =cross(vec3(1.0,0.0,0.0),(start-end));
			vec3 YY	   =cross(vec3(0.0,1.0,0.0),(start-end));

			vec2 ntc  = vec2(9.3*float(j+randomSeed)+t,3.1*float(i)+4.5*float(j));
			vec4 nlk  = texture_wrap_lod(randomTexture,ntc,0);

			vec3 mid 	= 0.5 * (start + end);
			float angle	= nlk.x*2.0*3.14159;
			// Add random rotation
			mid			+=off * nlk.y * (XX * cos(angle) + YY * sin(angle));

			outpos[j]	= mid;
		}
		delta	= int(delta * 0.5);
		t		*= 2.0;
	}

	LightningVertex OUT;
	float rsteps = 1.0 / float(steps);
	for(int ii = 0; ii < 129; ii++)
	{
		OUT.position   	= outpos[ii];
		OUT.texCoords	= vec2(strikeThicknessMetres,brightness);
		OUT.progress	= float(ii) * rsteps;
		verticesRW[ii] 	= OUT;
	}
}

CS_LAYOUT(1, 1, 1)
shader void CS_BranchFractal(uint3 idx : SV_DispatchThreadID)
{
	int MAX_OCTAVES_BRANCH 	= 5;
	int steps				= 1 << MAX_OCTAVES_BRANCH;  // 32
	int numVtx				= steps + 1; 				// 33
	int delta 				= steps;

	LightningVertex OUT; 	
 	LightningVertex IN0;
 	LightningVertex IN1;

 	// Parent level is trunk
 	if(curLevel == 1)
 	{
 		int rndStart 	= int(rand(idx.x + randomSeed) * 90.0);
 		IN0 			= vertices[rndStart];
		IN1 			= vertices[128];
 	}
 	// Parent level is another branch
 	else
 	{
 		// Find the parent branch offset
 		// numBranches = the requested number of branches (storm properties)
 		int parentBranchOff = int(idx.x  / numBranches) * numVtx;
 		int rndStart 		= int(rand(idx.x + randomSeed) * 33.0);
 		rndStart			= clamp(rndStart,0,31);
 		IN0 				= vertices[parentBranchOff + rndStart];
		IN1 				= vertices[parentBranchOff + 32];
 	}

	vec3 startP				= IN0.position;
	vec3 parentEndP			= IN1.position;

	// This is the direction of the parent branch
	vec3 parentDir			= normalize(parentEndP - startP);
	// Now we will create a random vector from it
	vec2 noise_texc			= vec2( 0.3 * float(branchInterval) * float(randomSeed * (idx.x + 1))+0.77 * float(parent_point),1.92 * float(branchInterval) + 0.34 * float(parent_point));
	vec3 rndvec				= texture_wrap_lod(randomTexture,noise_texc,0).xyz;
	float along				= dot(rndvec,parentDir);
	rndvec			        -= along * parentDir;
	rndvec					= normalize(rndvec);
	vec3 dir				= parentDir * cos(branchAngleRadians) + rndvec * sin(branchAngleRadians);
	dir						= normalize(dir);
	
	// Create a end point along the random direction:
	float randLen 			= rand(randomSeed * (idx.x + 1)) * branchLengthMetres;
	randLen					+= branchLengthMetres * 0.25; // smallest branch 1/4 of the lenght
	randLen 				= min(branchLengthMetres,randLen);
	vec3 endP				= startP + dir * randLen;
	endP.z 					= max(endP.z,0.0);

	vec3 outpos[33];
	outpos[0]				= startP;
	outpos[steps]			= endP;

	float persistence	= 0.8;
	float time			= phaseTime;
	vec3 off 			= vec3(1.0,1.0,1.0)*roughness;

	// Mid point displacement over MAX_OCTAVES_BRANCH
	for(int i = 0; i < MAX_OCTAVES_BRANCH; i++)
	{
		for(int j = int(delta * 0.5); j < steps; j += delta)
		{
			vec3 s 				= outpos[j - int(delta * 0.5)];
			vec3 e 				= outpos[j + int(delta * 0.5)];
			vec3 XX 			= cross(vec3(1.0,0.0,0.0),(s-e));
			vec3 YY 			= cross(vec3(0.0,1.0,0.0),(s-e));
			vec3 x 				= 0.5*(s+e);

			vec2 noise_texc		= vec2(9.3*float(j+randomSeed)+time,3.1*float(i)+4.5*float(j));
			vec4 noise_lookup	= texture_wrap_lod(randomTexture,noise_texc,0);
			float angle			= noise_lookup.x*2.0*3.14159;
			x 					+=off*(XX*cos(angle)+YY*sin(angle));

			outpos[j]			= x;
		}
		delta  	= int(delta * 0.5);
		time 	*= 2.0;
	}

	// Store the vertices
	float rsteps = 1.0 / float(steps);
	for(int ii = 0; ii < numVtx; ii++)
	{
		OUT.position 	= outpos[ii];
		OUT.progress 	= float(ii) * rsteps;
		OUT.texCoords 	= vec2(0,0);
		verticesRW[ii + (numVtx * idx.x)] = OUT;
	}
}

technique initial_fractal
{
    pass main
    {
        SetComputeShader(CompileShader(cs_5_0, CS_InitialFractal()));
    }
}

technique branch_fractal
{
    pass main
    {
		SetComputeShader(CompileShader(cs_5_0, CS_BranchFractal()));
    }
}

struct transformedVertex
{
    vec4 hPosition		: SV_POSITION;
	float brightness	: TEXCOORD0;
    vec2 hPosCentre1	: TEXCOORD1;
    vec2 hPosCentre2	: TEXCOORD2;
	vec2 screenPos		: TEXCOORD3;
	vec2 texc			: TEXCOORD4;
    float along			: TEXCOORD5;
	float clipWidth		: TEXCOORD6;
    vec4 clipPos		: TEXCOORD7;
    float endpoint		: TEXCOORD8;
    float progress		: TEXCOORD9;
	vec3 view			: TEXCOORD10;
};

struct transformedThinVertex
{
    vec4 hPosition		: SV_POSITION;
	float brightness	: TEXCOORD0;
    float depth			: TEXCOORD1;
	vec2 screenPos		: TEXCOORD2;
	vec2 texc			: TEXCOORD3;
	float progress		: TEXCOORD4;
	vec3 view			: TEXCOORD5;
};

shader transformedThinVertex VS_Thin(idOnly id)
{
	transformedThinVertex OUT;

    int idx 			=int(id.vertex_id + branchIndex);
    LightningVertex IN 	=vertices[idx];
	
    OUT.hPosition		=mul(worldViewProj, vec4(IN.position.xyz , 1.0));
	OUT.view			=normalize(viewPosition - IN.position.xyz);
	OUT.brightness		=IN.texCoords.y*10.0;
	OUT.depth			=OUT.hPosition.z/OUT.hPosition.w;
	OUT.screenPos		=OUT.hPosition.xy/OUT.hPosition.w;
	OUT.texc			=OUT.screenPos.xy*0.5+0.5;
	OUT.progress		=IN.progress;

    return OUT;
}

vec2 PixelPos(vec4 vertex)
{
	vec2 p = vec2(vertex.xy / vertex.w)*viewportPixels;
	return p;
}

shader transformedVertex VS_Thick(idOnly id)
{
	LightningVertex IN[4];
	vec4 hPos[4];
	int vertex_id = int(id.vertex_id /2);
	int left_right = int(id.vertex_id % 2);
	for (int i = 0; i < 4; i++)
	{
		IN[i] = vertices[vertex_id + i];
		hPos[i] = mul(worldViewProj, vec4(IN[i].position.xyz, 1.0));
	}
	transformedVertex OUT;

    OUT.hPosition			=mul(worldViewProj,vec4(IN[0].position.xyz,1.0));
	OUT.view				=normalize(viewPosition - IN[0].position.xyz);
	float thicknessMetres	=IN[0].texCoords.x;
	float endpoint		=saturate(1.0-IN[1].texCoords.y);
	OUT.brightness		= IN[0].texCoords.y;
	OUT.progress		= IN[0].progress;
	float depth			= OUT.hPosition.z/OUT.hPosition.w;
    //  a - - - - - - - - - - - - - - - - b
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  | - - -start - - - - - - end- - - |
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  d - - - - - - - - - - - - - - - - c
	vec2 p0		=PixelPos(hPos[0]);
	vec2 p1		=PixelPos(hPos[1]);
	vec2 p2		=PixelPos(hPos[2]);
	vec2 p3		=PixelPos(hPos[3]);
	vec2 area	=viewportPixels * 1.2;
	//if((p1.x<-area.x&&p2.x<-area.x)||(p1.x>area.x&&p2.x>area.x)) return;
	//if((p1.y<-area.y&&p2.y<-area.y)||(p1.y>area.y&&p2.y>area.y)) return;
	//if(IN[0].position.z<0) return;
    vec4 start			=hPos[1];
    vec4 end			=hPos[2];
	// determine the direction of each of the 3 segments (previous, current, next
	vec2 v0				=normalize(p1-p0);
	vec2 v1				=normalize(p2-p1);
	vec2 v2				=normalize(p3-p2);
	// determine the normal of each of the 3 segments (previous, current, next)
	vec2 n0				=vec2(-v0.y,v0.x);
	vec2 n1				=vec2(-v1.y,v1.x);
	vec2 n2				=vec2(-v2.y,v2.x);
	// determine mitre lines by averaging the normals of the 2 segments
	vec2 mitre1			=normalize(n0 + n1);	// mitre at start of current segment
	vec2 mitre2			=normalize(n1 + n2);	// mitre at end of current segment
	// determine the length of the mitre by projecting it onto normal and then inverse it

	//We want to have an output brightness*pixelWidth as specified according to thicknessMetres and input brightness.
	// so K=IN[1].brightness*(width1/start.w	*viewportPixels.x)
	// But: first we have a minimum pixel width. So if (width1/start.w	*viewportPixels.x)<minPixelWidth, we want brightness=K/minPixelWidth
	// And second we have a maximum output brightness, so if brightness>maxBrightness, we want pixelWidth=K/maxBrightness
	float l					=length(p2-p1);
	float t1				=min(0.5*l,thicknessMetres);
	float t2				=min(0.5*l,thicknessMetres);
	float truePixelWidth1	=(t1/start.w*viewportPixels.x);
	float truePixelWidth2	=(t2/start.w*viewportPixels.x);
	float K1				=IN[1].texCoords.y*truePixelWidth1;
	float K2				=IN[2].texCoords.y*truePixelWidth2;
	float brightness1		=IN[1].texCoords.y;
	float brightness2		=IN[2].texCoords.y;

	float width1			=t1;
	float width2			=t2;
	float maxBrightness		=1000.0;
	// Overbright? Make pixel width larger:
	if(brightness1>maxBrightness)
	{
		width1				*=brightness1/maxBrightness;
		brightness1			=maxBrightness;
	}
	if(brightness2>maxBrightness)
	{
		width2				*=brightness2/maxBrightness;
		brightness2			=maxBrightness;
	}
	//pixel size too small? make it up to the minimum, but scale down the brightness:
	if(width1<minPixelWidth/viewportPixels.x*start.w)
	{
		brightness1			*=width1/(minPixelWidth/viewportPixels.x*start.w);
		width1				=minPixelWidth/viewportPixels.x*start.w;
	}
	if(width2<minPixelWidth/viewportPixels.x*start.w)
	{
		brightness2			*=width2/(minPixelWidth/viewportPixels.x*start.w);
		width2				=minPixelWidth/viewportPixels.x*start.w;
	}
	float lengthPixels_a	=width1/start.w	*viewportPixels.x/dot(mitre1, n1);

	// To-DO: The max clamp is just harcoded, find a proper metric for it
	lengthPixels_a 			= clamp(lengthPixels_a,minPixelWidth	,10.0);

	float	mitre_LIMIT	=0.0;
	OUT.hPosCentre1		=vec2(p1.xy/viewportPixels);
	OUT.hPosCentre2		=vec2(p2.xy/viewportPixels);
	OUT.clipWidth		=width1/start.w;
	vec2 diff				=OUT.hPosCentre2-OUT.hPosCentre1;
	float dist				=length(diff);
	float d2				=dist*dist;
	// prevent excessively long mitres at sharp corners
	vec2 mitre1_a=mitre1;
	vec2 mitre1_b=mitre1;

	// Calc screen position:
	if (left_right == 0)
	{
		OUT.screenPos = (p1 + lengthPixels_a * mitre1_a) / viewportPixels;
	}
	else
	{
		OUT.screenPos = (p1 - lengthPixels_a * mitre1_b) / viewportPixels;
	}

	// Fill the rest of the out struct:
	OUT.hPosition 	= vec4(OUT.screenPos.xy*start.w, start.z, start.w);
	OUT.texc 		= OUT.screenPos.xy * 0.5 + 0.5;
	OUT.along 		= 0.0;
	OUT.brightness 	= brightness1;
	OUT.endpoint 	= endpoint;
	OUT.progress 	= IN[1].progress;
	OUT.clipPos 	= OUT.hPosition;

	return OUT;
}

vec4 PS_Main(transformedVertex IN,bool reverseDepth)
{
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	
	vec2 texc				=vec2(IN.texc.x,1.0-IN.texc.y);
	vec2 screen_texc		=vec2(0.5*(IN.clipPos.x/IN.clipPos.w+1.0),0.5*(1.0-IN.clipPos.y/IN.clipPos.w));
	vec2 depth_texc			=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
	vec4 dlookup 			=texture_clamp(depthTexture,depth_texc.xy);
	vec3 view				=normalize(IN.view);
	vec4 nearFarCloud 		=texture_cube_lod(cloudDepthTexture,view,0);
	vec4 clip_pos			=vec4(IN.screenPos,1.0,1.0);
	float l_depth			=IN.clipPos.z/IN.clipPos.w;
	vec2 dist				=depthToFadeDistance(vec2(l_depth,dlookup.x),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);

	float past				=saturate((nearFarCloud.w-dist.x)/0.008+1.0);
	past					*=saturate((dist.y-dist.x)/0.01-0.9);
	
	vec2 dir				=normalize(IN.hPosCentre2-IN.hPosCentre1);
	float along				=dot(IN.screenPos-IN.hPosCentre1,dir);
	vec2 centre1			=lerp(IN.hPosCentre1,IN.hPosCentre2,saturate(IN.along));
	vec2 centre2			=lerp(IN.hPosCentre1,IN.hPosCentre2,saturate(along));
	vec2 diff1				=IN.screenPos-centre1;
	vec2 diff2				=IN.screenPos-centre2;
	float clipWidth2px		=minPixelWidth/float(viewportPixels.x);
	float d					=min(length(diff1),length(diff2));
	float m					=d/clipWidth2px;
	float s					=max(0.0,d-clipWidth2px)/IN.clipWidth;
	
	float br				=saturate(2.0*(1.0-m));
	br						+=brightnessToUnity*saturate(exp(-4.0*s)-0.05)/0.95;
	br						*=IN.brightness;
	br						*=saturate((exp(-4.0*s)-0.05)/0.95);
	if(progress>0.0)
	{
		float p				=abs(IN.progress-progress);
		s*=4;
		// brightness max is 1/10th of full strike brightness, say.
		float a				=0.1*saturate(100.0*(progress-IN.progress)-3.0);
	//	br					*=saturate((exp(-4.0*s)-0.05)/0.95);
		float b				=10.0*exp(-p*p/0.0001);
		br					*=a+b;
	}
	br*=past;
	if(br<0)
		br=0;
	br 				= brightness * saturate(past) * 0.05;
	vec4 colour		= vec4(br*lightningColour.rgb,1.0);
    return colour;
}

shader vec4 PS_Main_ReverseDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,true);
}

shader vec4 PS_Main_ForwardDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,false);
}

vec4 PS_Thin(transformedThinVertex IN,bool reverseDepth)
{
	vec2 texc 				=vec2(IN.texc.x,1.0-IN.texc.y);
	vec4 dlookup 			=texture_clamp(depthTexture,texc.xy);
	vec3 view				=normalize(IN.view);
	vec4 nearFarCloud 		=texture_cube_lod(cloudDepthTexture,view,0);

	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;

	vec2 dist				=depthToFadeDistance(vec2(IN.depth,dlookup.x),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);
	float past				=saturate((nearFarCloud.w-dist.x)/0.008+1.0);
	past					*=saturate((dist.y-dist.x)/0.01-0.9);

	vec4 colour				= vec4(lightningColour * IN.brightness * 100.0 ,1.0);	
	colour.rgb 				= lightningColour * brightness * saturate(past) * 0.25;
	float f 				= pow(1.0 - IN.progress,1.5);
    return colour * f;
}

shader vec4 PS_Thin_ReverseDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,true);
}

shader vec4 PS_Thin_ForwardDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,false);
}

BlendState MaxBlend
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1]	=TRUE;
	SrcBlend		=ONE;
	DestBlend		=ONE;
	BlendOp			=MAX;
	RenderTargetWriteMask[0]=7;
	RenderTargetWriteMask[1]=7;
};

technique lightning_thick
{
    pass reverse_depth 
    {
		SetDepthStencilState(DisableDepth, 0);
        SetRasterizerState(RenderNoCull);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ReverseDepth()));
    }
    pass forward_depth 
    {
		SetDepthStencilState(DisableDepth, 0);
        SetRasterizerState(RenderNoCull);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ForwardDepth()));
    }
}
RasterizerState lightningLineRasterizer
{
	FillMode					= WIREFRAME;
	CullMode					= none;
	FrontCounterClockwise		= false;
	DepthBias					= 0;//DEPTH_BIAS_D32_FLOAT(-0.00001);
	DepthBiasClamp				= 0.f;
	SlopeScaledDepthBias		= 0.f;
	DepthClipEnable				= false;
	ScissorEnable				= false;
	MultisampleEnable			= true;
	AntialiasedLineEnable		= false;
};

technique lightning_thin
{
    pass reverse_depth 
    {
    	SetDepthStencilState(DisableDepth, 0);
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ReverseDepth()));
    }
    pass forward_depth 
    {
    	SetDepthStencilState(DisableDepth, 0);
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ForwardDepth()));
    }
}

technique random
{
    pass p0 
    {
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth,0);
		SetBlendState(NoBlend,vec4(1.0,1.0,1.0,1.0),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,PS_Random()));
    }
}