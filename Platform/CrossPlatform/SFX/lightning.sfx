#include "shader_platform.sl"
#include "../../CrossPlatform/SL/common.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/lightning_constants.sl"
#include "../../CrossPlatform/SL/depth.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/noise.sl"

Texture2D lightningTexture;
Texture2D depthTexture;
Texture2DMS<vec4> depthTextureMS;
Texture2D cloudDepthTexture;
Texture2D randomTexture;

shader vec4 PS_Random(posTexVertexOutput IN) : SV_TARGET
{
	// Range from -1 to 1.
	vec4 c=2.0*vec4(rand(IN.texCoords),rand(1.7*IN.texCoords),rand(0.11*IN.texCoords),rand(513.1*IN.texCoords))-1.0;
	//vec4 c=vec4(SphericalRandom(IN.texCoords),2.0*rand(513.1*IN.texCoords)-1.0);
    return c;
}

struct F_Vertex
{
    vec3 position	: POSITION;
    vec2 texcoord	: TEXCOORD0;
};

struct F_IdVertex
{
    vec3 position	: POSITION;
    vec2 texcoord	: TEXCOORD0;
	uint vertex_id	: TEXCOORD1;
};

struct F_Vertex_out
{
    vec4 hPosition	: SV_Position;
};

shader F_Vertex VS_InitialFractal(idOnly IN )
{
	F_Vertex OUT;
	OUT.texcoord	=vec2(200.0,1.0);
	OUT.position	=lerp(startPos,endPos,float(IN.vertex_id));
	return OUT;
}

[maxvertexcount(129)]
shader void GS_Fractal(line F_Vertex IN[2],inout PointStream<F_Vertex> vStream)
{
	F_Vertex OUT;
	vec3 startP			=IN[0].position;
	vec3 endP			=IN[1].position;
	uint num_octaves	=7;
	uint num_steps		=1<<num_octaves;
	uint num_pts		=num_steps+1;
	vec3 outpos[129];
	outpos[0]			=startP;
	outpos[num_steps]	=endP;
	int del				=num_steps;
	float persistence	=0.8;
	float off			=roughness;
	float time			=phaseTime;
	for(uint i=0;i<num_octaves;i++)
	{
		for(uint j=del/2;j<num_steps;j+=del)
		{
			// j is the index into the list of outputs.
			vec3 s				=outpos[j-del/2];
			vec3 e				=outpos[j+del/2];
			vec3 XX				=cross(vec3(1.0,0.0,0.0),(s-e));
			vec3 YY				=cross(vec3(0.0,1.0,0.0),(s-e));
			vec3 x				=0.5*(s+e);
			vec2 noise_texc		=vec2(9.3*(j+randomSeed)+time,3.1*i+4.5*j);
			vec4 noise_lookup	=texture_wrap_lod(randomTexture,noise_texc,0);
			float angle			=noise_lookup.x*2.0*3.14159;
			x					+=off*noise_lookup.y*(XX*cos(angle)+YY*sin(angle));
			outpos[j]			=x;
		}
		del	/=2;
		time*=2.0;
	//	off	*=persistence;
	}
	for(uint ii=0;ii<num_pts;ii++)
	{
		OUT.position		=outpos[ii];
		OUT.texcoord		=vec2(strikeThicknessMetres,brightness);
		vStream.Append(OUT);
	}
	vStream.RestartStrip();
}

shader F_IdVertex VS_Branch(F_Vertex IN,uint vertex_id	: SV_VertexID)
{
	F_IdVertex OUT;
	OUT.position	=IN.position;
	OUT.texcoord	=IN.texcoord;
	OUT.vertex_id	=vertex_id;
	return OUT;
}

[maxvertexcount(33)]
shader void GS_Branch(line F_IdVertex IN[2], inout PointStream<F_Vertex> vStream)
{
	// do we branch from this point?
	uint parent_point=IN[0].vertex_id;
	//if(parent_point %branchInterval)
	//	return;

	F_Vertex OUT;
	vec3 startP		=IN[0].position;
	vec3 parentEndP	=IN[1].position;
	vec3 parentDir	=normalize(parentEndP-startP);
	// dir is the direction of the main branch.
	// We need to find a direction normal to dir.
	// We will create a random vector, then subtract the part that is in the direction of dir.
	vec2 noise_texc	=vec2(0.3*branchInterval*randomSeed+0.77*parent_point,1.92*branchInterval+0.34*parent_point);
	vec3 rndvec		=texture_wrap_lod(randomTexture,noise_texc,0).xyz;

	float along		=dot(rndvec,parentDir);
	rndvec			-=along*parentDir;
	rndvec			=normalize(rndvec);
	vec3 dir		=parentDir*cos(branchAngleRadians)+rndvec*sin(branchAngleRadians);

	vec3 endP		=startP+dir*branchLengthMetres;

	int num_steps	=1<<num_octaves;
	int num_pts		=num_steps+1;
	vec3 outpos[33];
	outpos[0]			=startP;
	outpos[num_steps]	=endP;
	int del				=num_steps;
	float persistence	=0.8;
	float off			=roughness;
	float time			=phaseTime;
	for(int i=0;i<num_octaves;i++)
	{
		for(int j=del/2;j<num_steps;j+=del)
		{
			vec3 s=outpos[j-del/2];
			vec3 e=outpos[j+del/2];
			vec3 XX=cross(vec3(1.0,0.0,0.0),(s-e));
			vec3 YY=cross(vec3(0.0,1.0,0.0),(s-e));
			vec3 x=0.5*(s+e);
			vec2 noise_texc		=vec2(5.7*i-9.3*j+time,3.1*i+4.5*j);
			vec4 noise_lookup	=texture_wrap_lod(randomTexture,noise_texc,0);
			float angle			=noise_lookup.x*2.0*3.14159;
			x+=off*(XX*cos(angle)+YY*sin(angle));
			outpos[j]=x;
		}
		del/=2;
		//off*=persistence;
		time*=2.0;
	}

	OUT.position		=outpos[0];
	OUT.position		-=dir;
	OUT.texcoord		=vec2(strikeThicknessMetres,1.0);
	vStream.Append(OUT);

	for(int ii=0;ii<num_pts;ii++)
	{
		OUT.position		=outpos[ii];
		float br			=brightness*saturate(float(num_steps-ii)/5.0);
		float endpoint		=(i>(num_steps-2));
		OUT.texcoord		=vec2(strikeThicknessMetres,br);
		vStream.Append(OUT);
	}
	vStream.RestartStrip();
}

VertexShader vs_init		=CompileShader(vs_5_0,VS_InitialFractal());
GeometryShader gs_fractal	=CompileShader(gs_5_0,GS_Fractal());
GeometryShader so_fractal	=ConstructGSWithSO(gs_fractal, "POSITION.xyz;TEXCOORD0.xy");

VertexShader vs_branch		=CompileShader(vs_5_0,VS_Branch());
GeometryShader gs_branch	=CompileShader(gs_5_0,GS_Branch());
GeometryShader so_branch	=ConstructGSWithSO(gs_branch, "POSITION.xyz;TEXCOORD0.xy");

technique initial_fractal
{
    pass main
    {
        SetRasterizerState( RenderNoCull );
        SetVertexShader(vs_init);
        SetGeometryShader(so_fractal);
		SetPixelShader(NULL);
    }
}

technique branch_fractal
{
    pass main
    {
        SetRasterizerState(RenderNoCull);
        SetVertexShader(vs_branch);
        SetGeometryShader(so_branch);
		SetPixelShader(NULL);
    }
}

struct transformedVertex
{
    vec4 hPosition		: SV_POSITION;
	float brightness	: TEXCOORD0;
    vec2 hPosCentre1	: TEXCOORD1;
    vec2 hPosCentre2	: TEXCOORD2;
	vec2 screenPos		: TEXCOORD3;
	vec2 texc			: TEXCOORD4;
    float along			: TEXCOORD5;
	float clipWidth		: TEXCOORD6;
    vec4 clipPos		: TEXCOORD7;
    float endpoint		: TEXCOORD8;
};

struct transformedThinVertex
{
    vec4 hPosition		: SV_POSITION;
	float brightness	: TEXCOORD0;
    float depth			: TEXCOORD1;
	vec2 screenPos		: TEXCOORD2;
	vec2 texc			: TEXCOORD3;
};

shader transformedThinVertex VS_Thin(LightningVertexInput IN)
{
    transformedThinVertex OUT;
    OUT.hPosition	=mul(worldViewProj, vec4(IN.position.xyz , 1.0));
	OUT.brightness	=IN.texCoords.y*10.0;
	OUT.depth		=OUT.hPosition.z/OUT.hPosition.w;
	OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
	OUT.texc		=OUT.screenPos.xy*0.5+0.5;
    return OUT;
}

shader LightningVertexOutput VS_Thick(LightningVertexInput IN)
{
    LightningVertexOutput OUT;
    OUT.position		=mul(worldViewProj,vec4(IN.position.xyz,1.0));
	OUT.thicknessMetres	=IN.texCoords.x;
	OUT.endpoint		=saturate(1.0-IN.texCoords.y);
	OUT.brightness		=IN.texCoords.y;
	OUT.depth			=OUT.position.z/OUT.position.w;
    return OUT;
}

vec2 PixelPos(vec4 vertex)
{
	return vec2(vertex.xy/vertex.w)*viewportPixels;
}

[maxvertexcount(10)]
shader void GS_Thick(lineadj LightningVertexOutput IN[4], inout TriangleStream<transformedVertex> SpriteStream)
{
	transformedVertex OUT;
    //  a - - - - - - - - - - - - - - - - b
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  | - - -start - - - - - - end- - - |
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  d - - - - - - - - - - - - - - - - c
	vec2 p0		=PixelPos(IN[0].position);
	vec2 p1		=PixelPos(IN[1].position);
	vec2 p2		=PixelPos(IN[2].position);
	vec2 p3		=PixelPos(IN[3].position);
	vec2 area	=viewportPixels * 1.2;
	if(p1.x<-area.x||p1.x>area.x) return;
	if(p1.y<-area.y||p1.y>area.y) return;
	if(p2.x<-area.x||p2.x>area.x) return;
	if(p2.y<-area.y||p2.y>area.y) return;
	if(IN[0].position.z<0) return;
    vec4 start			=IN[1].position;
    vec4 end			=IN[2].position;
	// determine the direction of each of the 3 segments (previous, current, next
	vec2 v0				=normalize(p1-p0);
	vec2 v1				=normalize(p2-p1);
	vec2 v2				=normalize(p3-p2);
	// determine the normal of each of the 3 segments (previous, current, next)
	vec2 n0				=vec2(-v0.y,v0.x);
	vec2 n1				=vec2(-v1.y,v1.x);
	vec2 n2				=vec2(-v2.y,v2.x);
	// determine miter lines by averaging the normals of the 2 segments
	vec2 miter_a		=normalize(n0 + n1);	// miter at start of current segment
	vec2 miter_b		=normalize(n1 + n2);	// miter at end of current segment
	// determine the length of the miter by projecting it onto normal and then inverse it

	//We want to have an output brightness*pixelWidth as specified according to thicknessMetres and input brightness.
	// so K=IN[1].brightness*(width1/start.w	*viewportPixels.x)
	// But: first we have a minimum pixel width. So if (width1/start.w	*viewportPixels.x)<minPixelWidth, we want brightness=K/minPixelWidth
	// And second we have a maximum output brightness, so if brightness>maxBrightness, we want pixelWidth=K/maxBrightness
	float truePixelWidth1	=(IN[1].thicknessMetres/start.w*viewportPixels.x);
	float truePixelWidth2	=(IN[2].thicknessMetres/start.w*viewportPixels.x);
	float K1				=IN[1].brightness*truePixelWidth1;
	float K2				=IN[2].brightness*truePixelWidth2;
	float brightness1		=IN[1].brightness;
	float brightness2		=IN[2].brightness;
	float width1			=IN[1].thicknessMetres;
	float width2			=IN[2].thicknessMetres;
	float maxBrightness		=100.0;
	// Overbright? Make pixel width larger:
	if(brightness1>maxBrightness)
	{
		width1				*=brightness1/maxBrightness;
		brightness1			=maxBrightness;
	}
	if(brightness2>maxBrightness)
	{
		width2				*=brightness2/maxBrightness;
		brightness2			=maxBrightness;
	}
	//pixel size too small? make it up to the minimum, but scale down the brightness:
	if(width1<minPixelWidth/viewportPixels.x*start.w)
	{
		brightness1			*=width1/(minPixelWidth/viewportPixels.x*start.w);
		width1				=minPixelWidth/viewportPixels.x*start.w;
	}
	if(width2<minPixelWidth/viewportPixels.x*start.w)
	{
		brightness2			*=width2/(minPixelWidth/viewportPixels.x*start.w);
		width2				=minPixelWidth/viewportPixels.x*start.w;
	}
	float lengthPixels_a	=width1/start.w	*viewportPixels.x/dot(miter_a, n1);
	float lengthPixels_b	=width2/end.w	*viewportPixels.x/dot(miter_b, n1);
	const float	MITER_LIMIT	=1.0;
	OUT.hPosCentre1		=vec2(p1.xy/viewportPixels);
	OUT.hPosCentre2		=vec2(p2.xy/viewportPixels);
	OUT.clipWidth		=width1/start.w;
	vec2 diff				=OUT.hPosCentre2-OUT.hPosCentre1;
	float dist				=length(diff);
	float d2				=dist*dist;
	// prevent excessively long miters at sharp corners
	if( dot(v0,v1) < -MITER_LIMIT )
	{
		miter_a = n1;
		lengthPixels_a = width1;
		// close the gap
		if(dot(v0,n1)>0)
		{
			OUT.hPosition	=vec4( (p1 + width1 * n0) / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			OUT.hPosition	=vec4( (p1 + width1 * n1) / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			OUT.hPosition	=vec4( p1 / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			SpriteStream.RestartStrip();
		}
		else
		{
			OUT.hPosition	=vec4( (p1 - width2 * n1) / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			OUT.hPosition	=vec4( (p1 - width2 * n0) / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			OUT.hPosition	=vec4( p1 / viewportPixels, 0.0, 1.0 );
			OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
			OUT.texc		=OUT.screenPos.xy*0.5+0.5;
			OUT.along		=0;
			OUT.brightness	=IN[1].brightness;
			OUT.endpoint	=IN[1].endpoint;
			OUT.clipPos		=OUT.hPosition;
			SpriteStream.Append(OUT);
			SpriteStream.RestartStrip();
		}
	}
	if( dot(v1,v2) < -MITER_LIMIT )
	{
		miter_b = n1;
		lengthPixels_b = width2;
	}
  // generate the triangle strip
	OUT.clipWidth		=width1/start.w;
	OUT.screenPos		=(p1 + lengthPixels_a * miter_a)/viewportPixels;
	OUT.hPosition		=vec4(OUT.screenPos.xy*start.w,start.z,start.w);
	OUT.texc			=OUT.screenPos.xy*0.5+0.5;
	OUT.along			=0.0;//dot(OUT.screenPos.xy-OUT.hPosCentre1.xy,diff)/d2*1.1-0.05;
	OUT.brightness		=IN[1].brightness;
	OUT.endpoint		=IN[1].endpoint;
	OUT.clipPos			=OUT.hPosition;
	SpriteStream.Append(OUT);
	OUT.screenPos		=(p1 - lengthPixels_a * miter_a)/viewportPixels;
	OUT.hPosition		=vec4(OUT.screenPos.xy*start.w,start.z,start.w);
	OUT.texc			=OUT.screenPos.xy*0.5+0.5;
	OUT.along			=0.0;//dot(OUT.screenPos.xy-OUT.hPosCentre1.xy,diff)/d2;
	OUT.brightness		=IN[1].brightness;
	OUT.clipPos			=OUT.hPosition;
	SpriteStream.Append(OUT);
	OUT.clipWidth		=width2/end.w;
	OUT.screenPos		=(p2 + lengthPixels_b * miter_b)/viewportPixels;
	OUT.hPosition		=vec4(OUT.screenPos.xy*end.w,end.z,end.w);
	OUT.texc			=OUT.screenPos.xy*0.5+0.5;
	OUT.along			=1.0;//dot(OUT.screenPos.xy-OUT.hPosCentre1.xy,diff)/d2;
	OUT.brightness		=IN[2].brightness;
	OUT.endpoint		=IN[2].endpoint;
	OUT.clipPos			=OUT.hPosition;
	SpriteStream.Append(OUT);
	OUT.screenPos		=(p2 - lengthPixels_b * miter_b)/viewportPixels;
	OUT.hPosition		=vec4(OUT.screenPos.xy*end.w,end.z,end.w);
	OUT.texc			=OUT.screenPos.xy*0.5+0.5;
	OUT.along			=1.0;//dot(OUT.screenPos.xy-OUT.hPosCentre1.xy,diff)/d2;
	OUT.brightness		=IN[2].brightness;
	OUT.endpoint		=IN[2].endpoint;
	OUT.clipPos			=OUT.hPosition;
	SpriteStream.Append(OUT);
    SpriteStream.RestartStrip();
}

vec4 PS_Main(transformedVertex IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct={depthToLinFadeDistParams,reverseDepth};
	vec2 texc			=vec2(IN.texc.x,1.0-IN.texc.y);
	vec4 clookup 		=texture_wrap(cloudDepthTexture,texc.xy);

	vec4 clip_pos		=vec4(IN.screenPos,1.0,1.0);
	float depth			=clookup.x;
	float l_depth		=IN.clipPos.z/IN.clipPos.w;
	vec2 dist			=depthToFadeDistance(vec2(depth,l_depth),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);

	float past			=saturate(1.0-saturate((dist.y-dist.x)/0.00001)-0.01);
	
	float br			=IN.brightness;
	vec2 dir			=normalize(IN.hPosCentre2-IN.hPosCentre1);
	float along			=dot(IN.screenPos-IN.hPosCentre1,dir);
	vec2 centre1		=lerp(IN.hPosCentre1,IN.hPosCentre2,saturate(IN.along));//*(1.0-IN.endpoint)));
	vec2 centre2		=lerp(IN.hPosCentre1,IN.hPosCentre2,saturate(along));//*(1.0-IN.endpoint)));
	vec2 diff1			=IN.screenPos-centre1;
	vec2 diff2			=IN.screenPos-centre2;
	float clipWidth2px	=minPixelWidth/float(viewportPixels.x);
	float d				=min(length(diff1),length(diff2));
	float m				=d/clipWidth2px;
	float s				=max(0.0,d-clipWidth2px)/IN.clipWidth;
	
	br					=min(brightnessToUnity,br);//*saturate(exp(-4.0*s)-0.05)/0.95;
	br					+=IN.brightness*saturate(10.0*(1.0-m));
	br*=past;
	if(br<0)
		br=0;
	vec4 colour			=vec4(br*lightningColour.rgb,1.0);//lightningTexture.Sample(clampSamplerState,IN.texCoords.xy);
	//colour			*=saturate(1.0-(dist.y-dist.x)/0.001);
	
    return colour;
}

shader vec4 PS_Main_ReverseDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,true);
}

shader vec4 PS_Main_ForwardDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,false);
}

vec4 PS_Thin(transformedThinVertex IN,bool reverseDepth)
{
	vec2 texc=vec2(IN.texc.x,1.0-IN.texc.y);
	vec4 dlookup 		=texture_clamp(depthTexture,texc.xy);
	vec4 clookup 		=texture_clamp(cloudDepthTexture,texc.xy);
	float depth=0;
	if(reverseDepth)
		depth			=max(dlookup.x,clookup.x);
	else
		depth			=min(dlookup.x,clookup.x);
	DepthIntepretationStruct depthInterpretationStruct={depthToLinFadeDistParams,reverseDepth};
	vec2 dist			=depthToFadeDistance(vec2(depth,IN.depth),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);
	//if(dist.x<dist.y)
	//	discard;
	
	vec4 colour		=vec4(lightningColour,1.0)*IN.brightness;//;//lightningTexture.Sample(clampSamplerState,IN.texCoords.xy);
	colour			*=saturate(1.0-(dist.y-dist.x)/0.001);
    return colour;
}

shader vec4 PS_Thin_ReverseDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,true);
}

shader vec4 PS_Thin_ForwardDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,false);
}

BlendState MaxBlend
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1]	=TRUE;
	SrcBlend		=ONE;
	DestBlend		=ONE;
	BlendOp			=MAX;
};

technique lightning_thick
{
    pass reverse_depth 
    {
        SetRasterizerState(RenderNoCull);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
        SetGeometryShader( CompileShader(gs_5_0,GS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ReverseDepth()));
    }
    pass forward_depth 
    {
        SetRasterizerState(RenderNoCull);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
        SetGeometryShader( CompileShader(gs_5_0,GS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ForwardDepth()));
    }
}
RasterizerState lightningLineRasterizer
{
	FillMode					= WIREFRAME;
	CullMode					= none;
	FrontCounterClockwise		= false;
	DepthBias					= 0;//DEPTH_BIAS_D32_FLOAT(-0.00001);
	DepthBiasClamp				= 0.f;
	SlopeScaledDepthBias		= 0.f;
	DepthClipEnable				= false;
	ScissorEnable				= false;
	MultisampleEnable			= true;
	AntialiasedLineEnable		= false;
};

technique lightning_thin
{
    pass reverse_depth 
    {
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ReverseDepth()));
    }
    pass forward_depth 
    {
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(MaxBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ForwardDepth()));
    }
}

technique random
{
    pass p0 
    {
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth,0);
		SetBlendState(NoBlend,vec4(1.0,1.0,1.0,1.0),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_4_0,PS_Random()));
    }
}