#include "shader_platform.sl"
#include "../../CrossPlatform/SL/common.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/lightning_constants.sl"
#include "../../CrossPlatform/SL/depth.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/noise.sl"

Texture2D lightningTexture;
Texture2D depthTexture;
Texture2DMS<vec4> depthTextureMS;
Texture2D cloudDepthTexture;

struct F_Vertex
{
    vec3 position	: POSITION;
    vec4 texcoord	: TEXCOORD0;
};

struct F_Vertex_out
{
    vec4 hPosition	: SV_Position;
};

F_Vertex VS_Fractal(F_Vertex IN )
{
	F_Vertex OUT;
	OUT.position	=IN.position;
	OUT.texcoord	=IN.texcoord;
	return OUT;
}

F_Vertex VS_InitialFractal(idOnly IN )
{
	F_Vertex OUT;
	OUT.texcoord	=vec4(200.0,200.0,1.0,1000.0);
	OUT.position	=lerp(startPos,endPos,float(IN.vertex_id));
	return OUT;
}

[maxvertexcount(129)]
void GS_Fractal(line F_Vertex input[2], inout PointStream<F_Vertex> vStream)
{
	F_Vertex output;
	vec3 startP	=input[0].position;
	vec3 endP	=input[1].position;
	vec3 outpos[129];
	outpos[0]=startP;
	outpos[128]=endP;
	int del=128;
	float persistence=0.8;
	float off=0.4;
	for(int i=0;i<7;i++)
	{
		for(int j=del/2;j<128;j+=del)
		{
			vec3 s=outpos[j-del/2];
			vec3 e=outpos[j+del/2];
			vec3 XX=cross(vec3(1.0,0.0,0.0),(s-e));
			vec3 YY=cross(vec3(0.0,1.0,0.0),(e-e));
			vec3 x=0.5*(s+e);
			float angle=rand(0.01*x.xy+0.02*x.zx)*2.0*3.14159;
			x+=off*(XX*cos(angle)+YY*sin(angle));
			outpos[j]=x;
		}
		del/=2;
		off*=persistence;
	}
	for(int i=0;i<129;i++)
	{
		output.position		=outpos[i];
		output.texcoord		=vec4(200.0,200.0,100.0,1000.0);
		vStream.Append(output);
	}
	vStream.RestartStrip();
}


VertexShader vs_init		=CompileShader(vs_5_0,VS_InitialFractal());
GeometryShader gs_fractal	=CompileShader(gs_5_0,GS_Fractal());
GeometryShader so_fractal	=ConstructGSWithSO(gs_fractal, "POSITION.xyz;TEXCOORD0.xyzw");

technique initial_fractal
{
    pass main
    {
        SetRasterizerState( RenderNoCull );
        SetVertexShader(vs_init);
        SetGeometryShader(so_fractal);
		SetPixelShader(NULL);
    }
}
technique fractal
{
    pass main
    {
        SetRasterizerState( RenderNoCull );
        SetVertexShader(CompileShader(   vs_5_0,VS_Fractal()));
        SetGeometryShader(CompileShader( gs_5_0,GS_Fractal()));
		SetPixelShader(NULL);
    }
}

struct transformedVertex
{
    vec4 hPosition	: SV_POSITION;
	vec4 texCoords	: TEXCOORD0;
    vec2 hPosCentre1: TEXCOORD1;
    vec2 hPosCentre2: TEXCOORD2;
	vec2 screenPos:	TEXCOORD3;
	vec2 texc		:	TEXCOORD4;
    float along: TEXCOORD5;
	float width: TEXCOORD6;
    float depth	: TEXCOORD7;
};

struct transformedThinVertex
{
    vec4 hPosition	: SV_POSITION;
	vec4 texCoords	: TEXCOORD0;
    float depth	: TEXCOORD1;
	vec2 screenPos:	TEXCOORD2;
	vec2 texc		:	TEXCOORD3;
};

shader transformedThinVertex VS_Thin(LightningVertexInput IN)
{
    transformedThinVertex OUT;
    OUT.hPosition	=mul(worldViewProj, vec4(IN.position.xyz , 1.0));
	OUT.texCoords	=IN.texCoords;
	OUT.depth		=OUT.hPosition.z/OUT.hPosition.w;
	OUT.screenPos	=OUT.hPosition.xy/OUT.hPosition.w;
	OUT.texc		=OUT.screenPos.xy*0.5+0.5;
    return OUT;
}

shader LightningVertexOutput VS_Thick(LightningVertexInput IN)
{
    LightningVertexOutput OUT;
    OUT.position	=mul(worldViewProj, vec4(IN.position.xyz , 1.0));
	OUT.texCoords	=IN.texCoords;
	OUT.depth		=OUT.position.z/OUT.position.w;
    return OUT;
}

vec2 PixelPos(vec4 vertex)
{
	return vec2(vertex.xy/vertex.w)*viewportPixels;
}

[maxvertexcount(10)]
shader void GS_Thick(lineadj LightningVertexOutput input[4], inout TriangleStream<transformedVertex> SpriteStream)
{
	transformedVertex output;
    //  a - - - - - - - - - - - - - - - - b
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  | - - -start - - - - - - end- - - |
    //  |      |                   |      |
    //  |      |                   |      |
    //  |      |                   |      |
    //  d - - - - - - - - - - - - - - - - c
	vec2 p0		=PixelPos(input[0].position);
	vec2 p1		=PixelPos(input[1].position);
	vec2 p2		=PixelPos(input[2].position);
	vec2 p3		=PixelPos(input[3].position);
	vec2 area	=viewportPixels * 1.2;
	if(p1.x<-area.x||p1.x>area.x) return;
	if(p1.y<-area.y||p1.y>area.y) return;
	if(p2.x<-area.x||p2.x>area.x) return;
	if(p2.y<-area.y||p2.y>area.y) return;
	if(input[0].position.z<0) return;
    vec4 start			=input[1].position;
    vec4 end			=input[2].position;
	// determine the direction of each of the 3 segments (previous, current, next
	vec2 v0				=normalize(p1-p0);
	vec2 v1				=normalize(p2-p1);
	vec2 v2				=normalize(p3-p2);
	// determine the normal of each of the 3 segments (previous, current, next)
	vec2 n0				=vec2(-v0.y,v0.x);
	vec2 n1				=vec2(-v1.y,v1.x);
	vec2 n2				=vec2(-v2.y,v2.x);
	// determine miter lines by averaging the normals of the 2 segments
	vec2 miter_a		=normalize(n0 + n1);	// miter at start of current segment
	vec2 miter_b		=normalize(n1 + n2);	// miter at end of current segment
	// determine the length of the miter by projecting it onto normal and then inverse it
	float width1		=input[1].texCoords.x;
	float width2		=input[2].texCoords.x;
	float lengthPixels_a		=width1/start.w	*viewportPixels.x/dot(miter_a, n1);
	float lengthPixels_b		=width2/end.w	*viewportPixels.x/dot(miter_b, n1);
	const float	MITER_LIMIT=1.0;
	output.hPosCentre1	=vec2(p1.xy/viewportPixels);
	output.hPosCentre2	=vec2(p2.xy/viewportPixels);
	output.width		=width1/start.w;
	vec2 diff	=output.hPosCentre2-output.hPosCentre1;
	float dist	=length(diff);
	float d2	=dist*dist;
	// prevent excessively long miters at sharp corners
	if( dot(v0,v1) < -MITER_LIMIT )
	{
		miter_a = n1;
		lengthPixels_a = width1;
		// close the gap
		if(dot(v0,n1)>0)
		{
			output.hPosition	=vec4( (p1 + width1 * n0) / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(0,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			output.hPosition	=vec4( (p1 + width1 * n1) / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(0,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			output.hPosition	=vec4( p1 / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(0.5,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			SpriteStream.RestartStrip();
		}
		else
		{
			output.hPosition	=vec4( (p1 - width2 * n1) / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(1.0,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			output.hPosition	=vec4( (p1 - width2 * n0) / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(1.0,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			output.hPosition	=vec4( p1 / viewportPixels, 0.0, 1.0 );
			output.screenPos	=output.hPosition.xy/output.hPosition.w;
			output.texc			=output.screenPos.xy*0.5+0.5;
			output.along		=dot(output.hPosition.xy-output.hPosCentre1.xy,diff)/d2;
			output.texCoords	=vec4(0.5,input[1].texCoords.yzw);
			output.depth		=input[1].depth;
			SpriteStream.Append(output);
			SpriteStream.RestartStrip();
		}
	}
	if( dot(v1,v2) < -MITER_LIMIT )
	{
		miter_b = n1;
		lengthPixels_b = width2;
	}
  // generate the triangle strip
	output.width		=width1/start.w;
	output.screenPos	=(p1 + lengthPixels_a * miter_a)/viewportPixels;
	output.hPosition	=vec4(output.screenPos.xy*start.w,start.z,start.w);
	output.texc			=output.screenPos.xy*0.5+0.5;
	output.along		=dot(output.screenPos.xy-output.hPosCentre1.xy,diff)/d2*1.1-0.05;
	output.texCoords	=vec4(0.0,input[1].texCoords.yzw);

	output.depth		=input[1].depth;
	SpriteStream.Append(output);
	output.screenPos	=(p1 - lengthPixels_a * miter_a)/viewportPixels;
	output.hPosition	=vec4(output.screenPos.xy*start.w,start.z,start.w);
	output.texc			=output.screenPos.xy*0.5+0.5;
	output.along		=dot(output.screenPos.xy-output.hPosCentre1.xy,diff)/d2;
	output.texCoords	=vec4(1.0,input[1].texCoords.yzw);
	output.depth		=input[1].depth;
	SpriteStream.Append(output);
	output.width		=width2/end.w;
	output.screenPos	=(p2 + lengthPixels_b * miter_b)/viewportPixels;
	output.hPosition	=vec4(output.screenPos.xy*end.w,end.z,end.w);
	output.texc			=output.screenPos.xy*0.5+0.5;
	output.along		=dot(output.screenPos.xy-output.hPosCentre1.xy,diff)/d2;
	output.texCoords	=vec4(0.0,input[2].texCoords.yzw);
	output.depth		=input[2].depth;
	SpriteStream.Append(output);
	output.screenPos	=(p2 - lengthPixels_b * miter_b)/viewportPixels;
	output.hPosition	=vec4(output.screenPos.xy*end.w,end.z,end.w);
	output.texc			=output.screenPos.xy*0.5+0.5;
	output.along		=dot(output.screenPos.xy-output.hPosCentre1.xy,diff)/d2;
	output.texCoords	=vec4(1.0,input[2].texCoords.yzw);
	output.depth		=input[2].depth;
	SpriteStream.Append(output);
    SpriteStream.RestartStrip();
}

vec4 PS_Main(transformedVertex IN,bool reverseDepth)
{
	DepthIntepretationStruct depthInterpretationStruct={depthToLinFadeDistParams,reverseDepth};
	vec2 texc=vec2(IN.texc.x,1.0-IN.texc.y);
	vec4 dlookup 		=texture_wrap(depthTexture,texc.xy);
	vec4 clookup 		=texture_wrap(cloudDepthTexture,texc.xy);

	vec4 clip_pos		=vec4(IN.screenPos,1.0,1.0);
	float depth=0;
	if(reverseDepth)
		depth			=max(dlookup.x,clookup.x);
	else
		depth			=min(dlookup.x,clookup.x);

	vec2 dist			=depthToFadeDistance(vec2(depth,IN.depth),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);
	//return vec4(100*dist.xy,100*dlookup.z,1.0);//dlookup.rb,1);
	
	float b			=2.0*(IN.texCoords.x-0.5);
	float br		=IN.texCoords.w;//pow(1.0-b*b,4.0);// w is the local brightness factor
	vec2 centre		=lerp(IN.hPosCentre1,IN.hPosCentre2,saturate(IN.along));
	vec2 diff		=IN.screenPos-centre;
	float d			=length(diff)/IN.width;
	br				*=exp(-20.0*d);
	if(br<0)
		br=0;
	vec4 colour		=br;//*lightningColour;//lightningTexture.Sample(clampSamplerState,IN.texCoords.xy);
	colour			*=saturate(1.0-(dist.y-dist.x)/0.001);
	
    return colour;
}

shader vec4 PS_Main_ReverseDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,true);
}

shader vec4 PS_Main_ForwardDepth(transformedVertex IN): SV_TARGET
{
	return PS_Main(IN,false);
}

vec4 PS_Thin(transformedThinVertex IN,bool reverseDepth)
{
    return vec4(1,0,1,1);
	vec2 texc=vec2(IN.texc.x,1.0-IN.texc.y);
	vec4 dlookup 		=texture_clamp(depthTexture,texc.xy);
	vec4 clookup 		=texture_clamp(cloudDepthTexture,texc.xy);
	float depth=0;
	if(reverseDepth)
		depth			=max(dlookup.x,clookup.x);
	else
		depth			=min(dlookup.x,clookup.x);
	DepthIntepretationStruct depthInterpretationStruct={depthToLinFadeDistParams,reverseDepth};
	vec2 dist			=depthToFadeDistance(vec2(depth,IN.depth),IN.screenPos.xy,depthInterpretationStruct,tanHalfFov);
	//if(dist.x<dist.y)
	//	discard;
	
	vec4 colour=lightningColour*IN.texCoords.w;//lightningTexture.Sample(clampSamplerState,IN.texCoords.xy);
	colour			*=saturate(1.0-(dist.y-dist.x)/0.001);
    return colour;
}

shader vec4 PS_Thin_ReverseDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,true);
}

shader vec4 PS_Thin_ForwardDepth(transformedThinVertex IN): SV_TARGET
{
	return PS_Thin(IN,false);
}

technique lightning_thick
{
    pass reverse_depth 
    {
        SetRasterizerState(RenderNoCull);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
        SetGeometryShader( CompileShader(gs_5_0,GS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ReverseDepth()));
    }
    pass forward_depth 
    {
        SetRasterizerState(RenderNoCull);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thick()));
        SetGeometryShader( CompileShader(gs_5_0,GS_Thick()));
		SetPixelShader(CompileShader(ps_5_0,PS_Main_ForwardDepth()));
    }
}
RasterizerState lightningLineRasterizer
{
	FillMode					= WIREFRAME;
	CullMode					= none;
	FrontCounterClockwise		= false;
	DepthBias					= 0;//DEPTH_BIAS_D32_FLOAT(-0.00001);
	DepthBiasClamp				= 0.f;
	SlopeScaledDepthBias		= 0.f;
	DepthClipEnable				= false;
	ScissorEnable				= false;
	MultisampleEnable			= true;
	AntialiasedLineEnable		= false;
};

technique lightning_thin
{
    pass reverse_depth 
    {
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ReverseDepth()));
    }
    pass forward_depth 
    {
        SetRasterizerState(lightningLineRasterizer);
		SetBlendState(AddBlend,vec4(0.0f,0.0f,0.0f,0.0f),0xFFFFFFFF);
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Thin()));
		SetPixelShader(CompileShader(ps_5_0,PS_Thin_ForwardDepth()));
    }
}
