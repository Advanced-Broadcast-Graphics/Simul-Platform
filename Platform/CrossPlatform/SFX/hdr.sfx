#include "shader_platform.sl"
#include "../SL/render_states.sl"
#include "../SL/depth.sl"
#include "../SL/hdr_constants.sl"
#include "../SL/colour_packing.sl"
#include "../SL/mixed_resolution.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/composite.sl"
uniform Texture2D imageTexture;
uniform TEXTURE2DMS_FLOAT4 imageTextureMS;
uniform Texture2D nearImageTexture;
uniform Texture2D depthTexture;
uniform TEXTURE2DMS_FLOAT4 depthTextureMS;
uniform Texture2D lowResDepthTexture;
uniform Texture2D hiResDepthTexture;
uniform TEXTURE2D_UINT glowTexture;
 
uniform Texture2D inscatterTexture;			// Far, or default inscatter
uniform Texture2D nearInscatterTexture;		// Near inscatter.
uniform TEXTURE2D_UINT4 lossTexture;

uniform Texture3D screenSpaceInscatterVolumeTexture;
uniform Texture3D lightSpaceInscatterVolumeTexture;
uniform Texture3D cloudVolumeTexture;
struct a2v
{
	uint vertex_id	: SV_VERTEXID;
    vec4 position	: POSITION;
    vec2 texcoord	: TEXCOORD0;
};

struct v2f
{
    vec4 hPosition	: SV_POSITION;
    vec2 texCoords	: TEXCOORD0;
};

shader v2f MainVS(idOnly IN)
{
	v2f OUT;
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(pos,0.0,1.0);
	// Set to far plane so can use depth test as we want this geometry effectively at infinity
#if REVERSE_DEPTH==1
	OUT.hPosition.z	=0.0; 
#else
	OUT.hPosition.z	=OUT.hPosition.w; 
#endif
    OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
    return OUT;
}

shader v2f OffsetVS(idOnly IN)
{
	v2f OUT;
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(pos/*+offset*/,0.0,1.0);
	// Set to far plane so can use depth test as we want this geometry effectively at infinity
#if REVERSE_DEPTH==1
	OUT.hPosition.z	=0.0; 
#else
	OUT.hPosition.z	=OUT.hPosition.w; 
#endif
    OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
    return OUT;
}

shader posTexVertexOutput QuadVS(idOnly id)
{
    return VS_ScreenQuad(id,rect);
}

shader vec4 ShowDepthPS(posTexVertexOutput IN) : SV_Target
{
	vec4 depth		=texture_clamp(depthTexture,IN.texCoords);
	float dist		=10.0*depthToFadeDistance(depth.x,2.0*(IN.texCoords-0.5),depthToLinFadeDistParams,tanHalfFov);
    return vec4(1,dist,dist,1.0);
}

vec4 convertInt(TEXTURE2D_UINT glowTexture,uint2 location)
{
	uint int_color = IMAGE_LOAD(glowTexture,int2(location)).x;

	// Convert R11G11B10 to float3
	vec4 color;
	color.r =float(int_color >> 21) / 2047.0f;
	color.g =float((int_color >> 10) & 0x7ff) / 2047.0f;
	color.b =float(int_color & 0x0003ff) / 1023.0f;
	color.a = 1;
	color.rgb*=10.0;
	return color;
}

vec4 texture_int(TEXTURE2D_UINT glowTexture,vec2 texCoord)
{
	uint2 tex_dim;
	GET_DIMENSIONS(glowTexture,tex_dim.x, tex_dim.y);

	vec2 pos1=vec2(tex_dim.x*texCoord.x-0.5,tex_dim.y * texCoord.y-0.5);
	vec2 pos2=vec2(tex_dim.x*texCoord.x+0.5,tex_dim.y * texCoord.y+0.5);

	uint2 location1=uint2(pos1);
	uint2 location2=uint2(pos2);

	vec2 l=vec2(tex_dim.x*texCoord.x,tex_dim.y * texCoord.y)-vec2(location1);

	vec4 tex00=convertInt(glowTexture,location1);
	vec4 tex10=convertInt(glowTexture,uint2(location2.x,location1.y));
	vec4 tex11=convertInt(glowTexture,location2);
	vec4 tex01=convertInt(glowTexture,uint2(location1.x,location2.y));

	vec4 tex0=lerp(tex00,tex10,l.x);
	vec4 tex1=lerp(tex01,tex11,l.x);
	vec4 tex=lerp(tex0,tex1,l.y);
	return tex;
}

/*
 The Filmic tone mapper is from: http://filmicgames.com/Downloads/GDC_2010/Uncharted2-Hdr-Lighting.pptx
These numbers DO NOT have the pow(x,1/2.2) baked in
*/
vec3 FilmicTone(vec3 x)
{
	float A				=0.22;	//Shoulder Strength
	float B				=0.30;	//Linear Strength
	float C				=0.10;	//Linear Angle
	float D				=0.20;	//Toe Strength
	float E				=0.01;	//Toe Numerator
	float F				=0.30;	//Toe Denominator
	//Note: E/F = Toe Angle
	float LinearWhite	=1.2;	//Linear White Point Value
	vec3 Fx				= ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F)) - E/F;
	float Fw				= ((LinearWhite*(A*LinearWhite+C*B)+D*E)/(LinearWhite*(A*LinearWhite+B)+D*F)) - E/F;
	vec3 c				= Fx/Fw;
	return c;
}

shader vec4 LinearizeDepthPS(v2f IN) : SV_Target
{
	vec4 depth=texture_nearest_lod(depthTexture,IN.texCoords,0);
	float dist=depthToLinearDistance(depth.x,depthToLinFadeDistParams);
    return vec4(dist,dist,dist,1.0);
}

shader vec4 LinearizeDepthPS_MSAA(v2f IN,in uint coverageMask:SV_COVERAGE,out uint outputCoverage:SV_COVERAGE) : SV_Target
{
	int2 pos=vec2(fullResDims.xy)*IN.texCoords.xy;
//	const uint FullMask = ( 1 << NumMSAASamples ) - 1; // 0xF
//	float edgePixel = coverageMask != FullMask ? 1.0f : 0.0f;
	outputCoverage=coverageMask;
	for(int i=0;i<8;i++)
	{
		uint u=1<<i;
		//if(coverageMask&u)
		{
			vec4 depth=depthTextureMS.Load(pos,i);
			float dist=depthToLinearDistance(depth.x,depthToLinFadeDistParams);
			return vec4(dist,dist,dist,1.0);
		}
	}
    return vec4(0,0,0,1.0);
}

shader vec4 GlowExposureGammaPS(v2f IN) : SV_Target
{
	vec4 c		=texture_nearest_lod(imageTexture,IN.texCoords,0);
	vec4 glow	=texture_int(glowTexture,IN.texCoords);
	c.rgb		+=glow.rgb;
	c.rgb		*=exposure;
	c.rgb		=pow(c.rgb,gamma);
    return vec4(c.rgb,1.0);
}

shader vec4 GlowExposureGammaPS_MSAA(v2f IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
	vec4 glow=texture_int(glowTexture,IN.texCoords);
	c.rgb+=glow.rgb;
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
    return vec4(c.rgb,1.0);
}

shader vec4 PS_InfraRed(v2f IN) : SV_Target
{
	vec4 c					=texture_clamp(imageTexture,IN.texCoords);
    c.rgb					*=infraredIntegrationFactors.xyz;
    float final_radiance	=c.x+c.y+c.z;
	c=vec4(final_radiance,final_radiance,final_radiance,c.a);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
	return vec4(c.rgb,1.0);
}

shader vec4 PS_InfraRed_MSAA(v2f IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
    c.rgb					*=infraredIntegrationFactors.xyz;
    float final_radiance	=c.x+c.y+c.z;
	c=vec4(final_radiance,final_radiance,final_radiance,c.a);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
	return vec4(c.rgb,1.0);
}

shader vec4 PS_ShowCompressed(posTexVertexOutput IN) : SV_Target
{
	vec4 glow		=texture_int(glowTexture,IN.texCoords);
    return vec4(glow.rgb,1.0);
}

shader vec4 PS_ShowScatteringVolume(posTexVertexOutput IN) : SV_Target
{
	float z			=floor(8.0f*IN.texCoords.x)/8.0f;
	vec4 sc			=texture_clamp(lightSpaceInscatterVolumeTexture,vec3(IN.texCoords.xy,z));
    return vec4(sc.rgb,1.0);
}

shader vec4 PS_ShowVolume(posTexVertexOutput IN) : SV_Target
{
	float z			=floor(8.0f*IN.texCoords.x)/8.0f;
	if(IN.texCoords.y<.5)
		z=.5;
	vec4 colour		=texture_nearest_lod(screenSpaceInscatterVolumeTexture,vec3(IN.texCoords,z),0);
	//colour.r = colour.a;
	return colour;
}

shader vec4 ExposureGammaPS(v2f IN) : SV_Target
{
	vec4 c=texture_nearest_lod(imageTexture,IN.texCoords,0);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
    return vec4(c.rgb,1.0);
}

shader vec4 ExposureGammaPS_MSAA(v2f IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
    return vec4(c.rgb,1.0);
}

// Scales input texture coordinates for distortion.
vec2 HmdWarp(vec2 texCoords)
{
	vec2 theta		= (texCoords - warpLensCentre) * warpScaleIn; // Scales to [-1, 1]
	float rSq		= theta.x*theta.x+theta.y*theta.y;
	vec2 rvector	= theta * (warpHmdWarpParam.x + warpHmdWarpParam.y * rSq +
								warpHmdWarpParam.z * rSq * rSq +
								warpHmdWarpParam.w * rSq * rSq * rSq);
	return warpLensCentre+rvector*warpScale;
}

shader vec4 WarpExposureGammaPS(v2f IN) : SV_Target
{
	vec2 tc = HmdWarp(IN.texCoords);
	//if(any(clamp(tc,warpScreenCentre-vec2(0.25,0.5),warpScreenCentre+vec2(0.25, 0.5))-tc))
	//	return vec4(0,0,0,0);
	vec4 c=texture_clamp(imageTexture,tc);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,gamma);
    return vec4(c.rgb,1.0);
}

void UpdateNearestSample(	inout float MinDist,
							inout vec2 NearestUV,
							float Z,
							vec2 UV,
							float ZFull
							)
{
	float Dist = abs(Z - ZFull);
	if (Dist < MinDist)
	{
		MinDist = Dist;
		NearestUV = UV;
	}
}

bool IsSampleNearer(inout float MinDist,float Z,float ZFull)
{
	float Dist = abs(Z - ZFull);
	return (Dist < MinDist);
}


shader vec4 DirectPS(v2f IN) : SV_Target
{
	vec2 lowResTexCoords		=fullResToLowResTransformXYWH.xy+IN.texCoords*fullResToLowResTransformXYWH.zw;
	vec4 result	=texture_clamp(imageTexture,lowResTexCoords);
	vec4 insc	=texture_clamp(inscatterTexture,IN.texCoords);
	result		+=insc*result.a;
	result.rgb	=exposure*pow(result.rgb,gamma);
    return result;
}

shader vec4 PS_ForegroundComposite(v2f IN) : SV_Target
{
	vec4 depthLookup			=texture_clamp(depthTexture,IN.texCoords);
#if REVERSE_DEPTH==1
	if(depthLookup.x==0)
		discard;
#else
	if(depthLookup.x>=1.0)
		discard;
#endif
	vec2 hiResTexCoords		=fullResToHighResTransformXYWH.xy+IN.texCoords*fullResToHighResTransformXYWH.zw;
	vec4 result	;//=texture_clamp(imageTexture,lowResTexCoords);
	vec4 insc	=texture_nearest_lod(inscatterTexture,hiResTexCoords,0);
	result		=insc;//*result.a;
    return result;
}

// With an MSAA depth texture.
shader vec4 PS_ForegroundComposite_MSAA(v2f IN) : SV_Target
{
	vec2 depth_texc			=viewportCoordToTexRegionCoord(IN.texCoords.xy,viewportToTexRegionScaleBias);
	int2 fullres_depth_pos2	=int2(depth_texc*vec2(fullResDims.xy));
	float proportion		=0.0;
	for(int k=0;k<numSamples;k++)
	{
		float d			=depthTextureMS.Load(fullres_depth_pos2,k).x;
#if REVERSE_DEPTH==1
		proportion		+=1.0-step(0,-d);
#else
		proportion		*=step(1.0,d);
#endif
	}
	proportion/=float(numSamples);
	//if(!proportion)
	//	discard;
	vec2 hiResTexCoords		=fullResToHighResTransformXYWH.xy+IN.texCoords*fullResToHighResTransformXYWH.zw;
	vec4 result	;//=texture_clamp(imageTexture,lowResTexCoords);
	vec4 insc	=texture_clamp(inscatterTexture,hiResTexCoords);
	insc.rgb	*=proportion;
	result		=insc;//*result.a;
	//result.a=proportion;
    return result;
}


CS_LAYOUT(8,8,1)
shader void CS_Composite(uint3 sub_pos	: SV_DispatchThreadID )
{
}


shader TwoColourCompositeOutput PS_CompositeAtmospherics(v2f IN) 
{
	TwoColourCompositeOutput result	=CompositeAtmospherics(IN.texCoords.xy
												,imageTexture
												,nearImageTexture
												,hiResDepthTexture
												,hiResDims
												,lowResDims
												,depthTexture
												,fullResDims
												,viewportToTexRegionScaleBias
												,depthToLinFadeDistParams
												,fullResToLowResTransformXYWH
												,fullResToHighResTransformXYWH
												,inscatterTexture
												,nearInscatterTexture
												,screenSpaceInscatterVolumeTexture
												,cloudVolumeTexture
												,lightSpaceInscatterVolumeTexture
												,lossTexture);
	result.add.rgb	=pow(result.add.rgb,vec3(gamma,gamma,gamma));
	result.add.rgb	*=exposure;
	return result;
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(v2f IN) 
{
	TwoColourCompositeOutput result	=CompositeAtmospherics_MSAA(IN.texCoords.xy
														,imageTexture
							,nearImageTexture
							,hiResDepthTexture
							,hiResDims
							,lowResDims
							,depthTextureMS
							,numSamples
							,fullResDims
							,viewportToTexRegionScaleBias
							,depthToLinFadeDistParams
							,fullResToLowResTransformXYWH
							,fullResToHighResTransformXYWH
							,inscatterTexture
							,nearInscatterTexture
														,screenSpaceInscatterVolumeTexture
												,lightSpaceInscatterVolumeTexture
							,lossTexture);
	result.add.rgb	=pow(result.add.rgb,gamma);
	result.add.rgb	*=exposure;
	return result;
}
 
shader vec4 GlowPS(v2f IN) : SV_Target
{
    // original image has double the resulution, so we sample 2x2
    vec4 c=vec4(0,0,0,0);
	c+=texture_clamp(imageTexture,IN.texCoords+offset/2.0);
	c+=texture_clamp(imageTexture,IN.texCoords-offset/2.0);
	vec2 offset2=offset;
	offset2.x=offset.x*-1.0;
	c+=texture_clamp(imageTexture,IN.texCoords+offset2/2.0);
	c+=texture_clamp(imageTexture,IN.texCoords-offset2/2.0);
	c=c*exposure/4.0;
	c-=1.0*vec4(1.0,1.0,1.0,1.0);
	c=clamp(c,vec4(0.0,0.0,0.0,0.0),vec4(10.0,10.0,10.0,10.0));
    return c;
}

VertexShader mainvs_4_0=CompileShader(vs_4_0,MainVS());
VertexShader mainvs_5_0=CompileShader(vs_5_0,MainVS());

technique exposure_gamma
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,ExposureGammaPS()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,ExposureGammaPS_MSAA()));
    }
}

technique warp_exposure_gamma
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,OffsetVS()));
		SetPixelShader(CompileShader(ps_4_0,WarpExposureGammaPS()));
    }
}

technique infra_red
{
	pass main
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,MainVS()));
		SetPixelShader(CompileShader(ps_5_0,PS_InfraRed()));
	}
	pass msaa
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,MainVS()));
		SetPixelShader(CompileShader(ps_5_0,PS_InfraRed_MSAA()));
	}
}

technique warp_glow_exposure_gamma
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,OffsetVS()));
		SetPixelShader(CompileShader(ps_4_0,WarpExposureGammaPS()));
    }
}

technique glow_exposure_gamma
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,GlowExposureGammaPS()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,GlowExposureGammaPS_MSAA()));
    }
}

// special blend for 3-colour blending!
BlendState CompositeBlend
{
	BlendEnable[0]	=TRUE;
	//BlendEnable[1]	=TRUE;
	SrcBlend		=ONE;
	DestBlend		=SRC1_COLOR;
    BlendOp			=ADD;
};

BlendState SpecialBlend
{
	BlendEnable[0]	=TRUE;
	BlendEnable[1]	=FALSE;
	SrcBlend		=ONE;
	DestBlend		=INV_SRC_ALPHA;
};


technique simple_cloud_blend
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(CloudBufferBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,DirectPS()));
    }
    pass msaa// same as above
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(CloudBufferBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,DirectPS()));
    }
}

technique linearize_depth
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,LinearizeDepthPS()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,LinearizeDepthPS_MSAA()));
    }
}

technique composite_atmospherics
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA()));
    }
}

technique cs_composite
{
    pass main
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Composite()));
    }
}

technique simul_glow
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DoBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,GlowPS()));
    }
}

technique show_depth
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,QuadVS()));
		SetPixelShader(CompileShader(ps_4_0,ShowDepthPS()));
    }
}

shader posTexVertexOutput Debug2DVS(idOnly id)
{
    return VS_ScreenQuad(id,rect);
}

shader vec4 TexturedPS(posTexVertexOutput IN) : SV_Target
{
	vec4 res=vec4(0,1,0,1);
	return res;
}


technique textured
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,TexturedPS()));
    }
}

technique show_compressed_texture
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowCompressed()));
    }
}

technique show_scattering_volume
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowScatteringVolume()));
    }
}
technique show_volume
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,QuadVS()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowVolume()));
    }
}