#include "shader_platform.sl"
#include "../../CrossPlatform/SL/common.sl"
#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/depth.sl"
#include "../../CrossPlatform/SL/colour_packing.sl"
#include "../../CrossPlatform/SL/debug_constants.sl"

uniform sampler2D imageTexture SIMUL_TEXTURE_REGISTER(0);
uniform TEXTURE2DMS_FLOAT4 imageTextureMS SIMUL_TEXTURE_REGISTER(1);
uniform TextureCube cubeTexture SIMUL_TEXTURE_REGISTER(2);
uniform TEXTURE2D_UINT imageTextureUint SIMUL_TEXTURE_REGISTER(3);
uniform TEXTURE2D_UINT4 imageTextureUint4 SIMUL_TEXTURE_REGISTER(6);

uniform sampler3D volumeTexture;

struct a2v
{
    vec3 position	: POSITION;
    vec4 colour	: TEXCOORD0;
};

struct v2f
{
    vec4 hPosition	: SV_POSITION;
    vec4 colour		: TEXCOORD0;
};

shader posTexVertexOutput VS_Quad(idOnly id)
{
    return VS_ScreenQuad(id,rect);
}

shader v2f DebugVS(positionColourVertexInput IN)
{
	v2f OUT;
	vec3 pos		=IN.position.xyz;
    OUT.hPosition	=mul(worldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=IN.colour;
    return OUT;
}

shader v2f Debug2dVS(a2v IN)
{
	v2f OUT;
    OUT.hPosition	=vec4(rect.xy+rect.zw*IN.position.xy,0.0,1.0);
	OUT.colour		=IN.colour;
    return OUT;
}

shader v2f CircleVS(idOnly IN)
{
	v2f OUT;
	float angle		=2.0*3.1415926536*float(IN.vertex_id)/31.0;
	vec4 pos		=vec4(100.0*vec3(radius*vec2(cos(angle),sin(angle)),1.0),1.0);
    OUT.hPosition	=mul(worldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=colour;
    return OUT;
}

shader v2f FilledCircleVS(idOnly IN)
{
	v2f OUT;
	int i=int(IN.vertex_id/2);
	int j=int(IN.vertex_id%2);
	float angle		=2.0*3.1415926536*float(IN.vertex_id)/31.0;
	vec4 pos		=vec4(100.0*vec3(radius*j*vec2(cos(angle),sin(angle)),1.0),1.0);
    OUT.hPosition	=mul(worldViewProj,vec4(pos.xyz,1.0));
	OUT.colour		=colour;
    return OUT;
}

shader vec4 DebugPS(v2f IN) : SV_TARGET
{
    vec4 c= IN.colour;
	return c;
}

shader vec4 PS_ShowTexture(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=multiplier*texture_nearest_lod(imageTexture,IN.texCoords.xy,0);
	res.a=res.a;
	return res;
}

shader vec4 PS_ShowVolume(posTexVertexOutput IN) : SV_Target
{
	float z			=floor(8.0f*IN.texCoords.x)/8.0f;
	if(IN.texCoords.y<.5)
		z=.5;
	vec4 colour		=texture_nearest_lod(volumeTexture,vec3(IN.texCoords,z),0);
	//colour.r = colour.a;
	return colour;
}

#ifndef GLSL
shader vec4 PS_CompactedTexture(posTexVertexOutput IN) : SV_TARGET
{
	uint2 dims;
	GET_DIMENSIONS(imageTextureUint4,dims.x,dims.y);
	uint2 pos			=uint2(IN.texCoords*vec2(dims));
	uint4 lookup		=IMAGE_LOAD(imageTextureUint4,pos);
	vec3 clr1			=uint2_to_colour3(lookup.xy);
	vec3 clr2			=uint2_to_colour3(lookup.zw);
#if 0
	vec3 clr=vec3(clr1.x,clr2.x,0.0);
#else
	vec3 clr=0.5*(clr2+clr1);
	clr.r+=100.0*abs(clr1.x-clr2.x);
#endif
	vec3 res=multiplier*clr;
//	res.xy+=IN.texCoords.xy;
	return vec4(res,1.0);
}
#endif

shader vec4 PS_ShowTextureMS(posTexVertexOutput IN) : SV_TARGET
{
	uint2 dims;
	uint numSamples;
	GET_DIMENSIONS_MSAA(imageTextureMS,dims.x,dims.y,numSamples);
	int2 pos	=int2(IN.texCoords.xy*vec2(dims.xy));
	vec4 res	=multiplier*IMAGE_LOAD_MSAA(imageTextureMS,pos,0);
	return res;
}

vec4 ShowDepthPS(posTexVertexOutput IN,bool reverseDepth) 
{
	vec4 depth		=texture_nearest_lod(imageTexture,IN.texCoords,0);
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 dist		=depthToFadeDistance(depth.xy,2.0*(IN.texCoords-0.5),depthInterpretationStruct,tanHalfFov);
    vec4 result		=vec4(pow(dist.xy,vec2(0.44,0.44)),depth.z,1.0);
	//if(IN.texCoords.x<viewport.x||IN.texCoords.x>viewport.x+viewport.z
	///	||IN.texCoords.y<viewport.y||IN.texCoords.y>viewport.y+viewport.w)
	//	result *= 0.25;
//	if (IN.texCoords.x<.1)
//		result=depth;
	return result;
}

shader vec4 PS_ShowDepth_Forward(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthPS(IN,false);
	return res;
}

shader vec4 PS_ShowDepth_Reverse(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthPS(IN,true);
	return res;
}


vec4 ShowDepthMS_PS(posTexVertexOutput IN,bool reverseDepth) 
{
	uint2 dims;
	uint numSamples;
	GET_DIMENSIONS_MSAA(imageTextureMS,dims.x,dims.y,numSamples);
	int2 pos		=int2(IN.texCoords.xy*vec2(dims.xy));
	vec4 depth		=IMAGE_LOAD_MSAA(imageTextureMS,pos,0);
	DepthIntepretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec2 dist		=depthToFadeDistance(depth.xx,2.0*(IN.texCoords-0.5),depthInterpretationStruct,tanHalfFov);
	vec4 result=vec4(pow(dist.xy,vec2(0.44,0.44)),depth.z,1.0);
	if(IN.texCoords.x<viewport.x||IN.texCoords.x>viewport.x+viewport.z
		||IN.texCoords.y<viewport.y||IN.texCoords.y>viewport.y+viewport.w)
		result*=0.25;
	return result;
}

shader vec4 PS_ShowDepthMS_Forward(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthMS_PS(IN,false);
	return res;
}

shader vec4 PS_ShowDepthMS_Reverse(posTexVertexOutput IN) : SV_TARGET
{
	vec4 res=ShowDepthMS_PS(IN,true);
	return res;
}
struct vec3input
{
    vec3 position	: POSITION;
};

shader v2f Vec3InputSignatureVS(vec3input IN)
{
	v2f OUT;
    OUT.hPosition=mul(worldViewProj,vec4(IN.position.xyz,1.0));
	OUT.colour = vec4(1.0,1.0,1.0,1.0);
    return OUT;
}

struct v2f_cubemap
{
    vec4 hPosition	: SV_POSITION;
    vec3 wDirection	: TEXCOORD0;
};


shader v2f_cubemap VS_DrawCubemap(vec3input IN) 
{
    v2f_cubemap OUT;
    OUT.hPosition	=mul(worldViewProj,vec4(IN.position.xyz,1.0));
    OUT.wDirection	=normalize(IN.position.xyz);
    return OUT;
}

shader v2f_cubemap VS_DrawCubemapSphere(idOnly IN) 
{
    v2f_cubemap OUT;
	// we have (latitudes+1)*(longitudes+1)*2 id's
	uint vertex_id		=IN.vertex_id;
	uint latitude_strip	=vertex_id/(longitudes+1)/2;
	vertex_id			-=latitude_strip*(longitudes+1)*2;
	uint longitude		=(vertex_id)/2;
	vertex_id			-=longitude*2;
	float azimuth		=2.0*3.1415926536*float(longitude)/float(longitudes);
	float elevation		=.99*(float(latitude_strip+vertex_id)/float(latitudes+1)-0.5)*3.1415926536;
	float cos_el		=cos(elevation);
	vec3 pos			=radius*vec3(sin(azimuth)*cos_el,cos(azimuth)*cos_el,sin(elevation));
    OUT.hPosition		=mul(worldViewProj,vec4(pos.xyz,1.0));
    OUT.wDirection		=normalize(pos.xyz);
    return OUT;
}


shader vec4 PS_DrawCubemap(v2f_cubemap IN): SV_TARGET
{
	vec3 view		=-(IN.wDirection.xyz);
	vec4 result		=texture_cube(cubeTexture,view);
	result.rgb		*=exposure;
	result.rgb		=pow(result.rgb,vec3(gamma,gamma,gamma));
	vec4 u= vec4(result.rgb,1.0);
	return u;
}

group lines_3d_depth
{
	technique depth_forward
    {
		pass lines3d
		{
			SetRasterizerState(wireframeRasterizer);
			SetDepthStencilState(TestForwardDepth,0);
			SetBlendState(AlphaBlend,vec4(0.0,0.0,0.0,0.0),0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_4_0,DebugVS()));
			SetPixelShader(CompileShader(ps_4_0,DebugPS()));
		}
    }
    technique depth_reverse
    {
		pass lines3d
		{
			SetRasterizerState( wireframeRasterizer );
			SetDepthStencilState( TestReverseDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_4_0,DebugVS()));
			SetPixelShader(CompileShader(ps_4_0,DebugPS()));
		}
    }
}
fxgroup lines_3d
{
	technique lines_3d
	{
		pass lines3d
		{
			SetRasterizerState( wireframeRasterizer );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_4_0,DebugVS()));
			SetPixelShader(CompileShader(ps_4_0,DebugPS()));
		}
	}
}
technique lines_2d
{
    pass p0
    {
		SetRasterizerState( wireframeRasterizer );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2dVS()));
		SetPixelShader(CompileShader(ps_4_0,DebugPS()));
    }
}
fxgroup circle
{
	technique outline
	{
		pass p0
		{
			SetRasterizerState( wireframeRasterizer );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_4_0,CircleVS()));
			SetPixelShader(CompileShader(ps_4_0,DebugPS()));
		}
	}
	technique filled
	{
		pass p0
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(CompileShader(vs_4_0,FilledCircleVS()));
			SetPixelShader(CompileShader(ps_4_0,DebugPS()));
		}
	}
}

technique textured
{
    pass noblend
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowTexture()));
    }
    pass blend
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowTexture()));
    }
}

technique show_volume
{
    pass noblend
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowVolume()));
    }
    pass blend
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowVolume()));
    }
}

technique texturedMS
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_5_0,PS_ShowTextureMS()));
    }
}


technique vec3_input_signature
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Vec3InputSignatureVS()));
		SetPixelShader(CompileShader(ps_4_0,DebugPS()));
    }
}

technique draw_cubemap
{
    pass p0 
    {		
		SetRasterizerState( RenderFrontfaceCull );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_DrawCubemap()));
		SetPixelShader(CompileShader(ps_4_0,PS_DrawCubemap()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
    }
}
technique draw_cubemap_sphere
{
    pass p0 
    {		
		SetRasterizerState( RenderBackfaceCull );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_DrawCubemapSphere()));
		SetPixelShader(CompileShader(ps_4_0,PS_DrawCubemap()));
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
    }
}

technique show_depth
{
    pass reverse_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowDepth_Reverse()));
    }
    pass forward_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowDepth_Forward()));
    }
}
technique show_depth_ms
{
    pass reverse_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthMS_Reverse()));
    }
    pass forward_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_5_0,PS_ShowDepthMS_Forward()));
    }
}
#ifndef GLSL
technique compacted_texture
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_Quad()));
		SetPixelShader(CompileShader(ps_5_0,PS_CompactedTexture()));
    }
}
#endif