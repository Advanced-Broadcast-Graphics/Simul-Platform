// Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/spherical_harmonics_constants.sl"
#include "../SL/noise.sl"
#include "../SL/spherical_harmonics.sl"
// The cubemap input we are creating coefficients for.
uniform TextureCube cubemapTexture;
// A texture (l_max+1)^2 of coefficients.
uniform RWStructuredBuffer<vec4> targetBuffer;
// A buffer of nxn random sample positions. The higher res, the more accurate.
uniform RWStructuredBuffer<SphericalHarmonicsSample> samplesBufferRW;
uniform StructuredBuffer<SphericalHarmonicsSample> samplesBuffer;

#ifndef BLOCK_SIZE
#define BLOCK_SIZE 1
#endif

[numthreads(BLOCK_SIZE,BLOCK_SIZE,1)]
shader void CS_Jitter(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 pos = g * BLOCK_SIZE + t;
	pos += uint3(randomSeed, randomSeed, 0);

	// fill an N*N*2 array with uniformly distributed 
	// samples across the sphere using jittered stratification 
	float oneoverN			= 1.0/sqrtJitterSamples; 
	int a=int(pos.x);
	int b=int(pos.y);
	int i					=a*sqrtJitterSamples+b; // array index 
	// generate unbiased distribution of spherical coords 
	float x					=(a + rand(vec2(a,b))) * oneoverN; // do not reuse results 
	float y					=(b + rand(vec2(2.45*a,11.1*b))) * oneoverN; // each sample must be random 
	float theta				=2.0 * acos(sqrt(1.0 - x)); 
	float phi				=2.0 * PI * y; 
	// convert spherical coords to unit vector 
	vec3 vec				=vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)); 
	samplesBufferRW[i].dir	= vec; 
	// precompute all SH coefficients for this sample 
	int n = 0;
	for (int l = 0; l<MAX_SH_BANDS; l++)
	{
		if (l >= num_bands)
			break;
		for(int m=-l; m<=l; m++)
		{ 
//			int index = l*(l+1)/2+m; 
			samplesBufferRW[i].coeff[n++] = SH(l, m, theta, phi);
		}
	}
}

[numthreads(BLOCK_SIZE,BLOCK_SIZE,1)]
shader void CS_Clear(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos = g * BLOCK_SIZE + t;
	targetBuffer[sub_pos.x]	=vec4(0,0,0,0);
}

[numthreads(BLOCK_SIZE,BLOCK_SIZE,1)]
shader void CS_Encode(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 sub_pos						= g * BLOCK_SIZE + t;
	// The sub_pos gives the co-ordinate in the table of sam
	const float weight					=4.0*PI; 
	// divide the result by weight and number of samples 
	float factor						=weight*invNumJitterSamples; 
#if 0
	SphericalHarmonicsSample sample		=samplesBuffer[sub_pos.x];
	vec4 colour							=cubemapTexture.SampleLevel(wrapSamplerState,-sample.dir,0);
	for(int n=0;n<num_bands;n++)
	{ 
		targetBuffer[n]					+=colour;//*factor*sample.coeff[n]; 
	}
#else

	vec4 total=vec4(0,0,0,0);
	for(int n=0;n<numJitterSamples;n++)
	{ 
		SphericalHarmonicsSample shs	=samplesBuffer[n];
		vec4 colour						=texture_cube_lod(cubemapTexture,shs.dir,0);
		total							+=colour*factor*shs.coeff[sub_pos.x];
	}
	targetBuffer[sub_pos.x]=total;
#endif
}

technique jitter
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Jitter()));
    }
}

technique clear
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Clear()));
    }
}

technique encode
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Encode()));
    }
}

