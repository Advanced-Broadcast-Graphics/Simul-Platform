
#include "shader_platform.sl"
#include "../../CrossPlatform/SL/common.sl"
uniform sampler3D			densityTexture SIMUL_TEXTURE_REGISTER(0);
uniform sampler3D			lightTexture;
uniform sampler3D			lightTexture1 SIMUL_TEXTURE_REGISTER(1);
uniform sampler3D			lightTexture2 SIMUL_TEXTURE_REGISTER(2);
uniform sampler2D			maskTexture SIMUL_TEXTURE_REGISTER(3);
uniform sampler3D			ambientTexture;
uniform sampler3D			ambientTexture1 SIMUL_TEXTURE_REGISTER(4);
uniform sampler3D			ambientTexture2 SIMUL_TEXTURE_REGISTER(5);
uniform sampler3D			volumeNoiseTexture SIMUL_TEXTURE_REGISTER(6);
uniform RWTexture3D<uchar4> targetTexture SIMUL_RWTEXTURE_REGISTER(0);
uniform RWTexture3D<float>	targetTexture1 SIMUL_RWTEXTURE_REGISTER(1);
uniform Texture3D			inputTexture3D;
uniform Texture3D			inputTexture3DB;
uniform RWTexture3D<vec4>	outputTexture;

#include "../../CrossPlatform/SL/render_states.sl"
#include "../../CrossPlatform/SL/gpu_cloud_constants.sl"
#include "../../CrossPlatform/SL/simul_gpu_clouds.sl"

SamplerState lightSamplerState SIMUL_SAMPLER_REGISTER(8);
SamplerState densSamplerState SIMUL_SAMPLER_REGISTER(9);

struct vertexOutput
{
    vec4 hPosition	: SV_POSITION;
	vec2 texCoords	: TEXCOORD0;		
};

shader vertexOutput VS_Main(idOnly IN)
{
    vertexOutput OUT;
	vec2 poss[4]=
	{
		{ 1.0, 0.0},
		{ 1.0, 1.0},
		{ 0.0, 0.0},
		{ 0.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	pos.y			=yRange.x+pos.y*yRange.y;
	vec4 vert_pos	=vec4(vec2(-1.0,1.0)+2.0*vec2(pos.x,-pos.y),1.0,1.0);
    OUT.hPosition	=vert_pos;
    OUT.texCoords	=pos;
    return OUT;
}

struct ColourDepthOutput
{
	vec4 colour SIMUL_TARGET_OUTPUT;
	float depth	SIMUL_DEPTH_OUTPUT;
};

shader ColourDepthOutput PS_DensityMask(vertexOutput IN)
{
	ColourDepthOutput result;
	float dens					=GpuCloudMask(IN.texCoords, maskCentre, maskRadius,maskFeather, maskThickness,transformMatrix);
	result.colour				=vec4(dens,dens,dens,dens);
	result.depth				=dens;
	return result;
}

vec3 convertPosToTexc(uint3 pos,uint3 dims)
{
	return (vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
}

vec4 advect(vec3 texc		// grid coordinates
			,float timestep
			,vec3 cloudScales				// 1 / grid scale
			,vec3 velocity			// input velocity
			,Texture3D inputField)    // qty to advect
{
  // follow the velocity field "back in time"
   vec3 source_texc		= texc - timestep * velocity/cloudScales;
  // interpolate and write to the output fragment
	vec4 newval			= texture_wwc_lod(inputField,source_texc,0);
	return newval;
}

CS_LAYOUT(8,8,8)
shader void CS_InitSimulation( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos				=g*8+t;
	vec3 texc				=convertPosToTexc(pos,dims);
	vec4 lookup				=TEXTURE_LOAD_3D(inputTexture3D,pos);
	vec2 from_ctr			=texc-vec2(0.5,0.5);
	//float spd				=.001/pow((1000.0*length(from_ctr)+0.01),3.0);
	vec3 init_vel			=0.001*vec3(1.0,0,0)*texture_wrap_lod(volumeNoiseTexture,texc,0).x;//0*exp(-9*from_ctr.y*from_ctr.y)*vec3(1.0,0,0);//
	vec4 newval				=vec4(0,0,0,lookup.z);
	IMAGE_STORE_3D(outputTexture,pos,newval);
}

CS_LAYOUT(8,8,8)
shader void CS_Advection( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos				=g*8+t;
	vec3 texc				=convertPosToTexc(pos,dims);
	vec4 c1					=TEXTURE_LOAD_3D(inputTexture3D,pos);
	// transformMatrix is world-to-cloud transform
	vec4 newval				=advect(texc,time_step,cloudScalesKm,c1.xyz,inputTexture3D);
	float emission_diff		=step(length(texc-vec3(.5,.5,.5)),0.1);
//	newval.w				=saturate(newval.w+0.1*emission_diff);
	/// ADD noise:
	vec3 noisespace_texc	=texc*vec3(noiseScale)+vec3(time,0,0);
//	if(texc.x<0.2)
//		newval.xyz			=10000.0*vec3(0,1,0)*saturate((texc.x-0.0)/.2);	//texture_wrap_lod(volumeNoiseTexture,5*noisespace_texc,0).xyz;
	IMAGE_STORE_3D(outputTexture,pos,newval);
}

CS_LAYOUT(8,8,8)
shader void CS_Force( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos				=g*8+t;
	vec3 texc				=convertPosToTexc(pos,dims);
	vec4 vd					=TEXTURE_LOAD_3D(inputTexture3D,pos);
	vec3 F					=vec3(1,0,0);
	vec3 diff				=(texc-vec3(.5,.5,1))*cloudScalesKm;
	float radius			=6.0;
	float r2				=radius*radius;
	vec3 delta				=150*F*time_step*exp(-dot(diff,diff)/r2);
	vd.xyz					+=delta;
	IMAGE_STORE_3D(outputTexture,pos,vd);
}

CS_LAYOUT(8,8,8)
shader void CS_Divergence( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos		=g*8+t;
	vec3 texc		=convertPosToTexc(pos,dims);
	vec3 gridScale	=cloudScalesKm/vec3(dims);
	vec3 d			=vec3(0.5,0.5,0.5)/vec3(dims);
	vec4 wL			=texture_wwc_lod(inputTexture3D,texc-vec3(d.x,0,0),0);
	vec4 wR			=texture_wwc_lod(inputTexture3D,texc+vec3(d.x,0,0),0);
	vec4 wB			=texture_wwc_lod(inputTexture3D,texc-vec3(0,d.y,0),0);
	vec4 wF			=texture_wwc_lod(inputTexture3D,texc+vec3(0,d.y,0),0);
	vec4 wD			=texture_wwc_lod(inputTexture3D,texc-vec3(0,0,d.z),0);
	vec4 wU			=texture_wwc_lod(inputTexture3D,texc+vec3(0,0,d.z),0);
	if(pos.z==0||pos.z==dims.z-1)
		wU=wD;
	//vec3 halfrdx	=0.5/gridScale;
	float div		= ((wR.x - wL.x)/gridScale.x + (wF.y - wB.y)/gridScale.y+ (wU.z - wD.z)/gridScale.z);
	IMAGE_STORE_3D(outputTexture,pos,vec4(div,div,div,div));
}

CS_LAYOUT(8,8,8)
shader void CS_Clear3D( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos			=g*8+t;
	vec3 texc			=convertPosToTexc(pos,dims);
	vec4 bC				=alpha* texture_wwc_lod(inputTexture3DB, texc,0);
	vec3 i_g			=vec3(dims)/cloudScalesKm;		// inverse of one grid step
	vec3 i_g2			=i_g*i_g;
	// evaluate Jacobi iteration
	float beta=i_g2.x+i_g2.y+i_g2.z;
	vec4 j = (-bC)*invBeta/beta;
	float err=abs((j.x)/(abs(j.x)+0.0000001));
	
	j.b=err;	// blue= error.
	IMAGE_STORE_3D(outputTexture,pos,j);
}

CS_LAYOUT(8,8,8)
shader void CS_Jacobi( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos			=g*8+t;
	vec3 texc			=convertPosToTexc(pos,dims);
	
	// left, right, bottom, and top x samples
	vec3 d				=vec3(1.0,1.0,1.0)/vec3(dims);
	vec3 i_g			=vec3(dims)/cloudScalesKm;		// inverse of one grid step
	vec3 i_g2			=i_g*i_g;
	vec4 xL				=texture_wwc_lod(inputTexture3D,texc - vec3(d.x,0,0),0);
	vec4 xR				=texture_wwc_lod(inputTexture3D,texc + vec3(d.x,0,0),0);
	vec4 xB				=texture_wwc_lod(inputTexture3D,texc - vec3(0,d.y,0),0);
	vec4 xF				=texture_wwc_lod(inputTexture3D,texc + vec3(0,d.y,0),0);
	vec4 xD				=texture_wwc_lod(inputTexture3D,texc - vec3(0,0,d.z),0);
	vec4 xU				=texture_wwc_lod(inputTexture3D,texc + vec3(0,0,d.z),0);
	
	vec4 x				=texture_wwc_lod(inputTexture3D,texc ,0);
	if(pos.z==0||pos.z==dims.z-1)
		i_g2.z=0;
	// b sample, from center
	vec4 bC		=alpha* texture_wwc_lod(inputTexture3DB, texc,0);
	// evaluate Jacobi iteration
	float beta	=2.0*(i_g2.x+i_g2.y+i_g2.z);
	//float beta	=2.0*i_g2.x;
	vec4 j		=((xL+xR)*i_g2.x + (xB+xF)*i_g2.y + (xU+xD)*i_g2.z - bC)*invBeta/beta;
	//vec4 j		=((xL+xR+xB+xF) - bC)*invBeta/4.0;

	float err	=abs((x.x-j.x)/(abs(j.x)+0.0000001));
	
	j.b			=err;	// blue= error.
	j.ga		=j.r;
	IMAGE_STORE_3D(outputTexture,pos,j);
}

CS_LAYOUT(8,8,8)
shader void CS_SubtractGradient( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(outputTexture,dims.x,dims.y,dims.z);
	uint3 pos			=g*8+t;
	vec3 texc			=convertPosToTexc(pos,dims);
	
	vec3 d				=vec3(1.0,1.0,1.0)/vec3(dims);
	float pL			=texture_wwc_lod(inputTexture3DB,texc-vec3(d.x,0,0),0).x;
	float pR			=texture_wwc_lod(inputTexture3DB,texc+vec3(d.x,0,0),0).x;
	float pB			=texture_wwc_lod(inputTexture3DB,texc-vec3(0,d.y,0),0).x;
	float pF			=texture_wwc_lod(inputTexture3DB,texc+vec3(0,d.y,0),0).x;
	float pD			=texture_wwc_lod(inputTexture3DB,texc-vec3(0,0,d.z),0).x;
	float pU			=texture_wwc_lod(inputTexture3DB,texc+vec3(0,0,d.z),0).x;
	
	if(pos.z==0||pos.z==dims.z-1)
		pU=pD;
	vec3 gridScale		=cloudScalesKm/vec3(dims);
	vec4 uNew			=texture_wwc_lod(inputTexture3D, texc,0);
	uNew.xyz			-= 0.5 * vec3(pR-pL,pF-pB,pU-pD)/gridScale;
	if(pos.z==0||pos.z==dims.z-1)
		uNew.z=0;
	IMAGE_STORE_3D(outputTexture,pos,uNew);
}

CS_LAYOUT(8,8,8)
shader void CS_SimToTarget( uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID )
{
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(targetTexture,dims.x,dims.y,dims.z);
	uint3 pos			=g*8+t;
	vec3 texc			=convertPosToTexc(pos,dims);
	vec4 c1				=TEXTURE_LOAD_3D(inputTexture3D,pos);
	float h				=saturate(0.5+float(pos.z)/float(dims.z));
	float dens			=saturate(c1.w);
	//dens				*=saturate(h/zPixel-0.5)*saturate((1.0-h)/zPixel-1.5);
	vec4 res			=vec4(h,h,dens,0);
	IMAGE_STORE_3D(targetTexture,pos,res);
	//outputTexture3d[pos].rgba=res;
}

CS_LAYOUT(8,8,8)
shader void CS_Density(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 sub_pos = g * 8 + t;
	uint3 pos					=sub_pos+threadOffset;
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(targetTexture1,dims.x,dims.y,dims.z);
	uint3 noise_dims;
	GET_DIMENSIONS_3D(volumeNoiseTexture,noise_dims.x,noise_dims.y,noise_dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 densityspace_texcoord	=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
	vec3 noisespace_texcoord	=(densityspace_texcoord+vec3(0,0,0.0*zPixel))*vec3(noiseScale)+vec3(1.0,1.0,0);
	// noise_texel is the size of a noise texel
	float noise_texel			=1.0/float(noise_dims.z);
	float height				=noiseScale.z;
	float noise_val				=NoiseFunction(volumeNoiseTexture,noisespace_texcoord,octaves,persistence,time,height,noise_texel);
	float hm					=humidity*GetHumidityMultiplier2(densityspace_texcoord.z,baseLayer,transition,upperDensity)*texture_clamp_lod(maskTexture,densityspace_texcoord.xy,0).x;
	float dens					=saturate((noise_val+2.0*hm-1.0)/diffusivity);
	dens						*=saturate(densityspace_texcoord.z/zPixel-0.5)*saturate((1.0-0.5*zPixel-densityspace_texcoord.z)/zPixel);
	dens						=saturate(dens);
	IMAGE_STORE_3D(targetTexture1,int3(pos),vec4(dens,dens,dens,dens));
}

CS_LAYOUT(8, 8, 8)
shader void CS_Density_DontWrap(uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID)	//SV_DispatchThreadID gives the combined id in each dimension.
{
	uint3 sub_pos = g * 8 + t;
	uint3 pos = sub_pos + threadOffset;
	uint3 dims;
	GET_IMAGE_DIMENSIONS_3D(targetTexture1, dims.x, dims.y, dims.z);
	uint3 noise_dims;
	GET_DIMENSIONS_3D(volumeNoiseTexture, noise_dims.x, noise_dims.y, noise_dims.z);
	if (pos.x >= dims.x || pos.y >= dims.y || pos.z >= dims.z)
		return;
	vec3 densityspace_texcoord = (vec3(pos) + vec3(0.5, 0.5, 0.5));

	densityspace_texcoord/=vec3(dims);

	vec3 noisespace_texcoord = (densityspace_texcoord + vec3(0, 0, 0.0*zPixel))*vec3(noiseScale) + vec3(1.0, 1.0, 0);

	float noise_texel = 1.0 / float(noise_dims.z);


	float height = noiseScale.z;
	float noise_val = NoiseFunction(volumeNoiseTexture, noisespace_texcoord, octaves, persistence, time, height, noise_texel);
	float hm = humidity*GetHumidityMultiplier2(densityspace_texcoord.z, baseLayer, transition, upperDensity)*texture_clamp_lod(maskTexture, densityspace_texcoord.xy, 0).x;
	float dens = saturate((noise_val + 2.0*hm - 1.0) / diffusivity);
	dens *= saturate(densityspace_texcoord.z / zPixel - 0.5)*saturate((1.0 - 0.5*zPixel - densityspace_texcoord.z) / zPixel);
	dens = saturate(dens);
	if (pos.x == 0 || pos.y == 0 || pos.x == dims.x - 1 || pos.y == dims.y - 1)
		dens = 0;
	IMAGE_STORE_3D(targetTexture1, int3(pos), vec4(dens, dens, dens, dens));
}




float glow=0.1;

CS_LAYOUT(8,8,1)
shader void CS_Lighting(uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID)
{
	uint3 sub_pos = uint3(g.xy * 8 + t.xy,g.z+t.z);
	uint3 dims;
	uint3 pos						=sub_pos+threadOffset;
	GET_IMAGE_DIMENSIONS_3D(targetTexture1,dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	float direct_light				=1.0;
	IMAGE_STORE_3D(targetTexture1,int3(pos.xy,0),vec4(1.0,1.0,1.0,1.0));
	int C=1;
	for(uint i=1;i<dims.z;i++)
	{
		uint3 idx					=uint3(pos.xy,i);
		vec4 v=vec4(direct_light,0,0,0);
		IMAGE_STORE_3D(targetTexture1,idx,v);

		for(int j=0;j<C;j++)
		{
			vec3 lightspace_texcoord	=vec3(pos.xy,float(i)+0.5+float(j)/float(C))/vec3(dims);
			vec3 densityspace_texcoord	=(mul(transformMatrix,vec4(lightspace_texcoord,1.0))).xyz;
			float density				=sampleLod(densityTexture,densSamplerState, densityspace_texcoord, 0).x;
			direct_light				*=exp(-extinctions.x*density*stepLength/float(C));
		}
		//if(density==0)
		//	direct_light=1.0;
	}
}

CS_LAYOUT(8,8,1)
shader void CS_SecondaryLighting(uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID)
{
	uint3 sub_pos = uint3(g.xy * 8 + t.xy, g.z + t.z);
	int3 dims;
	int3 pos						=int3(sub_pos)+int3(threadOffset);
	GET_IMAGE_DIMENSIONS_3D(targetTexture1,dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	float indirect_light			=0.0;
	if(pos.z>0)
	{
		int Z			=pos.z-1;
		int x1			=(pos.x+2)%dims.x;
		int xn			=(pos.x+dims.x-2)%dims.x;
		int y1			=(pos.y+2)%dims.y;
		int yn			=(pos.y+dims.y-2)%dims.y;
		int3 sample_pts[5]	={int3(pos.xy,Z),int3(xn,pos.y,Z),int3(x1,pos.y,Z),int3(pos.x,yn,Z),int3(pos.x,y1,Z)};
		for(int i=0;i<5;i++)
		{
			//vec3 lightspace_texcoord	=(vec3(sample_pts[i])+0.5)/vec3(dims);
			//vec3 densityspace_texcoord	=(mul(transformMatrix,vec4(lightspace_texcoord,1.0))).xyz;
			//float density				=densityTexture.SampleLevel(wwcSamplerState,densityspace_texcoord,0).x;
			indirect_light	+=IMAGE_LOAD_3D(targetTexture1,sample_pts[i]).x;
		}
		indirect_light	/=5.0;
	}
	int i=pos.z;
	{
		uint3 idx					=uint3(pos.xy,i);
		vec3 lightspace_texcoord	=(vec3(idx)+0.5)/vec3(dims);

		vec3 densityspace_texcoord	=(mul(transformMatrix,vec4(lightspace_texcoord,1.0))).xyz;
		float density				= sampleLod(densityTexture,densSamplerState, densityspace_texcoord, 0).x;
		indirect_light				*=exp(-extinctions.y*density*stepLength);
		
		//NOTE: Causes artifact underneath clouds:
		if(density==0&&pos.z<dims.z-1)
			indirect_light			=1.0;//-(1.0-indirect_light)*exp(-5.0*stepLength);
		IMAGE_STORE_3D(targetTexture1,idx,vec4(indirect_light,indirect_light,indirect_light,indirect_light));
	}
}
CS_LAYOUT(8,8,1)
shader void CS_GaussianFilter(uint3 g:SV_GroupID,uint3 t:SV_GroupThreadID)
{
	uint3 sub_pos = uint3(g.xy * 8 + t.xy, g.z + t.z);
	uint3 dims;
	uint3 pos		=sub_pos+threadOffset;
	GET_DIMENSIONS_3D(targetTexture1,dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	float light		=IMAGE_LOAD_3D(lightTexture1,pos).x;
	if(pos.z>0)
	{
		int Z		=pos.z-1;
		light		+=IMAGE_LOAD_3D(lightTexture1,int3(pos+gaussianOffset)).x;
		light		+=IMAGE_LOAD_3D(lightTexture1,int3(pos.xy,pos.z+1)).x;
	}
}

float filterLight(Texture3D tex,vec3 texc)
{
	uint3 dims;
	GET_DIMENSIONS_3D(tex,dims.x,dims.y,dims.z);
	vec3 up			=vec3(0,0,1.0/float(dims.z));
	vec3 forward	=vec3(0,1.0/float(dims.y),0);
	vec3 right		=vec3(1.0/float(dims.x),0,0);
#ifdef GLSL
	vec3 offsets[7];
	offsets[0]=vec3(0,0,0);
	offsets[1]=up;
	offsets[2]=-up;
	offsets[3]=right;
	offsets[4]=-right;
	offsets[5]=forward;
	offsets[6]=-forward;
#else
	vec3 offsets[]	={vec3(0,0,0),up,-up,right,-right,forward,-forward};
#endif
	float res=0.0;
	for(int i=0;i<7;i++)
		res+=sampleLod(tex,lightSamplerState,texc+offsets[i],0).x;
	return res/7.0;
}

CS_LAYOUT(8,8,8)
shader void CS_Transform(uint3 g : SV_GroupID, uint3 t : SV_GroupThreadID)
{
	uint3 dims;
	uint3 sub_pos = g * 8 + t;
	uint3 pos=sub_pos+threadOffset;
	GET_IMAGE_DIMENSIONS_3D(targetTexture,dims.x,dims.y,dims.z);
	if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)
		return;
	vec3 densityspace_texcoord	=(pos.xyz+vec3(0.5,0.5,0.5))/vec3(dims);
	vec3 ambient_texcoord		=vec3(densityspace_texcoord.xy,1.0-zPixel/2.0-densityspace_texcoord.z);
	vec3 lightspace_texcoord	=mul(transformMatrix,vec4(densityspace_texcoord+vec3(0,0,zPixel),1.0)).xyz;
	vec2 light_lookup			=vec2(filterLight(lightTexture1,lightspace_texcoord)
										,sample_lod(lightTexture2,lightSamplerState,lightspace_texcoord,0).x);
	
	vec2 amb_texel				=vec2(	sample_lod(ambientTexture1,wwcSamplerState,ambient_texcoord,0).x
										,sample_lod(ambientTexture2,wwcSamplerState,ambient_texcoord,0).x);
	float ambient_lookup		=saturate(0.5*(amb_texel.x+amb_texel.y));
	float density				=saturate(sample_lod(densityTexture,wwcSamplerState,densityspace_texcoord,0).x);

    vec4 res					=vec4(light_lookup.y,light_lookup.x,density,ambient_lookup);
	IMAGE_STORE_3D(targetTexture,pos,res);
}

technique density_mask
{
    pass p0 
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState(ReverseDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(CompileShader(vs_4_0,VS_Main()));
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_4_0,PS_DensityMask()));
    }
}

technique gpu_density_compute
{
	pass wrap
	{
		SetComputeShader(CompileShader(cs_5_0, CS_Density()));
	}
    pass dont_wrap 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Density_DontWrap()));
    }
}

technique gpu_lighting_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Lighting()));
    }
}

technique gpu_secondary_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_SecondaryLighting()));
    }
}

technique gpu_transform_compute
{
    pass p0 
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Transform()));
    }
}

technique init_simulation
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_InitSimulation()));
    }
}

technique advection
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Advection()));
    }
}

technique force
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Force()));
    }
}

technique divergence
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Divergence()));
    }
}

technique jacobi
{
    pass clear
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Clear3D()));
    }
    pass iterate
    {
		SetComputeShader(CompileShader(cs_5_0,CS_Jacobi()));
    }
}

technique subtract_gradient
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_SubtractGradient()));
    }
}

technique simulated_to_target
{
    pass p0
    {
		SetComputeShader(CompileShader(cs_5_0,CS_SimToTarget()));
    }
}
